/* Generated By: AdqlStoX.jjt,v 1.2 2008/09/08 15&JJTree&JavaCC: Do not edit this line. AdqlStoX.java */
package org.astrogrid.adql ;

import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;
import java.util.HashSet ;
import java.util.ArrayList ;
import java.util.List ;
import org.astrogrid.adql.beans.* ;
import org.astrogrid.adql.AdqlParser.SyntaxOption;

/**
 * AdqlStoX         
 * <p>
 * AdqlStoX is a generated class. It started life as a JavaCC file with a file extension of .jjt, 
 * producing a syntax tree.
 * All of the classes with a name prefix of "AST_" were emitted as part of this syntax tree.
 * Other classes emitted as an adjunct of AdqlStoX are:
 * <blockquote><pre>
 * org.astrogrid.adql.AdqlStoXConstants
 * org.astrogrid.adql.AdqlStoTokenManager 
 * org.astrogrid.adql.AdqlStoXTreeConstants 
 * org.astrogrid.adql.ParseException 
 * org.astrogrid.adql.SimpleCharacterStream
 * org.astrogrid.adql.SimpleNode
 * org.astrogrid.adql.Token
 * org.astrogrid.adql.TokenMgrError     
 * </pre></blockquote>
 * There is one emitted interface:
 * org.astrogrid.adql.SimpleNode
 * <p>
 * AdqlStoX takes text in the form of Adql/s and parsers it into xml Adql/x format.
 * Adql/s is based upon SQL/92 with astronomical extensions. However, AdqlStoX is wrapped
 * by class org.astrogrid.adql.AdqlParser. All public and protected methods should
 * be invoked only from AdqlParser!
 * <p>
 * For those who are interested, and have access to the source for AdqlStoX.jtt,
 * the following details may be of use in reconciling the method names to the BNF
 * specification of ADQL. The methods are not documented, and will probably remain
 * undocumented, although some constructors are approximately mirrored within AdqlParser.  
 * However, there is a naming convention for methods, which is aimed at making the match
 * with the BNF diagrams as clear as possible...
 * <p>
 * (1) All methods which are quoted bnf statements follow the bnf format, 
 *     with any embedded dashes (-) removed from the name.
 *     Thus the statment &lt;comparison_predicate> from the SQL/92 standard
 *     will have a corresponding method with a name similar to comparison_predicate().
 *     However, such methods are decorated in a particular way, for which see
 *     points (2) and (3) below. All methods which are tantamount to quoted
 *     bnf will have the standard syntax as a comment embedded within the source. However,
 *     this style of comment is private to the original .jjt file and is not emitted
 *     into the java code. 
 *     Thus:
 * <blockquote><pre>
 *     //S:
 *     // &lt;row_value_constructor> &lt;comp_op> &lt;row_value_constructor>
 * </pre></blockquote>
 * <p>
 * (2) Methods which follow exactly the SQL/92 syntax at a shallow level are suffixed _S.
 *     Thus comparison_predicate_S() represents the SQL/92 standard syntax. Shallow implies
 *     that the syntax can still vary from the standard within statements quoted
 *     within the given construct. This is usually pretty obvious from the quoted statements
 *     (eg: quoted statement some_statement_A() means an ADQL variation, see next point), 
 *     but be aware that it is possible for variations to be deeply embedded.
 *     NB: A statement that is just a synonym for another statement will take
 *         the quoted statement's decoration. This is the one exception.
 * <p>
 * (3) Methods which are varied for some reason within ADQL, or are simply
 *     specific to ADQL, are suffixed _A.
 *     Thus comparison_predicate_A() represents an ADQL deviation.
 * <p>
 * (4) Some methods are introduced as implementations of part of a syntax.
 *     This is just to make for a neater structure. These methods follow
 *     the standard Java OO naming convention and are not decorated, 
 *     eg: numericValueExpressionList().
 * <p>
 * (5) Some methods are experimental and not connected to the main parsing path; ie: they 
 *     do not take part in any parse unless a coding change is made to re-incorporate them.
 *     These begin with an underscore; eg: _datetime_value_expression_S().
 *
 * There is built-in documentation to help in supporting BNF syntax diagrams. This built-in
 * documentation consists of special comments throughout the code. It is separate from the
 * above four conventions and must be maintained by the developer to correspond to the working
 * of the parser. Thus the resulting BNF documentation represents what the parser does. 
 * This seems a little back-to-front but is reasonably thorough in its results. There are two 
 * sorts of comments: singletons and multiples, depending on whether the BNF definition is on 
 * one or more lines. Two examples are given below:
 * <p>
 * <blockquote><pre>
 *     bnf-single &lt;boolean_factor> ::= [ NOT ] &lt;boolean_test> 
 *     bnf-start
 *        &lt;between_predicate> ::=
 *          &lt;value_expression> [ NOT ] BETWEEN
 *          &lt;value_expression> AND &lt;value_expression>
 *     bnf-end
 * </pre></blockquote>
 * (Real ones have to be positioned at the beginning of a line with each line prefixed by
 * the string " * " exactly. )
 * <p>
 * A utility programme BnfExtractor extracts these from the source and places them in 
 * suitable files (or to standard out). BnfExtractor produces output in two formats:
 * plain text and html. 
 * <p>     
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Sep 2006
 */
public class AdqlStoX/*@bgen(jjtree)*/implements AdqlStoXTreeConstants, AdqlStoXConstants {/*@bgen(jjtree)*/
  protected JJTAdqlStoXState jjtree = new JJTAdqlStoXState();
        private static Log log = LogFactory.getLog( AdqlStoX.class ) ;

        private static final int DONT_CHANGE_SIGN = 1 ;

        protected Tracker tracker ;
        protected AdqlParser parser ;

        void jjtreeOpenNodeScope( org.astrogrid.adql.Node n ) {
                ((SimpleNode)n).firstToken = getToken(1);
        }

    void jjtreeCloseNodeScope( org.astrogrid.adql.Node n ) {
        ((SimpleNode)n).lastToken = getToken(0);
    }


        private void enterTrace( String entry ) {
                log.trace( parser.getIndent().toString() + "enter: " + entry ) ;
                parser.indentPlus() ;
        }

    private void exitTrace( String entry ) {
        parser.indentMinus() ;
                log.trace( parser.getIndent().toString() + "exit : " + entry ) ;
        }

        private boolean lookForStringOperator() {
                return true ;
        }

/*
 * Dummy Tokens.
 * This section is really comment only, consisting of documentation
 * of things that are not used (so far) but are there for completeness
 * of the BNF diagrams.
 *
 * bnf-start
 *  <delimiter_token> ::=
 *        <character_string_literal>
 *    |   <delimited_identifier>
 *    |   <SQL_special_character>
 *    |   <not_equals_operator>
 *    |   <greater_than_or_equals_operator>
 *    |   <less_than_or_equals_operator>
 *    |   <concatenation_operator>
 *    |   <double_period>
 *    |   <left_bracket>
 *    |   <right_bracket>
 * bnf-end
 * bnf-start
 *  <nondelimiter_token> ::= 
 *      <regular_identifier>
 *    | <keyword>
 *    | <unsigned_numeric_literal>
 * bnf-end
 * bnf-start
 *  <token> ::= 
 *      <nondelimiter_token>
 *    | <delimiter_token>
 * bnf-end
 * bnf-single <double_period> ::= ..
 * bnf-single <concatenation_operator> ::= ||
 *
 */

/*
 * actual_identifier_S
 *
 * bnf-single <identifier> ::= <regular_identifier> | <delimited_identifier>
 *
 */
  final public void actual_identifier_S() throws ParseException {
 /*@bgen(jjtree) ActualIdentifier */
    AST_ActualIdentifier jjtn000 = new AST_ActualIdentifier(this, JJTACTUALIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "actual_identifier_S()" ) ;
    Token t = null ;
    try {
      if (parser.checkSomeReservedWords() == false) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REGULAR_IDENTIFIER:
        t = jj_consume_token(REGULAR_IDENTIFIER);
        break;
      case DELIMITED_IDENTIFIER:
        t = jj_consume_token(DELIMITED_IDENTIFIER);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isDebugEnabled() ) {
                        if( parser.isDebugIdentifiers() ) {
                                log.debug( "identifier: " + t.image ) ;
                        }
                }
                if( log.isTraceEnabled() ) exitTrace ( "actual_identifier_S()" ) ;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public Long signed_integer_S() throws ParseException {
        Token tSign = null ;
        Token tInteger = null ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS_SIGN:
    case MINUS_SIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_SIGN:
        tSign = jj_consume_token(PLUS_SIGN);
        break;
      case MINUS_SIGN:
        tSign = jj_consume_token(MINUS_SIGN);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    tInteger = jj_consume_token(UNSIGNED_INTEGER);
       if( tInteger != null ) {
          Long l = new Long( tInteger.image ) ;
          if( tSign != null ) {
                 if( tSign.image.startsWith( "-" ) ) {
                        l = new Long( -l.longValue() ) ;
                 }
          }
          {if (true) return l ;}
       }
    throw new Error("Missing return statement in function");
  }

/*
 * between_predicate_A
 *
 * bnf-start
 * <between_predicate> ::=
 *     <value_expression> [ NOT ] BETWEEN
 *     <value_expression> AND <value_expression>
 * bnf-end
 *
 */
  final public void between_predicate_A() throws ParseException {
 /*@bgen(jjtree) BetweenPredicate */
        AST_BetweenPredicate jjtn000 = new AST_BetweenPredicate(this, JJTBETWEENPREDICATE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "between_predicate_A()" ) ;
    try {
      restricted_value_expression_A(AdqlParser.ARG_ELEMENT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                     jjtn000.setNot();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(BETWEEN);
      restricted_value_expression_A(AdqlParser.ARG_ELEMENT);
      jj_consume_token(AND);
      restricted_value_expression_A(AdqlParser.ARG_ELEMENT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "between_predicate_A()" ) ;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * boolean_primary_S
 *
 * bnf-start
 *  <boolean_primary> ::=
 *     | <left_paren> <search_condition> <right_paren> 
 *       <predicate> 
 * bnf-end
 *
 */
  final public void boolean_primary_S() throws ParseException {
 /*@bgen(jjtree) BooleanPrimary */
        AST_BooleanPrimary jjtn000 = new AST_BooleanPrimary(this, JJTBOOLEANPRIMARY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "boolean_primary_S()" ) ;
    try {
      try {
        if (jj_2_1(2147483647)) {
          jj_consume_token(LEFT_PAREN);
                       jjtn000.setParenthesized() ;
          search_condition_S();
                       jjtn000.popPosition() ;
          jj_consume_token(RIGHT_PAREN);
        } else if (jj_2_2(1)) {
          predicate_A();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException pex) {
           {if (true) throw pex ;}
      } finally {
        if( log.isTraceEnabled() ) exitTrace ( "boolean_primary_S()" ) ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * boolean_term_S
 *
 * bnf-start
 *  <boolean_term> ::=
 *      <boolean_factor>
 *    | <boolean_term> AND <boolean_factor>
 * bnf-end
 *
 */
  final public void boolean_term_S() throws ParseException {
 /*@bgen(jjtree) BooleanTerm */
        AST_BooleanTerm jjtn000 = new AST_BooleanTerm(this, JJTBOOLEANTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "boolean_term_S()" ) ;
    try {
      boolean_factor_S();
      if (jj_2_3(3)) {
        jj_consume_token(AND);
                            jjtn000.setAnd() ;
        boolean_term_S();
      } else {
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "boolean_term_S()" ) ;
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * boolean_factor_S
 *
 * bnf-start
 *   <boolean_factor> ::= [ NOT ] <boolean_primary>
 * bnf-end
 */
  final public void boolean_factor_S() throws ParseException {
 /*@bgen(jjtree) BooleanFactor */
        AST_BooleanFactor jjtn000 = new AST_BooleanFactor(this, JJTBOOLEANFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "boolean_factor_S()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                            jjtn000.setInverse();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      boolean_primary_S();
                    if( jjtn000.isInverse() ) {
                            jjtn000.popPosition();
                    }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "boolean_factor_S()" ) ;
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * like_predicate_A
 *
 * bnf-start
 *  <like_predicate> ::=
 *      <match_value> [ NOT ] LIKE <pattern>
 * bnf-end
 *
 */
  final public void like_predicate_A() throws ParseException {
 /*@bgen(jjtree) LikePredicate */
        AST_LikePredicate jjtn000 = new AST_LikePredicate(this, JJTLIKEPREDICATE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "like_predicate_A()" ) ;
    try {
      match_value_S();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                    jjtn000.setLike(false);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(LIKE);
      pattern_A();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "like_predicate_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _caseExpression_S() throws ParseException {
    jj_consume_token(332);
  }

  final public void _castSpecification_S() throws ParseException {
    jj_consume_token(333);
  }

/*
 * character_factor_A
 *
 * bnf-start
 *  <character_factor> ::= <character_primary>
 *  !! For information only, SQL92 supports <collate_clause>
 * bnf-end
 *
 */
  final public void character_factor_A() throws ParseException {
    character_primary_A();
  }

/*
 * character_primary_A
 *
 * bnf-start v20+RFC
 *  <character_primary> ::= 
 *      <value_expression_primary>
 *    | <user_defined_function>
 * bnf-end
 * bnf-start v21-Projection
 *  <character_primary> ::= 
 *      <value_expression_primary>
 *    | <string_value_function>
 * bnf-end
 * bnf-start v20-AG
 *  <character_primary> ::= <value_expression_primary>
 * bnf-end
 *
 */
  final public void character_primary_A() throws ParseException {
    if (jj_2_4(16)) {
      string_value_function_A(null);
    } else if (jj_2_5(1)) {
      value_expression_primary_A(null);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * string_value_function_A
 *
 * bnf-start v21-Projection
 *   <string_value_function> ::=
 *       <string_geometry_function>
 *     | <user_defined_function>
 * bnf-end  
 */
  final public void string_value_function_A(String elementName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COORDSYS:
      string_geometry_function_A(elementName);
      break;
    default:
      jj_la1[6] = jj_gen;
      if (jj_2_6(1)) {
        user_defined_function_A(elementName);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/*
 * string_geometry_function_A
 *
 * bnf-start v21-Projection
 *   <string_geometry_function> ::= <extract_coordsys>
 * bnf-end
 * bnf-start v21-Projection 
 *   <extract_coordsys> ::= COORDSYS <left_paren> <geometry_value_expression> <right_paren>
 * bnf-end
 */
  final public void string_geometry_function_A(String elementName) throws ParseException {
                                                                                /*@bgen(jjtree) SystemDefinedFunction */
  AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(COORDSYS);
      jj_consume_token(LEFT_PAREN);
      geometry_value_expression_A(elementName);
      jj_consume_token(RIGHT_PAREN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * character_string_literal_A
 *
 * bnf-start
 *  <character_string_literal> ::=
 *     <quote> [ <character_representation>... ] <quote>
 *     [ { <separator>... <quote> [ <character_representation>... ] <quote> }... ]
 * bnf-end
 *
 * bnf-start
 * <character_representation> ::= <nonquote_character> | <quote_symbol>
 * !! A way of allowing a single quote to be escaped by a single quote.
 * bnf-end
 * bnf-single <quote_symbol> ::= <quote> <quote>
 * bnf-single <separator> ::= { <comment> | <space> | <newline> }...
 *
 */
  final public void character_string_literal_A() throws ParseException {
                                                             /*@bgen(jjtree) CharacterStringLiteral */
  AST_CharacterStringLiteral jjtn000 = new AST_CharacterStringLiteral(this, JJTCHARACTERSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ASCIIStringLiteral();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void ASCIIStringLiteral() throws ParseException {
                                                 /*@bgen(jjtree) ASCIIStringLiteral */
  AST_ASCIIStringLiteral jjtn000 = new AST_ASCIIStringLiteral(this, JJTASCIISTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        ASCIIStringLiteralPart();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASCII_STRING_LITERAL:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_1;
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void ASCIIStringLiteralPart() throws ParseException {
                                                         /*@bgen(jjtree) ASCIIStringLiteralPart */
  AST_ASCIIStringLiteralPart jjtn000 = new AST_ASCIIStringLiteralPart(this, JJTASCIISTRINGLITERALPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(ASCII_STRING_LITERAL);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void bit_string_literal_A() throws ParseException {
                                                 /*@bgen(jjtree) BitStringLiteral */
  AST_BitStringLiteral jjtn000 = new AST_BitStringLiteral(this, JJTBITSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_STRING_LITERAL:
        jj_consume_token(BIT_STRING_LITERAL);
        break;
      case HEX_STRING_LITERAL:
        jj_consume_token(HEX_STRING_LITERAL);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( !parser.isSyntaxSet( SyntaxOption.BITWISE_MANIPULATION) ) {
                    tracker.setError( "Reference Implementation: bit/hex literals and bit manipulation not supported" ) ;
                }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * character_value_expression_S
 *
 * bnf-start
 *  <character_value_expression> ::= <concatenation> | <character_factor>
 * bnf-end
 *
 * bnf-start
 *  <concatenation> ::= <character_value_expression> <concatenation_operator> <character_factor>
 * bnf-end
 *
 */
  final public void character_value_expression_S(String elementName) throws ParseException {
 /*@bgen(jjtree) CharacterValueExpression */
        AST_CharacterValueExpression jjtn000 = new AST_CharacterValueExpression(this, JJTCHARACTERVALUEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "character_value_expression_S()" ) ;
    try {
      character_factor_A();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONCATENATION_OPERATOR:
        jj_consume_token(CONCATENATION_OPERATOR);
        character_value_expression_S(elementName);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "character_value_expression_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * column_name_S
 *
 * bnf-single <column_name> ::= <identifier>
 *
 */
  final public void column_name_S() throws ParseException {
 /*@bgen(jjtree) ColumnName */
        AST_ColumnName jjtn000 = new AST_ColumnName(this, JJTCOLUMNNAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "column_name_S()" ) ;
    try {
      identifier_A();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "column_name_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * column_name_list_S
 *
 * bnf-single <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
 *
 */
  final public void column_name_list_S() throws ParseException {
                                             /*@bgen(jjtree) ColumnNameList */
  AST_ColumnNameList jjtn000 = new AST_ColumnNameList(this, JJTCOLUMNNAMELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      column_name_S();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        column_name_S();
      }
    } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
           }
    }
  }

/*
 * column_reference_A
 *
 * bnf-start
 *  <column_reference> ::= [ <qualifier> <period> ] <column_name>
 * bnf-end
 *
 */
  final public void column_reference_A(String elementName) throws ParseException {
 /*@bgen(jjtree) ColumnReference */
        AST_ColumnReference jjtn000 = new AST_ColumnReference(this, JJTCOLUMNREFERENCE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "column_reference_A()" ) ;
        jjtn000.pushPosition( elementName ) ;
    try {
      if (jj_2_7(6)) {
        columnOwnership();
        identifier_A();
        jj_consume_token(PERIOD);
        column_name_S();
      } else if (jj_2_8(5)) {
        identifier_A();
        jj_consume_token(PERIOD);
        column_name_S();
      } else if (jj_2_9(1)) {
        column_name_S();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition( elementName ) ;
                if( log.isTraceEnabled() ) exitTrace ( "column_reference_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * value_expression_primary_A
 *
 * NB: Referred in some sources as <common_primary>
 *
 * bnf-start
 *  <value_expression_primary> ::=
 *      <unsigned_value_specification>
 *    | <column_reference>
 *    | <set_function_specification>
 *    | <left_paren> <value_expression> <right_paren>
 * bnf-end
 *
 */
  final public void value_expression_primary_A(String elementName) throws ParseException {
 /*@bgen(jjtree) ValueExpressionPrimary */
        AST_ValueExpressionPrimary jjtn000 = new AST_ValueExpressionPrimary(this, JJTVALUEEXPRESSIONPRIMARY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "value_expression_primary_A()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASCII_STRING_LITERAL:
      case BIT_STRING_LITERAL:
      case HEX_STRING_LITERAL:
      case APPROXIMATE_NUMERIC_LITERAL:
      case UNSIGNED_INTEGER:
      case EXACT_NUMERIC_LITERAL:
        unsigned_value_specification_S();
        break;
      default:
        jj_la1[11] = jj_gen;
        if (jj_2_10(1)) {
          column_reference_A(elementName);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AVG:
          case COUNT:
          case MAX:
          case MIN:
          case SUM:
            set_function_specification_S();
            break;
          case LEFT_PAREN:
            jj_consume_token(LEFT_PAREN);
                    jjtn000.setParenthesized( elementName );
            value_expression_A(AdqlParser.ARG_ELEMENT);
                    jjtn000.popPosition() ;
            jj_consume_token(RIGHT_PAREN);
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "value_expression_primary_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * comp_op_S
 *
 * bnf-start
 *  <comp_op> ::=
 *      <equals_operator>
 *    | <not_equals_operator>
 *    | <less_than_operator>
 *    | <greater_than_operator>
 *    | <less_than_or_equals_operator>
 *    | <greater_than_or_equals_operator>
 * bnf-end
 *
 */
  final public void comp_op_S() throws ParseException {
 /*@bgen(jjtree) Comparison */
        AST_Comparison jjtn000 = new AST_Comparison(this, JJTCOMPARISON);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "comp_op_S()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS_OPERATOR:
        jj_consume_token(EQUALS_OPERATOR);
        break;
      case NOT_EQUALS_OPERATOR:
        jj_consume_token(NOT_EQUALS_OPERATOR);
        break;
      case LESS_THAN_OPERATOR:
        jj_consume_token(LESS_THAN_OPERATOR);
        break;
      case GREATER_THEN_OPERATOR:
        jj_consume_token(GREATER_THEN_OPERATOR);
        break;
      case LESS_THAN_OR_EQUALS_OPERATOR:
        jj_consume_token(LESS_THAN_OR_EQUALS_OPERATOR);
        break;
      case GREATER_THAN_OR_EQUALS_OPERATOR:
        jj_consume_token(GREATER_THAN_OR_EQUALS_OPERATOR);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "comp_op_S()" ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * comparison_predicate_A
 *
 * bnf-start
 *  <comparison_predicate> ::=
 *      <value_expression> <comp_op> <value_expression>
 * bnf-end
 *
 */
  final public void comparison_predicate_A() throws ParseException {
 /*@bgen(jjtree) ComparisonPredicate */
        AST_ComparisonPredicate jjtn000 = new AST_ComparisonPredicate(this, JJTCOMPARISONPREDICATE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "comparison_predicate_A()" ) ;
        jjtn000.pushPosition() ;
    try {
      restricted_value_expression_A(parser.ARG_ELEMENT);
      comp_op_S();
      restricted_value_expression_A(parser.ARG_ELEMENT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           jjtn000.popPosition() ;
           if( log.isTraceEnabled() ) exitTrace( "comparison_predicate_A()" ) ;
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * correlation_name_S
 *
 * bnf-single <correlation_name> ::= <identifier>
 *
 */
  final public void correlation_name_S() throws ParseException {
 /*@bgen(jjtree) CorrelationName */
        AST_CorrelationName jjtn000 = new AST_CorrelationName(this, JJTCORRELATIONNAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "correlation_name_S()" ) ;
    try {
      try {
        identifier_A();
      } catch (ParseException pex) {
                parser.errorSkipTo( new int[]{ token.kind } ) ;
                tracker.setError( pex ) ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          if( log.isTraceEnabled() ) exitTrace ( "correlation_name_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _datetime_factor_S() throws ParseException {
    _datetime_primary_S();
    if (jj_2_11(2)) {
      _time_zone_S();
    } else {
      ;
    }
  }

  final public void _datetime_primary_S() throws ParseException {
    if (jj_2_12(1)) {
      value_expression_primary_A(null);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT_DATE:
      case CURRENT_TIME:
      case CURRENT_TIMESTAMP:
        _datetime_value_function_S();
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void _datetime_term_S() throws ParseException {
    _datetime_factor_S();
  }

  final public void _datetime_value_expression_S() throws ParseException {
    if (jj_2_14(3)) {
      _datetime_term_S();
      label_3:
      while (true) {
        if (jj_2_13(2)) {
          ;
        } else {
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS_SIGN:
          jj_consume_token(PLUS_SIGN);
          break;
        case MINUS_SIGN:
          jj_consume_token(MINUS_SIGN);
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        _datetime_value_expression_S();
      }
    } else if (jj_2_15(1)) {
      _interval_value_expression_S();
      jj_consume_token(PLUS_SIGN);
      _datetime_term_S();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _datetime_value_function_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT_DATE:
      jj_consume_token(CURRENT_DATE);
      break;
    case CURRENT_TIME:
      jj_consume_token(CURRENT_TIME);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _time_precision_S();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      break;
    case CURRENT_TIMESTAMP:
      jj_consume_token(CURRENT_TIMESTAMP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _timestamp_precision_S();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * derived_table_S
 *
 * bnf-single <derived_table> ::= <table_subquery>
 *
 * 
 */
  final public void derived_table_S() throws ParseException {
 /*@bgen(jjtree) DerivedTable */
        AST_DerivedTable jjtn000 = new AST_DerivedTable(this, JJTDERIVEDTABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "derived_table_S()" ) ;
    try {
      table_subquery_S();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "derived_table_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _end_field_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DAY:
    case HOUR:
    case MINUTE:
    case MONTH:
    case YEAR:
      _nonsecond_datetime_field_S();
      break;
    case SECOND:
      jj_consume_token(SECOND);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _interval_fractional_seconds_precision_S();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _escape_character_A() throws ParseException {
    character_value_expression_S("todo");
  }

/*
 * exact_numeric_literal_S
 *
 * bnf-start
 *  <exact_numeric_literal> ::=
 *      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]
 *    | <period> <unsigned_integer>
 * bnf-end
 *
 */
  final public void exact_numeric_literal_S(int signIndicator) throws ParseException {
 /*@bgen(jjtree) ExactNumericLiteral */
        AST_ExactNumericLiteral jjtn000 = new AST_ExactNumericLiteral(this, JJTEXACTNUMERICLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "exact_numeric_literal_S()" ) ;
        jjtn000.setSign( signIndicator ) ;
        Token t ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXACT_NUMERIC_LITERAL:
        t = jj_consume_token(EXACT_NUMERIC_LITERAL);
        break;
      case UNSIGNED_INTEGER:
        t = jj_consume_token(UNSIGNED_INTEGER);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                        if( t != null ) {
                                if( log.isDebugEnabled() ) {
                                        log.debug( "Token encountered: kind [" + t.kind + "] with image [" + t.image + "]" ) ;
                                }
                        }
                        if( log.isTraceEnabled() ) exitTrace ( "exact_numeric_literal_S()" ) ;
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * exists_predicate_A
 *
 * bnf-single <exists_predicate> ::= EXISTS <table_subquery>
 *
 */
  final public void exists_predicate_A() throws ParseException {
 /*@bgen(jjtree) ExistsPredicate */
    AST_ExistsPredicate jjtn000 = new AST_ExistsPredicate(this, JJTEXISTSPREDICATE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "exists_predicate_A()" ) ;
    try {
      jj_consume_token(EXISTS);
      table_subquery_S();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "exists_predicate_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _explicit_table_S() throws ParseException {
    jj_consume_token(TABLE);
    table_name_A();
  }

/*
 * factor_S
 *
 * bnf-single <factor> ::= [ <sign> ] <numeric_primary> 
 *
 */
  final public void factor_S(String elementName) throws ParseException {
 /*@bgen(jjtree) Factor */
        AST_Factor jjtn000 = new AST_Factor(this, JJTFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "factor_S()" ) ;
        Token t = null ;
        String em = elementName ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_SIGN:
      case MINUS_SIGN:
        t = sign_S();
               if( t!=null ) {
                  jjtn000.setSign( t, elementName ) ;
                  em = AdqlParser.ARG_ELEMENT ;
               }
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      numeric_primary_S(em);
                                    if( t!=null) jjtn000.popPosition();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "factor_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * sign_S
 *
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 *
 */
  final public Token sign_S() throws ParseException {
 /*@bgen(jjtree) Sign */
    AST_Sign jjtn000 = new AST_Sign(this, JJTSIGN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "sign_S()" ) ;
    Token t = null ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_SIGN:
        t = jj_consume_token(PLUS_SIGN);
        break;
      case MINUS_SIGN:
        t = jj_consume_token(MINUS_SIGN);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           log.debug( "sign: " + t.image ) ;
           if( log.isTraceEnabled() ) exitTrace ( "sign_S()" ) ;
           {if (true) return t ;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * from_clause_S
 *
 * bnf-start
 *  <from_clause> ::= FROM <table_reference>
 *     [ { <comma> <table_reference> }... ]
 * bnf-end
 *
 */
  final public void from_clause_S() throws ParseException {
 /*@bgen(jjtree) From */
    AST_From jjtn000 = new AST_From(this, JJTFROM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "from_clause_S()" ) ;
    jjtn000.pushPosition() ;
    try {
      try {
        jj_consume_token(FROM);
        table_reference_A();
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_4;
          }
          jj_consume_token(COMMA);
          table_reference_A();
        }
      } catch (ParseException pex) {
                parser.errorSkipTo( parser.FROM_SKIP_TO ) ;
        tracker.setError( pex ) ;
      } finally {
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "from_clause_S()" ) ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * general_literal_A
 *
 * bnf-start
 *  <general_literal> ::= <character_string_literal>
 * bnf-end
 *
 */
  final public void general_literal_A() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASCII_STRING_LITERAL:
      character_string_literal_A();
      break;
    case BIT_STRING_LITERAL:
    case HEX_STRING_LITERAL:
      bit_string_literal_A();
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * general_set_function_A
 *
 * bnf-start
 *  <general_set_function> ::=
 *     <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>
 * bnf-end
 *
 * bnf-single <set_function_type> ::= AVG | MAX | MIN | SUM | COUNT
 *
 */
  final public void general_set_function_A() throws ParseException {
 /*@bgen(jjtree) GeneralSetFunction */
        AST_GeneralSetFunction jjtn000 = new AST_GeneralSetFunction(this, JJTGENERALSETFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "general_set_function_A()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AVG:
        jj_consume_token(AVG);
        break;
      case MAX:
        jj_consume_token(MAX);
        break;
      case MIN:
        jj_consume_token(MIN);
        break;
      case SUM:
        jj_consume_token(SUM);
        break;
      case COUNT:
        jj_consume_token(COUNT);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        set_quantifier_S();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      value_expression_A(parser.ARG_ELEMENT);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "general_set_function_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * general_value_specification_A
 *
 *-bnf-start
 *- <general_value_specification> ::= <variable_specification>
 *- !! ADQL Note:
 *- !! Missing from the ADQL draft spec.
 *- !! Part of an experiment to see if scripting variables can be accommodated.
 *- !! SQL92 also supports <parameter_specification>, <dynamic_parameter_specification>,
 *- !! USER, CURRENT_USER, SESSION_USER, SYSTEM_USER and VALUE
 *-bnf-end
 *
 */
  final public void general_value_specification_A() throws ParseException {
    variable_specification_A();
  }

/*
 * group_by_clause_S
 *
 * bnf-start
 *  <group_by_clause> ::= GROUP BY <grouping_column_reference_list>
 * bnf-end
 *
 */
  final public void group_by_clause_S() throws ParseException {
 /*@bgen(jjtree) GroupBy */
        AST_GroupBy jjtn000 = new AST_GroupBy(this, JJTGROUPBY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "group_by_clause_S()" ) ;
        jjtn000.pushPosition() ;
    try {
      jj_consume_token(GROUPBY);
      grouping_column_reference_list_S();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "group_by_clause_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * grouping_column_reference_list_S
 *
 * bnf-start
 *  <grouping_column_reference_list> ::=
 *      <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
 * bnf-end
 *
 */
  final public void grouping_column_reference_list_S() throws ParseException {
 /*@bgen(jjtree) GroupingColumnReferenceList */
    AST_GroupingColumnReferenceList jjtn000 = new AST_GroupingColumnReferenceList(this, JJTGROUPINGCOLUMNREFERENCELIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_list_S()" ) ;
    try {
      grouping_column_reference_A();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        grouping_column_reference_A();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_list_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * grouping_column_reference_A
 *
 * bnf-start
 *  <grouping_column_reference> ::= <column_reference> 
 * bnf-end
 *
 */
  final public void grouping_column_reference_A() throws ParseException {
    if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_A()" ) ;
    column_reference_A("todo");
                if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_A()" ) ;
  }

/*
 * having_clause_S
 *
 * bnf-single <having_clause> ::= HAVING <search_condition>	
 *
 */
  final public void having_clause_S() throws ParseException {
 /*@bgen(jjtree) Having */
        AST_Having jjtn000 = new AST_Having(this, JJTHAVING);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "having_clause_S()" ) ;
        jjtn000.pushPosition() ;
    try {
      jj_consume_token(HAVING);
      search_condition_S();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "having_clause_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * identifier_A
 *
 * For the moment, <identifier> is a synonym for <actual_identifier>
 *
 */
  final public void identifier_A() throws ParseException {
    actual_identifier_S();
  }

/*
 * in_predicate_A
 *
 * bnf-start
 *  <in_predicate> ::=
 *      <value_expression> [ NOT ] IN <in_predicate_value>
 * bnf-end
 *
 */
  final public void in_predicate_A() throws ParseException {
 /*@bgen(jjtree) InPredicate */
        AST_InPredicate jjtn000 = new AST_InPredicate(this, JJTINPREDICATE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "in_predicate_A()" ) ;
    try {
      value_expression_A(null);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                                              jjtn000.setIn(false);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(IN);
      in_predicate_value_S();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
       if( log.isTraceEnabled() ) exitTrace ( "in_predicate_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * in_predicate_value_S
 *
 * bnf-start
 *  <in_predicate_value> ::=
 *     <table_subquery> | <left_paren> <in_value_list> <right_paren>
 * bnf-end
 *
 */
  final public void in_predicate_value_S() throws ParseException {
 /*@bgen(jjtree) InPredicateValue */
        AST_InPredicateValue jjtn000 = new AST_InPredicateValue(this, JJTINPREDICATEVALUE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "in_predicate_value_S()" ) ;
    try {
      if (jj_2_16(5)) {
        table_subquery_S();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_PAREN:
          jj_consume_token(LEFT_PAREN);
          in_value_list_A();
          jj_consume_token(RIGHT_PAREN);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "in_predicate_value_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _interval_factor_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS_SIGN:
    case MINUS_SIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_SIGN:
        jj_consume_token(PLUS_SIGN);
        break;
      case MINUS_SIGN:
        jj_consume_token(MINUS_SIGN);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    _interval_primary_S();
  }

  final public void _interval_fractional_seconds_precision_S() throws ParseException {
    jj_consume_token(UNSIGNED_INTEGER);
  }

  final public void _interval_leading_field_precision_S() throws ParseException {
    jj_consume_token(UNSIGNED_INTEGER);
  }

  final public void _interval_primary_S() throws ParseException {
    value_expression_primary_A(null);
    if (jj_2_17(2)) {
      _interval_qualifier_S();
    } else {
      ;
    }
  }

  final public void _interval_qualifier_S() throws ParseException {
    if (jj_2_18(3)) {
      _start_field_S();
      jj_consume_token(TO);
      _end_field_S();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DAY:
      case HOUR:
      case MINUTE:
      case MONTH:
      case SECOND:
      case YEAR:
        _single_datetime_field_S();
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void _interval_term_S() throws ParseException {
    if (jj_2_19(3)) {
      _interval_factor_S();
    } else if (jj_2_20(3)) {
      factor_S("to-do");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      case SOLIDUS:
        jj_consume_token(SOLIDUS);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      _interval_term_S();
    } else if (jj_2_21(1)) {
      term_S("to-do");
      jj_consume_token(ASTERISK);
      _interval_factor_S();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _interval_value_expression_S() throws ParseException {
    if (jj_2_23(3)) {
      _interval_term_S();
      label_6:
      while (true) {
        if (jj_2_22(2)) {
          ;
        } else {
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS_SIGN:
          jj_consume_token(PLUS_SIGN);
          break;
        case MINUS_SIGN:
          jj_consume_token(MINUS_SIGN);
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        _interval_term_S();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _datetime_value_expression_S();
        jj_consume_token(MINUS_SIGN);
        _datetime_term_S();
        jj_consume_token(RIGHT_PAREN);
        _interval_qualifier_S();
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/*
 * in_value_list_A
 *
 * bnf-start
 *  <in_value_list> ::=
 *      <value_expression> { <comma> <value_expression> } ...
 * bnf-end
 *
 */
  final public void in_value_list_A() throws ParseException {
                                       /*@bgen(jjtree) InValueList */
  AST_InValueList jjtn000 = new AST_InValueList(this, JJTINVALUELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      value_expression_A(null);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        value_expression_A(null);
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * join_specification_S
 *
 * bnf-start
 *  <join_specification> ::= <join_condition> | <named_columns_join>	
 * bnf-end
 *
 */
  final public void join_specification_S() throws ParseException {
                                                  /*@bgen(jjtree) JoinSpecification */
  AST_JoinSpecification jjtn000 = new AST_JoinSpecification(this, JJTJOINSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ON:
        join_condition_S();
        break;
      case USING:
        named_columns_join_S();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * join_condition_S
 *
 * bnf-single <join_condition> ::= ON <search_condition>
 *
 */
  final public void join_condition_S() throws ParseException {
 /*@bgen(jjtree) JoinCondition */
    AST_JoinCondition jjtn000 = new AST_JoinCondition(this, JJTJOINCONDITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "join_condition_S()" ) ;
    try {
      jj_consume_token(ON);
      search_condition_S();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "join_condition_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * named_columns_join_S
 *
 * bnf-single <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren> 
 *
 */
  final public void named_columns_join_S() throws ParseException {
 /*@bgen(jjtree) NamedColumnsJoin */
        AST_NamedColumnsJoin jjtn000 = new AST_NamedColumnsJoin(this, JJTNAMEDCOLUMNSJOIN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "named_columns_join_S()" ) ;
    try {
      jj_consume_token(USING);
      jj_consume_token(LEFT_PAREN);
      join_column_list_S();
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "named_columns_join_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * join_column_list_S
 *
 * bnf-single <join_column_list> ::= <column_name_list>
 *
 */
  final public void join_column_list_S() throws ParseException {
    column_name_list_S();
  }

/*
 * joined_table_A
 *
 * bnf-start
 *  <joined_table> ::=
 *      <qualified_join>
 *    | <left_paren> <joined_table> <right_paren>
 * bnf-end
 *
 */
  final public void joined_table_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "joined_table_A()" ) ;
    qualified_join_A();
                if( log.isTraceEnabled() ) exitTrace ( "joined_table_A()" ) ;
  }

/*
 * join_type_A
 *
 * bnf-start
 *  <join_type> ::=
 *     INNER
 *   | <outer_join_type> [ OUTER ]
 *  !! For information, SQL92 also supports UNION
 * bnf-end
 *
 * bnf-single <outer_join_type> ::= LEFT | RIGHT | FULL
 *
 */
  final public void join_type_A() throws ParseException {
                                /*@bgen(jjtree) JoinType */
  AST_JoinType jjtn000 = new AST_JoinType(this, JJTJOINTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INNER:
        jj_consume_token(INNER);
        break;
      case FULL:
      case LEFT:
      case RIGHT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT:
          jj_consume_token(LEFT);
          break;
        case RIGHT:
          jj_consume_token(RIGHT);
          break;
        case FULL:
          jj_consume_token(FULL);
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OUTER:
          jj_consume_token(OUTER);
          break;
        default:
          jj_la1[40] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * match_value_S
 *
 * bnf-single <match_value> ::= <character_value_expression>
 *
 */
  final public void match_value_S() throws ParseException {
 /*@bgen(jjtree) MatchValue */
    AST_MatchValue jjtn000 = new AST_MatchValue(this, JJTMATCHVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "match_value_S()" ) ;
    try {
      character_value_expression_S("");
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "match_value_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _match_predicate_S() throws ParseException {
    _row_value_constructor_S();
    jj_consume_token(MATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FULL:
    case PARTIAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARTIAL:
        jj_consume_token(PARTIAL);
        break;
      case FULL:
        jj_consume_token(FULL);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    table_subquery_S();
  }

/*
 * math_function_A
 *
 * bnf-start
 *  <math_function> ::=
 *      ABS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | CEILING <left_paren> <numeric_value_expression> <right_paren> 
 *	  | DEGREES <left_paren> <numeric_value_expression> <right_paren> 
 *	  | EXP <left_paren> <numeric_value_expression> <right_paren> 
 *	  | FLOOR <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG <left_paren> <numeric_value_expression> <right_paren> 
 *	  | PI <left_paren><right_paren> 
 *	  | POWER <left_paren> <numeric_value_expression> <comma> <unsigned_integer> <right_paren> 
 *	  | RADIANS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQUARE <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQRT <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG10 <left_paren> <numeric_value_expression> <right_paren> 
 *	  | RAND <left_paren> [ <numeric_value_expression> ] <right_paren> 
 *	  | ROUND <left_paren> <numeric_value_expression> [ <comma> <signed_integer> ] <right_paren> 
 *	  | TRUNCATE <left_paren> <numeric_value_expression> [ <comma> <signed_integer> ] <right_paren> 
 * bnf-end
 *
 */
  final public void math_function_A(String elementName) throws ParseException {
 /*@bgen(jjtree) MathFunction */
        AST_MathFunction jjtn000 = new AST_MathFunction(this, JJTMATHFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "math_function_A()" ) ;
        jjtn000.pushPosition( elementName ) ;
    Token arg2 = null ;
    Long signedLong ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABS:
        jj_consume_token(ABS);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case CEILING:
        jj_consume_token(CEILING);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case DEGREES:
        jj_consume_token(DEGREES);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case EXP:
        jj_consume_token(EXP);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case FLOOR:
        jj_consume_token(FLOOR);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case LOG:
        jj_consume_token(LOG);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case PI:
        jj_consume_token(PI);
        jj_consume_token(LEFT_PAREN);
        jj_consume_token(RIGHT_PAREN);
        break;
      case POWER:
        jj_consume_token(POWER);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(COMMA);
        arg2 = jj_consume_token(UNSIGNED_INTEGER);
                                                 jjtn000.setArg2(new Long(arg2.image));
        jj_consume_token(RIGHT_PAREN);
        break;
      case RADIANS:
        jj_consume_token(RADIANS);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case SQUARE:
        jj_consume_token(SQUARE);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case SQRT:
        jj_consume_token(SQRT);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case LOG10:
        jj_consume_token(LOG10);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case RAND:
        jj_consume_token(RAND);
        jj_consume_token(LEFT_PAREN);
        if (jj_2_24(1)) {
          numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        } else {
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        break;
      case ROUND:
        jj_consume_token(ROUND);
        jj_consume_token(LEFT_PAREN);
                          tracker.push( parser.ARG_ELEMENT ) ;
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
                                                                                                                        tracker.pop() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          signedLong = signed_integer_S();
                                                                  jjtn000.setArg2( signedLong ) ;
          break;
        default:
          jj_la1[45] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        break;
      case TRUNCATE:
        jj_consume_token(TRUNCATE);
        jj_consume_token(LEFT_PAREN);
                          tracker.push( parser.ARG_ELEMENT ) ;
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
                                                                                                                        tracker.pop() ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          signedLong = signed_integer_S();
                                                                  jjtn000.setArg2( signedLong ) ;
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           jjtn000.popPosition( elementName ) ;
           if( log.isTraceEnabled() ) exitTrace ( "math_function_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * null_predicate_A
 *
 * bnf-start
 *  <null_predicate> ::= <column_reference> IS [ NOT ] NULL
 * bnf-end
 *
 */
  final public void null_predicate_A() throws ParseException {
 /*@bgen(jjtree) NullPredicate */
           AST_NullPredicate jjtn000 = new AST_NullPredicate(this, JJTNULLPREDICATE);
           boolean jjtc000 = true;
           jjtree.openNodeScope(jjtn000);
           jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "null_predicate_A()" ) ;
    try {
      column_reference_A("");
      jj_consume_token(IS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                                               jjtn000.setNullPredicate(false);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      jj_consume_token(NULL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "null_predicate_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * numeric_primary_S
 *
 * bnf-start
 *  <numeric_primary> ::=
 *      <value_expression_primary>
 *    | <numeric_value_function>
 * bnf-end
 *
 */
  final public void numeric_primary_S(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "numeric_primary_S()" ) ;
    if (jj_2_25(6)) {
      numeric_value_function_A(elementName);
    } else if (jj_2_26(1)) {
      value_expression_primary_A(elementName);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "numeric_primary_S()" ) ;
  }

/*
 * numeric_value_expression_S
 *
 * bnf-start
 *  <numeric_value_expression> ::=
 *      <term>
 *    | <numeric_value_expression> <plus_sign> <term>
 *    | <numeric_value_expression> <minus_sign> <term>
 * bnf-end
 *
 */
  final public void numeric_value_expression_S(String elementName) throws ParseException {
 /*@bgen(jjtree) NumericValueExpression */
        AST_NumericValueExpression jjtn000 = new AST_NumericValueExpression(this, JJTNUMERICVALUEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "numeric_value_expression_S()" ) ;
        Token t = null ;
    try {
      term_S(elementName);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_SIGN:
      case MINUS_SIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS_SIGN:
          t = jj_consume_token(PLUS_SIGN);
          break;
        case MINUS_SIGN:
          t = jj_consume_token(MINUS_SIGN);
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                  jjtn000.setOperator( t, elementName );
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
        if( log.isTraceEnabled() ) exitTrace ( "numeric_value_expression_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void numericValueExpressionBitFactor() throws ParseException {
 /*@bgen(jjtree) BitFactor */
        AST_BitFactor jjtn000 = new AST_BitFactor(this, JJTBITFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null ;
    try {
      numeric_value_expression_S(null);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
      case VERTICAL_BAR:
      case CIRCUMFLEX:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AMPERSAND:
          t = bitwiseAND();
          break;
        case VERTICAL_BAR:
          t = bitwiseOR();
          break;
        case CIRCUMFLEX:
          t = bitwiseXOR();
          break;
        default:
          jj_la1[51] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                        jjtn000.setOperator( t.image ) ;
                        if( !parser.isSyntaxSet( SyntaxOption.BITWISE_MANIPULATION) ) {
                                        tracker.setError( "Reference Implementation: Bit value expressions not supported." ) ;
                                }
        numericValueExpressionBitFactor();
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public Token bitwiseAND() throws ParseException {
  Token t = null;
    t = jj_consume_token(AMPERSAND);
          {if (true) return t ;}
    throw new Error("Missing return statement in function");
  }

  final public Token bitwiseOR() throws ParseException {
  Token t = null;
    t = jj_consume_token(VERTICAL_BAR);
          {if (true) return t ;}
    throw new Error("Missing return statement in function");
  }

  final public Token bitwiseXOR() throws ParseException {
  Token t = null;
    t = jj_consume_token(CIRCUMFLEX);
          {if (true) return t ;}
    throw new Error("Missing return statement in function");
  }

  final public Token bitwiseNOT() throws ParseException {
  Token t = null;
    t = jj_consume_token(TILDE);
          {if (true) return t ;}
    throw new Error("Missing return statement in function");
  }

/*
 * numeric_value_function_A
 *
 * bnf-start v20+RFC 
 *   <numeric_value_function> ::=
 *       <trig_function>
 *     | <math_function>
 *     | <user_defined_function>
 *     | <system_defined_function>
 * bnf-end
 *
 * bnf-start v21-Projection
 *  <numeric_value_function> ::= 
 *     <trig_function> 
 *   | <math_function>	
 *   | <numeric_geometry_function>
 *   | <user_defined_function>
 * bnf-end
 *
 * bnf-start v20-AG
 *  <numeric_value_function> ::= 
 *     <trig_function> 
 *   | <math_function>	
 *   | <user_defined_function>
 * bnf-end
 *
 */
  final public void numeric_value_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "numeric_value_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIN:
    case COS:
    case TAN:
    case COT:
    case ASIN:
    case ACOS:
    case ATAN:
    case ATAN2:
      trig_function_A(elementName);
      break;
    case ABS:
    case CEILING:
    case DEGREES:
    case EXP:
    case FLOOR:
    case LOG:
    case PI:
    case POWER:
    case RADIANS:
    case SQRT:
    case SQUARE:
    case LOG10:
    case RAND:
    case ROUND:
    case TRUNCATE:
      math_function_A(elementName);
      break;
    case AREA:
    case LATITUDE:
    case LONGITUDE:
    case INTERSECTS:
    case DISTANCE:
    case CONTAINS:
      numeric_geometry_function_A(elementName);
      break;
    default:
      jj_la1[53] = jj_gen;
      if (jj_2_27(1)) {
        user_defined_function_A(elementName);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                if( log.isTraceEnabled() ) exitTrace ( "numeric_value_function_A()" ) ;
  }

/*
 * numeric_geometry_function_A
 *
 * bnf-start v21-Projection
 *   <numeric_geometry_function> ::=
 *      <predicate_geometry_function> | <non_predicate_geometry_function>
 * bnf-end
 *
 */
  final public void numeric_geometry_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "numeric_geometry_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERSECTS:
    case CONTAINS:
      predicate_geometry_function_A(elementName);
      break;
    case AREA:
    case LATITUDE:
    case LONGITUDE:
    case DISTANCE:
      non_predicate_geometry_function_A(elementName);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "numeric_geometry_function_A()" ) ;
  }

/*
 * user_defined_function_A
 *
 * bnf-start
 *  <user_defined_function> ::=
 *      <user_defined_function_name> 
 *          <left_paren> 
 *              [ <user_defined_function_param> [ { <comma> <user_defined_function_param> }... ] ]
 *          <right_paren> 
 *  !! ADQL Note:
 *  !! If metadata on a user defined function is available, this should be used.
 *  !! For example, function names and cardinality of arguments should be checked.
 * bnf-end
 *
 * bnf-start
 *  <user_defined_function_param> ::= <value_expression>
 * bnf-end
 *
 * bnf-start
 *   <user_defined_function_name> ::=
 *       [ <default_function_prefix> ] <regular_identifier>
 *   !! Function names should be checked against metadata where available. 
 * bnf-end 
 *
 * bnf-start
 *   <default_function_prefix> ::=
 *   !! The prefix is set by default to "udf_".
 *   !! It should be possible to change the default prefix to accommodate local preferences.
 * bnf-end
 *
 */
  final public void user_defined_function_A(String elementName) throws ParseException {
 /*@bgen(jjtree) UserDefinedFunction */
        AST_UserDefinedFunction jjtn000 = new AST_UserDefinedFunction(this, JJTUSERDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "user_defined_function_A()" ) ;
        jjtn000.pushPosition( elementName ) ;
        Token tName = null ;
    try {
      if (jj_2_28(4)) {
        objectOwnership();
      } else {
        ;
      }
      tName = jj_consume_token(REGULAR_IDENTIFIER);
      jj_consume_token(LEFT_PAREN);
                                                               jjtn000.setFunctionName( tName.image ) ;
      if (jj_2_29(1)) {
        value_expression_A(AdqlParser.ARG_ELEMENT);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[55] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMMA);
          value_expression_A(AdqlParser.ARG_ELEMENT);
        }
      } else {
        ;
      }
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "user_defined_function_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void columnOwnership() throws ParseException {
 /*@bgen(jjtree) Ownership */
        AST_Ownership jjtn000 = new AST_Ownership(this, JJTOWNERSHIP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "columnOwnership()" ) ;
    try {
      if (jj_2_30(4) && (parser.ifQualifiedPartsEqual(4))) {
        identifier_A();
        jj_consume_token(PERIOD);
        identifier_A();
        jj_consume_token(PERIOD);
                                                        jjtn000.setQualifierDepth(2) ;
      } else if (jj_2_31(4)) {
        identifier_A();
        jj_consume_token(PERIOD);
        jj_consume_token(PERIOD);
                                         jjtn000.setQualifierDepth(2) ;
      } else if (jj_2_32(1)) {
        identifier_A();
        jj_consume_token(PERIOD);
                                jjtn000.setQualifierDepth(1) ;
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "columnOwnership()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void objectOwnership() throws ParseException {
 /*@bgen(jjtree) Ownership */
        AST_Ownership jjtn000 = new AST_Ownership(this, JJTOWNERSHIP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "objectOwnership()" ) ;
    try {
      if (jj_2_33(4) && (parser.ifQualifiedPartsEqual(3))) {
        identifier_A();
        jj_consume_token(PERIOD);
        identifier_A();
        jj_consume_token(PERIOD);
                                                        jjtn000.setQualifierDepth(2) ;
      } else if (jj_2_34(4)) {
        identifier_A();
        jj_consume_token(PERIOD);
        jj_consume_token(PERIOD);
                                         jjtn000.setQualifierDepth(2) ;
      } else if (jj_2_35(1)) {
        identifier_A();
        jj_consume_token(PERIOD);
                                jjtn000.setQualifierDepth(1) ;
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "objectOwnership()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * order_by_clause
 *
 * bnf-start
 *  <order_by_clause> ::= ORDER BY <sort_specification_list>
 * bnf-end
 *
 */
  final public void order_by_clause_S() throws ParseException {
 /*@bgen(jjtree) OrderByClause */
        AST_OrderByClause jjtn000 = new AST_OrderByClause(this, JJTORDERBYCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "order_by_clause_S()" ) ;
    try {
      jj_consume_token(ORDERBY);
      sort_specification_list_S(AdqlParser.ORDERBY_ELEMENT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          if( log.isTraceEnabled() ) exitTrace ( "order_by_clause_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * sort_specification_list
 *
 * bnf-start
 *  <sort_specification_list> ::=
 *      <sort_specification> [ { <comma> <sort_specification> }... ]
 * bnf-end 
 *
 */
  final public void sort_specification_list_S(String elementName) throws ParseException {
 /*@bgen(jjtree) SortSpecificationList */
    AST_SortSpecificationList jjtn000 = new AST_SortSpecificationList(this, JJTSORTSPECIFICATIONLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "sort_specification_list_S()" ) ;
    try {
      sort_specification_A(null);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        sort_specification_A(null);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "sort_specification_list_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * sort_specification_A
 *
 * bnf-start
 *  <sort_specification> ::=
 *      <sort_key> [ <ordering_specification> ]
 *  !! For information, SQL92 also supports <collate_clause>
 * bnf-end
 * 
 */
  final public void sort_specification_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SortSpecification */
    AST_SortSpecification jjtn000 = new AST_SortSpecification(this, JJTSORTSPECIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "sort_specification_A()" ) ;
    jjtn000.pushPosition( elementName ) ;
    try {
      sort_key_S();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
      case DESC:
        ordering_specification_S();
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "sort_specification_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * sort_key_S
 *
 * bnf-start
 *   <sort_key> ::= <column_name> | <unsigned_integer> 
 *   !! For information, the use of <unsigned_integer> in <sort_key>is a deprecated feature of SQL92
 * bnf-end
 *
 */
  final public void sort_key_S() throws ParseException {
 /*@bgen(jjtree) SortKey */
        AST_SortKey jjtn000 = new AST_SortKey(this, JJTSORTKEY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "sort_key_S()" ) ;
        Token t = null ;
    try {
      if (jj_2_36(1)) {
        column_reference_A(null);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNSIGNED_INTEGER:
          t = jj_consume_token(UNSIGNED_INTEGER);
          break;
        default:
          jj_la1[58] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( t!= null ) {
                        if( t.image.equals( "0" ) ) {
                                {if (true) throw new ParseException( "Sort key in ORDER BY clause cannot be 0." ) ;}
                        }
                }
                if( log.isTraceEnabled() ) exitTrace ( "sort_key_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * ordering_specification_S
 * 
 * bnf-single <ordering_specification> ::= ASC | DESC
 */
  final public void ordering_specification_S() throws ParseException {
 /*@bgen(jjtree) OrderingSpecification */
    AST_OrderingSpecification jjtn000 = new AST_OrderingSpecification(this, JJTORDERINGSPECIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "ordering_specification_S()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
        jj_consume_token(ASC);
        break;
      case DESC:
        jj_consume_token(DESC);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "ordering_specification_S()" ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _overlaps_predicate_S() throws ParseException {
    _row_value_constructor_S();
    jj_consume_token(OVERLAPS);
    _row_value_constructor_S();
  }

/*
 * pattern_A
 *
 * bnf-start
 *  <pattern> ::= <character_value_expression>
 * bnf-end
 *
 */
  final public void pattern_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "pattern_A()" ) ;
    character_value_expression_S("todo");
                if( log.isTraceEnabled() ) exitTrace ( "pattern_A()" ) ;
  }

/*
 * predicate_A
 *
 * bnf-start
 *  <predicate> ::=
 *     <comparison_predicate>
 *   | <between_predicate>
 *   | <in_predicate>
 *   | <like_predicate>
 *   | <null_predicate>
 *   | <exists_predicate>
 * bnf-end
 *
 */
  final public void predicate_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "predicate_A()" ) ;
    if (jj_2_37(2147483647)) {
      comparison_predicate_A();
    } else if (jj_2_38(2147483647)) {
      between_predicate_A();
    } else if (jj_2_39(2147483647)) {
      in_predicate_A();
    } else if (jj_2_40(2147483647)) {
      like_predicate_A();
    } else if (jj_2_41(1)) {
      null_predicate_A();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXISTS:
        exists_predicate_A();
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        if( log.isTraceEnabled() ) exitTrace ( "predicate_A()" ) ;
  }

/*
 * point_A
 *
 * bnf-start v20+RFC,v21-Projection 
 *   <point> ::= POINT <left_paren> <coord_sys> <comma> <coordinates> <right_paren>
 * bnf-end
 *
 */
  final public void point_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "point_A()" ) ;
    try {
      jj_consume_token(POINT);
      jj_consume_token(LEFT_PAREN);
      coord_sys_A();
      jj_consume_token(COMMA);
      coordinates_A();
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        if( log.isTraceEnabled() ) exitTrace ( "point_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * coordinates_A
 *
 * bnf-start v21-Projection,v20+RFC
 *   <coordinates> ::=  <coordinate1>  <comma>  <coordinate2> 
 * bnf-end
 *
 */
  final public void coordinates_A() throws ParseException {
    coordinate1_A();
    jj_consume_token(COMMA);
    coordinate2_A();
  }

/*
 * coordinate1_A
 *
 * bnf-start
 *   <coordinate1> ::= <numeric_value_expression>
 * bnf-end
 *
 */
  final public void coordinate1_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * coordinate2_A
 *
 * bnf-start
 *   <coordinate2> ::= <numeric_value_expression>
 * bnf-end
 *
 */
  final public void coordinate2_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * size1_A
 *
 */
  final public void size1_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * size2_A
 *
 */
  final public void size2_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * coord_sys_A
 *
 * bnf-start v21-Projection,v20+RFC 
 *  <coord_sys> ::= <string_value_expression>
 * bnf-end
 *
 */
  final public void coord_sys_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "coord_sys_A()" ) ;
    string_value_expression_A(null);
           if( log.isTraceEnabled() ) exitTrace ( "coord_sys_A()" ) ;
  }

/*
 * box_A
 *
 * bnf-start v20+RFC,v21-Projection
 *   <box> ::= 
 *      BOX <left_paren> <coord_sys>
 *                     <comma> <coordinates> 
 *                     <comma> <numeric_value_expression> 
 *                     <comma> <numeric_value_expression> 
 *                <right_paren>
 * bnf-end
 *
 */
  final public void box_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "box_A()" ) ;
    try {
      jj_consume_token(BOX);
      jj_consume_token(LEFT_PAREN);
      coord_sys_A();
      jj_consume_token(COMMA);
      coordinates_A();
      jj_consume_token(COMMA);
      size1_A();
      jj_consume_token(COMMA);
      size2_A();
      jj_consume_token(RIGHT_PAREN);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "box_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * circle_A
 *
 * bnf-start v20+RFC,v21-Projection
 *   <circle> ::= 
 *      CIRCLE <left_paren> <coord_sys> 
 *                  <comma> <coordinates> 
 *                  <comma> <radius> 
 *             <right_paren>
 * bnf-end
 *
 */
  final public void circle_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "circle_A()" ) ;
    try {
      jj_consume_token(CIRCLE);
      jj_consume_token(LEFT_PAREN);
      coord_sys_A();
      jj_consume_token(COMMA);
      coordinates_A();
      jj_consume_token(COMMA);
      radius_A();
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "circle_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/* * ellipse_A * *-bnf-start *-  <ellipse> ::=  *-     ELLIPSE <left_paren> <coord_sys>  *-                  <comma> <coordinates>  *-                  <comma> <radius>  *-                  <comma> <minor_radius> *-                  <comma> <position_angle> *-             <right_paren> *-bnf-end * */
  final public void _ellipse_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "ellipse_A()" ) ;
    jj_consume_token(ELLIPSE);
    jj_consume_token(LEFT_PAREN);
    coord_sys_A();
    jj_consume_token(COMMA);
    coordinates_A();
    jj_consume_token(COMMA);
    radius_A();
    jj_consume_token(COMMA);
    _minor_radius_A();
    jj_consume_token(COMMA);
    _position_angle_A();
    jj_consume_token(RIGHT_PAREN);
                if( log.isTraceEnabled() ) exitTrace ( "ellipse_A()" ) ;
  }

/*
 * polygon_A
 *
 * bnf-start v20+RFC,v21-Projection
 *   <polygon> ::=
 *      POLYGON <left_paren> <coord_sys> 
 *                   <comma> <coordinates> 
 *                   <comma> <coordinates> 
 *                 { <comma> <coordinates> } ?
 *              <right_paren>
 * bnf-end
 */
  final public void polygon_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "polygon_A()" ) ;
    try {
      jj_consume_token(POLYGON);
      jj_consume_token(LEFT_PAREN);
      coord_sys_A();
      jj_consume_token(COMMA);
      coordinates_A();
      jj_consume_token(COMMA);
      coordinates_A();
      label_10:
      while (true) {
        jj_consume_token(COMMA);
        coordinates_A();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_10;
        }
      }
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "polygon_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * radius_A
 *
 * bnf-start v20+RFC,v21-Projection
 *   <radius> ::= <numeric_value_expression>
 * bnf-end
 *
 */
  final public void radius_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * minor_radius_A
 *
 *-bnf-single <minor_radius> ::= <numeric_value_expression>
 *
 */
  final public void _minor_radius_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * position_angle_A
 *
 *-bnf-single <position_angle> ::= <numeric_value_expression>
 *
 */
  final public void _position_angle_A() throws ParseException {
    numeric_value_expression_S(null);
  }

/*
 * region_A
 *
 * bnf-start v20+RFC,v21-Projection
 *   <region> ::= REGION <left_paren> <string_value_expression> <right_paren>
 * bnf-end
 *
 */
  final public void region_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "region_A()" ) ;
    try {
      jj_consume_token(REGION);
      jj_consume_token(LEFT_PAREN);
      string_value_expression_A(null);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "region_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void table_array_fragment() throws ParseException {
 /*@bgen(jjtree) TableArrayFragment */
    AST_TableArrayFragment jjtn000 = new AST_TableArrayFragment(this, JJTTABLEARRAYFRAGMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "table_array_fragment()" ) ;
    try {
      table_reference_A();
      jj_consume_token(COMMA);
      table_reference_A();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
           if( log.isTraceEnabled() ) exitTrace ( "table_array_fragment()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * schema_name_A
 *
 * bnf-start
 *    <schema_name> ::= [ <catalog_name> <period> ] <unqualified_schema name>
 * bnf-end
 * bnf-single <catalog_name> ::= <identifier>
 * bnf-single <unqualified_schema name> ::= <identifier>
 *
 */
  final public void schema_name_A() throws ParseException {
 /*@bgen(jjtree) SchemaName */
   AST_SchemaName jjtn000 = new AST_SchemaName(this, JJTSCHEMANAME);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "schema_name_A()" ) ;
    try {
      if (jj_2_42(6)) {
        identifier_A();
      } else if (jj_2_43(1)) {
        catalog_name_A();
        jj_consume_token(PERIOD);
        identifier_A();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "schema_name_A()" ) ;
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void catalog_name_A() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "catalog_name_A()" ) ;
    identifier_A();
                if( log.isTraceEnabled() ) exitTrace ( "catalog_name_A()" ) ;
  }

/*
 * 
 * bnf-start
 *  <qualifier> ::= <table_name> | <correlation_name> 
 * bnf-end
 *
 */
  final public void qualifier_A() throws ParseException {
   if( log.isTraceEnabled() ) enterTrace ( "qualifier_A()" ) ;
    table_name_A();
                if( log.isTraceEnabled() ) exitTrace ( "qualifier_A()" ) ;
  }

/*
 * 
 *
 * bnf-start
 *  <query_specification> ::=
 *      SELECT [ <set_quantifier> ] [ <set_limit> ] <select_list> <table_expression>
 * bnf-end
 *
 * bnf-start
 *  <table_expression> ::=
 *      <from_clause>
 *      [ <where_clause> ]
 *      [ <group_by_clause> ]
 *      [ <having_clause> ]
 *      [ <order_by_clause> ]
 * bnf-end 
 *
 */
  final public void query_specification_A() throws ParseException {
 /*@bgen(jjtree) Select */
    AST_Select jjtn000 = new AST_Select(this, JJTSELECT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "query_specification_A()" ) ;
    jjtn000.pushPosition() ;
    try {
      jj_consume_token(SELECT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
      case DISTINCT:
        set_quantifier_S();
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TOP:
        set_limit_A();
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      select_list_S();
      from_clause_S();
      if (jj_2_44(3)) {
        where_clause_S();
      } else {
        ;
      }
      if (jj_2_45(3)) {
        group_by_clause_S();
      } else {
        ;
      }
      if (jj_2_46(3)) {
        having_clause_S();
      } else {
        ;
      }
      if (jj_2_47(3)) {
        order_by_clause_S();
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "query_specification_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _row_subquery_S() throws ParseException {
    subquery_S();
  }

  final public ScalarExpressionType _row_value_constructor_S() throws ParseException {
        ScalarExpressionType seType = null ;
    if (jj_2_48(3)) {
      _row_value_constructor_element_S();
    } else if (jj_2_49(2)) {
      jj_consume_token(LEFT_PAREN);
      _row_value_constructor_list_S();
      jj_consume_token(RIGHT_PAREN);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        _row_subquery_S();
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
           {if (true) return seType ;}
    throw new Error("Missing return statement in function");
  }

  final public ScalarExpressionType _row_value_constructor_element_S() throws ParseException {
        ScalarExpressionType seType = null ;
    value_expression_A(null);
          {if (true) return seType ;}
    throw new Error("Missing return statement in function");
  }

  final public void _row_value_constructor_list_S() throws ParseException {
    _row_value_constructor_element_S();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[66] = jj_gen;
        break label_11;
      }
      jj_consume_token(COMMA);
      _row_value_constructor_element_S();
    }
  }

  final public void _scalar_subquery_S() throws ParseException {
    subquery_S();
  }

/*
 * 
 *
 * bnf-start
 *  <search_condition> ::=
 *      <boolean_term>
 *    | <search_condition> OR <boolean_term>
 * bnf-end
 *
 */
  final public void search_condition_S() throws ParseException {
 /*@bgen(jjtree) SearchCondition */
        AST_SearchCondition jjtn000 = new AST_SearchCondition(this, JJTSEARCHCONDITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "search_condition_S" ) ;
    try {
      boolean_term_S();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
                           jjtn000.setOr() ;
        search_condition_S();
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "search_condition_S" ) ;
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * select_list_S
 *
 * bnf-start
 *  <select_list> ::=
 *      <asterisk>
 *    | <select_sublist> [ { <comma> <select_sublist> }... ]
 * bnf-end
 *
 */
  final public void select_list_S() throws ParseException {
 /*@bgen(jjtree) SelectionList */
        AST_SelectionList jjtn000 = new AST_SelectionList(this, JJTSELECTIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "select_list_S()" ) ;
        jjtn000.pushPosition() ;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
          allSelectionItem();
          break;
        default:
          jj_la1[69] = jj_gen;
          select_sublist_A(true);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[68] = jj_gen;
              break label_12;
            }
            jj_consume_token(COMMA);
            select_sublist_A(false);
          }
        }
      } catch (ParseException pex) {
        parser.errorSkipTo( new int[] { AdqlStoXConstants.FROM } ) ;
        tracker.setError( pex ) ;
      } finally {
        jjtn000.popPosition() ;
        if( log.isTraceEnabled() ) exitTrace ( "select_list_S()" ) ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void allSelectionItem() throws ParseException {
 /*@bgen(jjtree) AllSelectionItem */
  AST_AllSelectionItem jjtn000 = new AST_AllSelectionItem(this, JJTALLSELECTIONITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);jjtn000.pushPosition( parser.ITEM_ELEMENT ) ;
    try {
      jj_consume_token(ASTERISK);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.popPosition( parser.ITEM_ELEMENT ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * select_sublist_A
 *
 * bnf-start
 *  <select_sublist> ::= <derived_column> | <qualifier> <period> <asterisk>
 * bnf-end
 *
 */
  final public void select_sublist_A(boolean first) throws ParseException {
 /*@bgen(jjtree) SelectSublist */
        AST_SelectSublist jjtn000 = new AST_SelectSublist(this, JJTSELECTSUBLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "select_sublist_A()" ) ;
        jjtn000.pushPosition( parser.ITEM_ELEMENT ) ;
        if( first ) {
                parser.selectSublistEnsureNotComma() ;
        }
    try {
      try {
        if (jj_2_50(12) && (parser.findPeriodAsterisk(12) == false)) {
          derived_column_S(AdqlParser.ITEM_ELEMENT);
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                           jjtreeCloseNodeScope(jjtn000);
                                                           parser.selectSublistEnsureCommaOrFrom() ;
        } else if (jj_2_51(1)) {
          qualifierPeriodAsterisk(AdqlParser.ITEM_ELEMENT);
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                  jjtreeCloseNodeScope(jjtn000);
                                                                  parser.selectSublistEnsureCommaOrFrom() ;
        } else {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             parser.selectSublistError( first, new ParseException( "SELECT list error" ) ) ;
        }
      } catch (ParseException pex) {
       parser.selectSublistError( first, pex ) ;
      } finally {
       jjtn000.popPosition( parser.ITEM_ELEMENT ) ;
       if( log.isTraceEnabled() ) exitTrace ( "select_sublist_A()" ) ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void qualifierPeriodAsterisk(String elementName) throws ParseException {
 /*@bgen(jjtree) QualifierPeriodAsterisk */
        AST_QualifierPeriodAsterisk jjtn000 = new AST_QualifierPeriodAsterisk(this, JJTQUALIFIERPERIODASTERISK);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "qualifierPeriodAsterisk()" ) ;
    try {
      table_name_A();
      jj_consume_token(PERIOD_ASTERISK);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
//		jjtThis.popPosition( elementName ) ;
                if( log.isTraceEnabled() ) exitTrace ( "qualifierPeriodAsterisk()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * derived_column_S
 *
 * bnf-start
 *  <derived_column> ::= <value_expression> [ <as_clause> ]
 * bnf-end
 * bnf-start
 *  <as_clause> ::= [ AS ] <column_name>
 * bnf-end
 */
  final public void derived_column_S(String elementName) throws ParseException {
 /*@bgen(jjtree) DerivedColumn */
        AST_DerivedColumn jjtn000 = new AST_DerivedColumn(this, JJTDERIVEDCOLUMN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "derived_column_S()" ) ;
    try {
      value_expression_A(elementName);
      if (jj_2_52(1)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          break;
        default:
          jj_la1[70] = jj_gen;
          ;
        }
        column_name_S();
                                                                        jjtn000.setAliased( elementName );
      } else {
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "derived_column_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * set_function_specification_S
 *
 * bnf-start
 *  <set_function_specification> ::=
 *      COUNT <left_paren> <asterisk> <right_paren>
 *    | <general_set_function>
 * bnf-end
 *
 */
  final public void set_function_specification_S() throws ParseException {
                                                                 /*@bgen(jjtree) SetFunctionSpecification */
  AST_SetFunctionSpecification jjtn000 = new AST_SetFunctionSpecification(this, JJTSETFUNCTIONSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_53(3)) {
        jj_consume_token(COUNT);
        jj_consume_token(LEFT_PAREN);
        jj_consume_token(ASTERISK);
        jj_consume_token(RIGHT_PAREN);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AVG:
        case COUNT:
        case MAX:
        case MIN:
        case SUM:
          general_set_function_A();
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void set_function_specification_part_fragment() throws ParseException {
 /*@bgen(jjtree) SetFunctionSpecificationPartFragment */
        AST_SetFunctionSpecificationPartFragment jjtn000 = new AST_SetFunctionSpecificationPartFragment(this, JJTSETFUNCTIONSPECIFICATIONPARTFRAGMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "set_function_specification_part_fragment()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      default:
        jj_la1[72] = jj_gen;
        if (jj_2_54(1)) {
          value_expression_A(null);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  if( log.isTraceEnabled() ) exitTrace ( "set_function_specification_part_fragment()" ) ;
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
    }
  }

/*
 * 
 *
 * bnf-start
 *  <set_limit> ::= TOP <unsigned_integer>
 * bnf-end
 *
 */
  final public void set_limit_A() throws ParseException {
 /*@bgen(jjtree) Restrict */
  AST_Restrict jjtn000 = new AST_Restrict(this, JJTRESTRICT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "set_limit_A" ) ;
  jjtn000.pushPosition() ;
  Token t = null ;
    try {
      try {
        jj_consume_token(TOP);
        t = jj_consume_token(UNSIGNED_INTEGER);
                        if( t!=null ) {
                                try {
                                   jjtn000.setLimit( ( new Integer( t.image )).intValue() ) ;
                                }
                                catch( NumberFormatException ex ) {
                                   {if (true) throw new ParseException( ex.getLocalizedMessage() ) ;}
                                }
                        }
      } catch (ParseException pex) {
            tracker.setError( pex.getLocalizedMessage() ) ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
        if( log.isTraceEnabled() ) exitTrace ( "set_limit_A" ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * set_quantifier_S
 *
 * bnf-single <set_quantifier> ::= DISTINCT | ALL
 *
 */
  final public void set_quantifier_S() throws ParseException {
 /*@bgen(jjtree) Allow */
  AST_Allow jjtn000 = new AST_Allow(this, JJTALLOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);jjtn000.pushPosition() ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
        break;
      case ALL:
        jj_consume_token(ALL);
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.popPosition() ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _single_datetime_field_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DAY:
    case HOUR:
    case MINUTE:
    case MONTH:
    case YEAR:
      _nonsecond_datetime_field_S();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _interval_leading_field_precision_S();
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
      break;
    case SECOND:
      jj_consume_token(SECOND);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        jj_consume_token(LEFT_PAREN);
        _interval_leading_field_precision_S();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          _interval_fractional_seconds_precision_S();
          break;
        default:
          jj_la1[75] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _start_field_S() throws ParseException {
    _nonsecond_datetime_field_S();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      _interval_leading_field_precision_S();
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
  }

/*
 * string_value_expression_A()
 *
 * bnf-start
 *  <string_value_expression> ::=
 *      <character_value_expression>
 * bnf-end
 *
 */
  final public void string_value_expression_A(String elementName) throws ParseException {
    character_value_expression_S(elementName);
  }

/*
 * subquery_S
 *
 * bnf-start
 *    <subquery> ::= <left_paren> <query_expression> <right_paren>
 * bnf-end
 */
  final public void subquery_S() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "subquery_S()" ) ;
    jj_consume_token(LEFT_PAREN);
    query_expression_A();
    jj_consume_token(RIGHT_PAREN);
                if( log.isTraceEnabled() ) exitTrace ( "subquery_S()" ) ;
  }

  final public void _quantified_comparison_predicate_S() throws ParseException {
    _row_value_constructor_S();
    comp_op_S();
    _quantifier_S();
    table_subquery_S();
  }

  final public void _quantifier_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
      jj_consume_token(ALL);
      break;
    case ANY:
    case SOME:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SOME:
        jj_consume_token(SOME);
        break;
      case ANY:
        jj_consume_token(ANY);
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * query_expression_A
 *
 * bnf-start
 *   <query_expression> ::=
 *       <query_specification>
 *     | <joined_table>
 * bnf-end
 *
 */
  final public void query_expression_A() throws ParseException {
 /*@bgen(jjtree) QueryExpression */
        AST_QueryExpression jjtn000 = new AST_QueryExpression(this, JJTQUERYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "query_expression_A()" ) ;
    try {
      if (jj_2_55(3)) {
        query_specification_A();
      } else if (jj_2_56(1)) {
        joined_table_A();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "query_expression_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _query_primary_S() throws ParseException {
    if (jj_2_57(3)) {
      _nonjoin_query_primary_S();
    } else if (jj_2_58(1)) {
      joined_table_A();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void query_term_S() throws ParseException {
    if (jj_2_59(2)) {
      _nonjoin_query_term_S();
    } else if (jj_2_60(1)) {
      joined_table_A();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void corresponding_spec_S() throws ParseException {
    jj_consume_token(CORRESPONDING);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BY:
      jj_consume_token(BY);
      jj_consume_token(LEFT_PAREN);
      corresponding_column_list_S();
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
  }

  final public void corresponding_column_list_S() throws ParseException {
    column_name_list_S();
  }

  final public void _nonjoin_query_expression_S() throws ParseException {
    if (jj_2_61(4)) {
      query_term_S();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXCEPT:
        case UNION:
          ;
          break;
        default:
          jj_la1[82] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNION:
          jj_consume_token(UNION);
          break;
        case EXCEPT:
          jj_consume_token(EXCEPT);
          break;
        default:
          jj_la1[83] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
          jj_consume_token(ALL);
          break;
        default:
          jj_la1[84] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CORRESPONDING:
          corresponding_spec_S();
          break;
        default:
          jj_la1[85] = jj_gen;
          ;
        }
        query_term_S();
      }
    } else if (jj_2_62(1)) {
      _nonjoin_query_term_S();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _nonjoin_query_term_S() throws ParseException {
    if (jj_2_63(3)) {
      _nonjoin_query_primary_S();
    } else if (jj_2_64(1)) {
      _query_primary_S();
      jj_consume_token(INTERSECT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
        jj_consume_token(ALL);
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CORRESPONDING:
        corresponding_spec_S();
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
      _query_primary_S();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _nonjoin_query_primary_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
    case TABLE:
    case VALUES:
      _simple_table_S();
      break;
    case LEFT_PAREN:
      jj_consume_token(LEFT_PAREN);
      _nonjoin_query_expression_S();
      jj_consume_token(RIGHT_PAREN);
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _nonsecond_datetime_field_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case YEAR:
      jj_consume_token(YEAR);
      break;
    case MONTH:
      jj_consume_token(MONTH);
      break;
    case DAY:
      jj_consume_token(DAY);
      break;
    case HOUR:
      jj_consume_token(HOUR);
      break;
    case MINUTE:
      jj_consume_token(MINUTE);
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void _simple_table_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      query_specification_A();
      break;
    case VALUES:
      _table_value_constructor_S();
      break;
    case TABLE:
      _explicit_table_S();
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * table_name_A
 *
 * bnf-start
 *  <table_name> ::= [ <schema_name> <period> ] <identifier>
 * bnf-end
 *
 */
  final public void table_name_A() throws ParseException {
 /*@bgen(jjtree) TableName */
        AST_TableName jjtn000 = new AST_TableName(this, JJTTABLENAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "table_name_A()" ) ;
    try {
      if (jj_2_65(4)) {
        objectOwnership();
      } else {
        ;
      }
      identifier_A();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "table_name_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/* 
 * table_reference_A
 *
 * bnf-start
 *  <table_reference> ::=
 *     <table_name> [ <correlation_specification> ]
 *   | <derived_table> <correlation_specification>
 *   | <joined_table>
 * bnf-end
 *
 */
  final public void table_reference_A() throws ParseException {
 /*@bgen(jjtree) TableReference */
        AST_TableReference jjtn000 = new AST_TableReference(this, JJTTABLEREFERENCE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "table_reference_A()" ) ;
        jjtn000.pushPosition( AdqlParser.TABLE_ELEMENT ) ;
    try {
      try {
        if (jj_2_67(2147483647)) {
          tableReference2();
          label_14:
          while (true) {
            if (jj_2_66(3)) {
              ;
            } else {
              break label_14;
            }
            joinPart();
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEFT_PAREN:
            jj_consume_token(LEFT_PAREN);
            joined_table_A();
            jj_consume_token(RIGHT_PAREN);
            break;
          default:
            jj_la1[91] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } catch (ParseException pex) {
                parser.errorSkipTo( AdqlParser.TABLE_REF_SKIP_TO ) ;
        tracker.setError( pex ) ;
      } finally {
                jjtn000.popPosition( AdqlParser.TABLE_ELEMENT ) ;
                if( log.isTraceEnabled() ) exitTrace ( "table_reference_A()" ) ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/* 
 * qualified_join_A
 *
 * bnf-start
 *  <qualified_join> ::=
 *      <table_reference> [ NATURAL ] [ <join_type> ] JOIN
 *      <table_reference> [ <join_specification> ]
 * bnf-end
 *
 */
  final public void qualified_join_A() throws ParseException {
 /*@bgen(jjtree) QualifiedJoin */
        AST_QualifiedJoin jjtn000 = new AST_QualifiedJoin(this, JJTQUALIFIEDJOIN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "qualified_join_A()" ) ;
    try {
      tableReference2();
      joinPart();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "qualified_join_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/* 
 * joinPart
 *
 */
  final public void joinPart() throws ParseException {
 /*@bgen(jjtree) JoinPart */
        AST_JoinPart jjtn000 = new AST_JoinPart(this, JJTJOINPART);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "joinPart()" ) ;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NATURAL:
          jj_consume_token(NATURAL);
                              jjtn000.setNatural( true );
          break;
        default:
          jj_la1[92] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FULL:
        case INNER:
        case LEFT:
        case RIGHT:
          join_type_A();
          break;
        default:
          jj_la1[93] = jj_gen;
          ;
        }
        jj_consume_token(JOIN);
        table_reference_A();
        if (jj_2_68(3)) {
          join_specification_S();
        } else {
          ;
        }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                        if( jjtn000.isNatural() && jjtn000.isJoinSpecification() ) {
                                {if (true) throw new ParseException( "NATURAL join with join specification." ) ;}
                        }
      } catch (ParseException pex) {
                {if (true) throw pex ;}
      } finally {
                if( log.isTraceEnabled() ) exitTrace ( "joinPart()" ) ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/* 
 * tableReference2
 *
 *
 */
  final public void tableReference2() throws ParseException {
 /*@bgen(jjtree) TableReference2 */
        AST_TableReference2 jjtn000 = new AST_TableReference2(this, JJTTABLEREFERENCE2);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "tableReference2()" ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN:
        derived_table_S();
        correlation_specification_A();
        break;
      default:
        jj_la1[94] = jj_gen;
        if (jj_2_70(1)) {
          table_name_A();
          if (jj_2_69(1)) {
            correlation_specification_A();
          } else {
            ;
          }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "tableReference2()" ) ;
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * correlation_specification_A
 *
 * bnf-single <correlation_specification> ::= [ AS ] <correlation_name>
 *
 */
  final public void correlation_specification_A() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    correlation_name_S();
  }

/*
 * table_subquery_S
 *
 * bnf-start
 *  <table_subquery> ::= <subquery>
 * bnf-end
 *
 */
  final public void table_subquery_S() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "table_subquery_S" ) ;
    subquery_S();
                if( log.isTraceEnabled() ) exitTrace ( "table_subquery_S" ) ;
  }

  final public void _table_value_constructor_S() throws ParseException {
    jj_consume_token(VALUES);
    _table_value_constructor_list_S();
  }

  final public void _table_value_constructor_list_S() throws ParseException {
    _row_value_constructor_S();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[96] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      _row_value_constructor_S();
    }
  }

/*
 * term_S
 *
 * bnf-start
 *  <term> ::=
 *      <factor>
 *    | <term> <asterisk> <factor>
 *    | <term> <solidus> <factor>
 * bnf-end
 *
 */
  final public void term_S(String elementName) throws ParseException {
 /*@bgen(jjtree) Term */
        AST_Term jjtn000 = new AST_Term(this, JJTTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "term_S()" ) ;
        Token t = null ;
    try {
      factorBitTerm(elementName);
      if (jj_2_71(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
          t = jj_consume_token(ASTERISK);
          break;
        case SOLIDUS:
          t = jj_consume_token(SOLIDUS);
          break;
        default:
          jj_la1[97] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                 jjtn000.setOperator(t);
        term_S(AdqlParser.ARG_ELEMENT);
      } else {
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "term_S()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void factorBitTerm(String element) throws ParseException {
 /*@bgen(jjtree) BitTerm */
        AST_BitTerm jjtn000 = new AST_BitTerm(this, JJTBITTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "factorBitTerm()" ) ;
        Token t = null ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = bitwiseNOT();
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      factor_S(element);
                   if( t != null ) {
                          jjtn000.setBitInversion( t.image ) ;
                          if( !parser.isSyntaxSet( SyntaxOption.BITWISE_MANIPULATION) ) {
                                  tracker.setError( "Reference Implementation: Bit value expressions not supported." ) ;
                          }
                   }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "factorBitTerm()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _time_fractional_seconds_precision_S() throws ParseException {
    jj_consume_token(UNSIGNED_INTEGER);
  }

  final public void _time_precision_S() throws ParseException {
    _time_fractional_seconds_precision_S();
  }

  final public void _timestamp_precision_S() throws ParseException {
    _time_fractional_seconds_precision_S();
  }

  final public void _time_zone_S() throws ParseException {
    jj_consume_token(AT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      jj_consume_token(LOCAL);
      break;
    case TIME_ZONE:
      jj_consume_token(TIME_ZONE);
      _interval_value_expression_S();
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * 
 *
 * bnf-start
 *  <trig_function> ::=
 *      ACOS <left_paren> <numeric_value_expression> <right_paren>
 *    | ASIN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN2 <left_paren> <numeric_value_expression> <comma> <numeric_value_expression> <right_paren>
 *    | COS <left_paren> <numeric_value_expression> <right_paren>
 *    | COT <left_paren> <numeric_value_expression> <right_paren>
 *    | SIN <left_paren> <numeric_value_expression> <right_paren>
 *    | TAN <left_paren> <numeric_value_expression> <right_paren>
 * bnf-end
 *
 */
  final public void trig_function_A(String elementName) throws ParseException {
 /*@bgen(jjtree) TrigFunction */
        AST_TrigFunction jjtn000 = new AST_TrigFunction(this, JJTTRIGFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "trig_function_A()" ) ;
        jjtn000.pushPosition( elementName ) ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACOS:
        jj_consume_token(ACOS);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case ASIN:
        jj_consume_token(ASIN);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case ATAN:
        jj_consume_token(ATAN);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case ATAN2:
        jj_consume_token(ATAN2);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(COMMA);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case COS:
        jj_consume_token(COS);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case COT:
        jj_consume_token(COT);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case SIN:
        jj_consume_token(SIN);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      case TAN:
        jj_consume_token(TAN);
        jj_consume_token(LEFT_PAREN);
        numeric_value_expression_S(AdqlParser.ARG_ELEMENT);
        jj_consume_token(RIGHT_PAREN);
        break;
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition( elementName ) ;
                if( log.isTraceEnabled() ) exitTrace ( "trig_function_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void _unique_predicate_S() throws ParseException {
    jj_consume_token(UNIQUE);
    table_subquery_S();
  }

/*
 * unsigned_literal_S
 *
 * bnf-single <unsigned_literal> ::= <unsigned_numeric_literal> | <general_literal>
 *
 */
  final public void unsigned_literal_S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APPROXIMATE_NUMERIC_LITERAL:
    case UNSIGNED_INTEGER:
    case EXACT_NUMERIC_LITERAL:
      unsigned_numeric_literal_S();
      break;
    case ASCII_STRING_LITERAL:
    case BIT_STRING_LITERAL:
    case HEX_STRING_LITERAL:
      general_literal_A();
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * unsigned_numeric_literal_S
 *
 * bnf-start
 *  <unsigned_numeric_literal> ::=
 *     <exact_numeric_literal>
 *   | <approximate_numeric_literal>
 * bnf-end
 *
 */
  final public void unsigned_numeric_literal_S() throws ParseException {
    if( log.isTraceEnabled() ) enterTrace ( "unsigned_numeric_literal_S()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNSIGNED_INTEGER:
    case EXACT_NUMERIC_LITERAL:
      exact_numeric_literal_S(+1);
      break;
    case APPROXIMATE_NUMERIC_LITERAL:
      approximate_numeric_literal_S(+1);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "unsigned_numeric_literal_S()" ) ;
  }

/*
 * approximate_numeric_literal_S
 *
 * bnf-start
 *  <approximate_numeric_literal> ::= <mantissa>E<exponent>
 * bnf-end
 *
 */
  final public void approximate_numeric_literal_S(int sign) throws ParseException {
 /*@bgen(jjtree) ApproximateNumericLiteral */
        AST_ApproximateNumericLiteral jjtn000 = new AST_ApproximateNumericLiteral(this, JJTAPPROXIMATENUMERICLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "approximate_numeric_literal_S()" ) ;
        jjtn000.setSign( sign ) ;
    try {
      jj_consume_token(APPROXIMATE_NUMERIC_LITERAL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "approximate_numeric_literal_S()" ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * unsigned_value_specification_S
 *
 *-bnf-start
 *- <unsigned_value_specification> ::=
 *-     <unsigned_literal>
 *-   | <general_value_specification>
 *-bnf-end
 * 
 * bnf-start
 *  <unsigned_value_specification> ::= <unsigned_literal>
 * bnf-end
 *
 */
  final public void unsigned_value_specification_S() throws ParseException {
    unsigned_literal_S();
  }

/*
 * value_expression_A
 *
 * bnf-start v21-Projection
 *  <value_expression> ::=
 *      <numeric_value_expression>
 *    | <string_value_expression>
 *    | <geometry_value_expression>
 * bnf-end
 * bnf-start v20+RFC,v20-AG
 *  <value_expression> ::=
 *      <numeric_value_expression>
 *    | <string_value_expression>
 * bnf-end
 *
 */
  final public void value_expression_A(String elementName) throws ParseException {
 /*@bgen(jjtree) ValueExpression */
    AST_ValueExpression jjtn000 = new AST_ValueExpression(this, JJTVALUEEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "value_expression_A()" ) ;
    try {
      try {
        if (jj_2_72(16) && (parser.findFirstOperator(16,0) != 1)) {
          numericValueExpressionBitFactor();
        } else if (jj_2_73(16)) {
          string_value_expression_A(elementName);
        } else if (jj_2_74(1)) {
          geometry_value_expression_A(elementName);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException pex) {
        if( log.isDebugEnabled() ) log.debug( "value_expression_A() throwing pex" ) ;
                {if (true) throw pex ;}
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "value_expression_A()" ) ;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * restricted_value_expression_A
 *
 * This is a restricted version of the main structure value_expression_A().
 * At present it is here purely for the sake of the COMPARISON and BETWEEN predicates...
 * geometry_value_expression_A() is omitted as there is no such thing as
 * being between two geometries (well, at the present time), nor of comparing geometries.
 */
  final public void restricted_value_expression_A(String elementName) throws ParseException {
 /*@bgen(jjtree) ValueExpression */
    AST_ValueExpression jjtn000 = new AST_ValueExpression(this, JJTVALUEEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "restricted_value_expression_A()" ) ;
    try {
      try {
        if (jj_2_75(16) && (parser.findFirstOperator(16,0) !=1)) {
          numericValueExpressionBitFactor();
        } else if (jj_2_76(1)) {
          string_value_expression_A(elementName);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException pex) {
        if( log.isDebugEnabled() ) log.debug( "restricted_value_expression_A() throwing pex" ) ;
                {if (true) throw pex ;}
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "restricted_value_expression_A()" ) ;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * variable_specification_A
 *
 *-bnf-start
 *-<variable_specification> ::=
 *-    <dollar> <left_brace> <regular_identifier> <right_brace>
 *-  | VAR <regular_identifier>
 *- !! ADQL Note:
 *- !! Not in the draft spec.
 *- !! Part of an ADQL experiment to specify symbolic scripting variables.
 *-bnf-end
 *
 */
  final public void variable_specification_A() throws ParseException {
 /*@bgen(jjtree) VariableSpec */
        AST_VariableSpec jjtn000 = new AST_VariableSpec(this, JJTVARIABLESPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "variable_specification_A" ) ;
        Token t ;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOLLAR:
        jj_consume_token(DOLLAR);
        jj_consume_token(LBRACE);
        t = jj_consume_token(REGULAR_IDENTIFIER);
        jj_consume_token(RBRACE);
        break;
      case VAR:
        jj_consume_token(VAR);
        t = jj_consume_token(REGULAR_IDENTIFIER);
        break;
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( t != null ) {
                        jjtn000.setVariable( t.image ) ;
                }
        if( log.isTraceEnabled() ) exitTrace ( "variable_specification_A" ) ;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * where_clause_S
 *
 * bnf-single <where_clause> ::= WHERE <search_condition>
 *
 */
  final public void where_clause_S() throws ParseException {
 /*@bgen(jjtree) Where */
        AST_Where jjtn000 = new AST_Where(this, JJTWHERE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "where_clause_S" ) ;
        jjtn000.pushPosition() ;
        Token whereToken = null ;
        Token eof = null ;
    try {
      try {
        whereToken = jj_consume_token(WHERE);
        search_condition_S();
      } catch (ParseException pex) {
        boolean eofEncountered = parser.errorSkipTo( parser.WHERE_SKIP_TO ) ;
        boolean matchingBraces = parser.checkForMatchingBraces( whereToken, token ) ;
        if( matchingBraces ) {
                tracker.setError( pex ) ;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.popPosition() ;
                if( log.isTraceEnabled() ) exitTrace ( "where_clause_S" ) ;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * non_predicate_geometry_function_A
 *
 * bnf-start v20+RFC 
 *   <system_defined_function> ::=
 *       <distance_function>
 *     | <region_function>
 *     | <longitude>
 *     | <latitude>
 *     | <area>
 * bnf-end
 *
 * bnf-start v21-Projection
 *  <non_predicate_geometry_function> ::= 
 *     <area>
 *   | <coord1>
 *   | <coord2> 
 *   | <distance>
 * bnf-end
 *
 */
  final public void non_predicate_geometry_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "non_predicate_geometry_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTANCE:
      distance_A(elementName);
      break;
    case LATITUDE:
      coord1_A(elementName);
      break;
    case LONGITUDE:
      coord2_A(elementName);
      break;
    case AREA:
      area_A(elementName);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "non_predicate_geometry_function_A()" ) ;
  }

/*
 * distance_A
 *
 * bnf-start v20+RFC 
 *   <distance_function> ::= DISTANCE <left_paren> <point> <comma> <point> <right_paren>
 * bnf-end
 *
 * bnf-start v21-Projection
 *  <distance> ::=     
 *     DISTANCE <left_paren> <coord_value> <comma> <coord_value> <right_paren>
 * bnf-end
 *
 */
  final public void distance_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "distance_A()" ) ;
    try {
      jj_consume_token(DISTANCE);
      jj_consume_token(LEFT_PAREN);
      coord_value_A(elementName);
      jj_consume_token(COMMA);
      coord_value_A(elementName);
      jj_consume_token(RIGHT_PAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
        if( log.isTraceEnabled() ) exitTrace ( "distance_A()" ) ;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
 * predicate_geometry_function_A
 *
 * bnf-start v20+RFC
 *    <region_function> ::= <contains_function> | <intersects_function>
 * bnf-end
 *
 * bnf-start v21-Projection
 *   <predicate_geometry_function> ::= <contains> | <intersects>
 * bnf-end
 *
 */
  final public void predicate_geometry_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "predicate_geometry_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTAINS:
      contains_A(elementName);
      break;
    case INTERSECTS:
      intersects_A(elementName);
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "predicate_geometry_function_A()" ) ;
  }

/*
 * contains_A
 *
 * bnf-start v20+RFC
 *   <contains_function> ::= CONTAINS <left_paren> <geometry_value_expression> <comma> <geometry_value_expression> <right_paren>  
 * bnf-end
 *
 * bnf-start v21-Projection
 *   <contains> ::= CONTAINS <left_paren> <geometry_value_expression> <comma> <geometry_value_expression> <right_paren>  
 * bnf-end
 *
 */
  final public void contains_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "contains_A()" ) ;
    try {
      jj_consume_token(CONTAINS);
      jj_consume_token(LEFT_PAREN);
      geometry_value_expression_A(null);
      jj_consume_token(COMMA);
      geometry_value_expression_A(null);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "contains_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * intersects_A
 *
 * bnf-start v20+RFC
 *   <intersects_function> ::= INTERSECTS <left_paren> <geometry_value_expression> <comma> <geometry_value_expression> <right_paren>
 * bnf-end
 *
 * bnf-start v21-Projection
 *   <intersects> ::= INTERSECTS <left_paren> <geometry_value_expression> <comma> <geometry_value_expression> <right_paren>
 * bnf-end
 *
 */
  final public void intersects_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "intersects_A()" ) ;
    try {
      jj_consume_token(INTERSECTS);
      jj_consume_token(LEFT_PAREN);
      geometry_value_expression_A(null);
      jj_consume_token(COMMA);
      geometry_value_expression_A(null);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "intersects_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * geometry_value_expression_A
 *
 * bnf-start v20+RFC
 *   <geometry_value_expression> ::= <geometry_expression> | <geometry_value> | <centroid>
 * bnf-end
 *
 * bnf-start v20+RFC
 *   <geometry_expression> ::= <point> | <circle> | <box> | <polygon> | <region>
 * bnf-end
 *
 * bnf-start v20+RFC
 *   <geometry_value> ::= <column_reference>
 * bnf-end
 *
 * bnf-start v21-Projection
 *  <geometry_value_expression> ::= <value_expression_primary> | <geometry_value_function>
 * bnf-end
 *
 */
  final public void geometry_value_expression_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "geometry_value_expression_A()" ) ;
    if (jj_2_77(3)) {
      value_expression_primary_A(elementName);
    } else if (jj_2_78(1)) {
      geometry_value_function_A(elementName);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "geometry_value_expression_A()" ) ;
  }

/*
 * geometry_value_function_A
 *
 * bnf-start v21-Projection
 *   <geometry_value_function> ::=
 *       <box> 
 *     | <centroid> 
 *     | <circle> 
 *     | <point> 
 *     | <polygon> 
 *     | <region> 
 *     | <user_defined_function>
 * bnf-end
 *
 */
  final public void geometry_value_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "geometry_value_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CENTROID:
    case REGION:
    case CIRCLE:
    case POLYGON:
    case BOX:
    case POINT:
      region_function_A(elementName);
      break;
    default:
      jj_la1[106] = jj_gen;
      if (jj_2_79(1)) {
        user_defined_function_A(elementName);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                if( log.isTraceEnabled() ) exitTrace ( "geometry_value_function_A()" ) ;
  }

  final public void region_function_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "region_function_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POINT:
      point_A(elementName);
      break;
    case CIRCLE:
      circle_A(elementName);
      break;
    case BOX:
      box_A(elementName);
      break;
    case POLYGON:
      polygon_A(elementName);
      break;
    case REGION:
      region_A(elementName);
      break;
    case CENTROID:
      centroid_A(elementName);
      break;
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if( log.isTraceEnabled() ) exitTrace ( "region_function_A()" ) ;
  }

/*
 * centroid_A
 *
 * bnf-start v20+RFC
 *   <centroid> ::= CENTROID <left_paren> <geometry_expression> <right_paren>
 * bnf-end
 *
 * bnf-start v21-Projection
 *  <centroid> ::= CENTROID <left_paren> <geometry_value_expression> <right_paren>
 * bnf-end
 */
  final public void centroid_A(String elementName) throws ParseException {
 /*@bgen(jjtree) GeometryFunction */
        AST_GeometryFunction jjtn000 = new AST_GeometryFunction(this, JJTGEOMETRYFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "centroid_A()" ) ;
    try {
      jj_consume_token(CENTROID);
      jj_consume_token(LEFT_PAREN);
      geometry_value_expression_A(elementName);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "centroid_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * coord1_A
 *
 * bnf-start v20+RFC
 *   <longitude> ::= LONGITUDE <left_paren> <point> <right_paren>
 * bnf-end
 *
 * bnf-start v21-Projection 
 *  <coord1> ::= COORD1 <left_paren> <coord_value> <right_paren>
 * bnf-end
 */
  final public void coord1_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "coord1_A()" ) ;
    try {
      jj_consume_token(LATITUDE);
      jj_consume_token(LEFT_PAREN);
      coord_value_A(elementName);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "coord1_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * coord2_A
 *
 * bnf-start v20+RFC
 *   <latitude> ::= LATITUDE <left_paren> <point> <right_paren>
 * bnf-end 
 *
 * bnf-start v21-Projection
 *  <coord2> ::= COORD2 <left_paren> <coord_value> <right_paren>
 * bnf-end
 */
  final public void coord2_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "coord2_A()" ) ;
    try {
      jj_consume_token(LONGITUDE);
      jj_consume_token(LEFT_PAREN);
      coord_value_A(elementName);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "coord2_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * area_A
 *
 * bnf-start V20+RFC,v21-Projection
 *  <area> ::= AREA <left_paren> <geometry_value_expression> <right_paren>
 * bnf-end
 */
  final public void area_A(String elementName) throws ParseException {
 /*@bgen(jjtree) SystemDefinedFunction */
        AST_SystemDefinedFunction jjtn000 = new AST_SystemDefinedFunction(this, JJTSYSTEMDEFINEDFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);if( log.isTraceEnabled() ) enterTrace ( "area_A()" ) ;
    try {
      jj_consume_token(AREA);
      jj_consume_token(LEFT_PAREN);
      geometry_value_expression_A(elementName);
      jj_consume_token(RIGHT_PAREN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if( log.isTraceEnabled() ) exitTrace ( "area_A()" ) ;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

/*
 * coord_value_A
 *
 * bnf-start v21-Projection
 *   <coord_value> ::= <point> | <column_reference>
 * bnf-end
 *
 */
  final public void coord_value_A(String elementName) throws ParseException {
        if( log.isTraceEnabled() ) enterTrace ( "coord_value_A()" ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POINT:
      point_A(elementName);
      break;
    default:
      jj_la1[108] = jj_gen;
      if (jj_2_80(1)) {
        column_reference_A(elementName);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                if( log.isTraceEnabled() ) exitTrace ( "coord_value_A()" ) ;
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  final private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  final private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  final private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  final private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  final private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  final private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  final private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  final private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  final private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  final private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  final private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  final private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  final private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  final private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  final private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  final private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  final private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  final private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  final private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  final private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  final private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  final private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  final private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  final private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  final private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  final private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  final private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  final private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  final private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  final private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  final private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  final private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  final private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  final private boolean jj_2_78(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  final private boolean jj_2_79(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  final private boolean jj_2_80(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  final private boolean jj_3_60() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_59()) {
    jj_scanpos = xsp;
    if (jj_3_60()) return true;
    }
    return false;
  }

  final private boolean jj_3_59() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_253() {
    if (jj_3R_268()) return true;
    return false;
  }

  final private boolean jj_3R_256() {
    if (jj_3R_271()) return true;
    return false;
  }

  final private boolean jj_3R_255() {
    if (jj_3R_270()) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_3R_127()) return true;
    return false;
  }

  final private boolean jj_3R_290() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_254() {
    if (jj_3R_269()) return true;
    return false;
  }

  final private boolean jj_3R_232() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3_58() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_289() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(153)) {
    jj_scanpos = xsp;
    if (jj_scan_token(202)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(182)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3_58()) return true;
    }
    return false;
  }

  final private boolean jj_3_57() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_294() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_3R_210()) return true;
    }
    return false;
  }

  final private boolean jj_3_56() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3_55() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_55()) {
    jj_scanpos = xsp;
    if (jj_3_56()) return true;
    }
    return false;
  }

  final private boolean jj_3R_293() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(309)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(310)) {
    jj_scanpos = xsp;
    if (jj_scan_token(311)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_287() {
    if (jj_3R_293()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_294()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(WHERE)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_scan_token(POINT)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_286()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_137()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_133()) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_3R_239()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_scan_token(322)) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(USING)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_211()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_127()) return true;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_129()) return true;
    return false;
  }

  final private boolean jj_3_39() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3_41() {
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_3R_161()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(ON)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3_76() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3_75() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_89()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_233() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_22()) return true;
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    }
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_89()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_227()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(SECOND)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_160()) return true;
    return false;
  }

  final private boolean jj_3R_296() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.findFirstOperator(16,0) !=1;
    lookingAhead = false;
    if (!jj_semLA || jj_3_75()) {
    jj_scanpos = xsp;
    if (jj_3_76()) return true;
    }
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    }
    return false;
  }

  final private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  final private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3_74() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_3R_24()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_296()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_233()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_73() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(CONCATENATION_OPERATOR)) return true;
    if (jj_3R_127()) return true;
    return false;
  }

  final private boolean jj_3_72() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    }
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_36()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_127()) return true;
    return false;
  }

  final private boolean jj_3_54() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_scan_token(TOP)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_35()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_3R_37()) return true;
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_166()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_167()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_225()) return true;
    return false;
  }

  final private boolean jj_3R_234() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    return false;
  }

  final private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(TO)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3_53() {
    if (jj_scan_token(COUNT)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_53()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_201()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_20()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_277() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(304)) {
    jj_scanpos = xsp;
    if (jj_scan_token(306)) return true;
    }
    return false;
  }

  final private boolean jj_3_36() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_292() {
    if (jj_scan_token(ASCII_STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.findFirstOperator(16,0) != 1;
    lookingAhead = false;
    if (!jj_semLA || jj_3_72()) {
    jj_scanpos = xsp;
    if (jj_3_73()) {
    jj_scanpos = xsp;
    if (jj_3_74()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_284() {
    if (jj_3R_292()) return true;
    return false;
  }

  final private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_scan_token(322)) return true;
    }
    return false;
  }

  final private boolean jj_3R_281() {
    Token xsp;
    if (jj_3R_284()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_284()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_52()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_234()) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    return false;
  }

  final private boolean jj_3R_276() {
    if (jj_3R_281()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_3R_202()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    }
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(PERIOD_ASTERISK)) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(COORDSYS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_235() {
    return false;
  }

  final private boolean jj_3R_275() {
    if (jj_scan_token(APPROXIMATE_NUMERIC_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3_51() {
    if (jj_3R_55()) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_205()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_41()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) jj_scanpos = xsp;
    if (jj_scan_token(IN)) return true;
    if (jj_3R_105()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_147()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_148()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_132()) return true;
    return false;
  }

  final private boolean jj_3_50() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_205() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.findPeriodAsterisk(12) == false;
    lookingAhead = false;
    if (!jj_semLA || jj_3_50()) {
    jj_scanpos = xsp;
    if (jj_3_51()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_260() {
    if (jj_3R_275()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_259() {
    if (jj_3R_274()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_19()) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3_5()) return true;
    }
    return false;
  }

  final private boolean jj_3R_246() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) return true;
    }
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(ORDERBY)) return true;
    if (jj_3R_110()) return true;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_scan_token(ASTERISK)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_205()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_206()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_204()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(HAVING)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_3R_246()) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_215()) return true;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_3R_247()) return true;
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3_34() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    }
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.ifQualifiedPartsEqual(3);
    lookingAhead = false;
    if (!jj_semLA || jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3_35()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_scan_token(TAN)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_scan_token(SIN)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_295() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3_32() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_scan_token(COT)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_18()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(COS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_106()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) jj_scanpos = xsp;
    if (jj_scan_token(LIKE)) return true;
    if (jj_3R_108()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_3R_145()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_146()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.ifQualifiedPartsEqual(4);
    lookingAhead = false;
    if (!jj_semLA || jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3_32()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(ATAN2)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_222()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(ASIN)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(ACOS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_scan_token(ATAN)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) jj_scanpos = xsp;
    if (jj_scan_token(REGULAR_IDENTIFIER)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    xsp = jj_scanpos;
    if (jj_3_29()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(GROUPBY)) return true;
    if (jj_3R_109()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_130()) jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_52()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_295()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(TIME_ZONE)) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(156)) {
    jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    }
    return false;
  }

  final private boolean jj_3R_279() {
    if (jj_3R_283()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_78()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_48() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3_49() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_53()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_232()) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_3R_231()) return true;
    return false;
  }

  final private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) {
    jj_scanpos = xsp;
    if (jj_3_49()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_258() {
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_283() {
    if (jj_3R_87()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_225() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) return true;
    }
    }
    }
    }
    if (jj_scan_token(LEFT_PAREN)) return true;
    xsp = jj_scanpos;
    if (jj_3R_258()) jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_47() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3_46() {
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3_45() {
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_3R_175()) return true;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_3R_142()) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_141()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_16()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3_27()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_3R_277()) return true;
    return false;
  }

  final private boolean jj_3R_261() {
    if (jj_3R_276()) return true;
    return false;
  }

  final private boolean jj_3R_247() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) return true;
    }
    return false;
  }

  final private boolean jj_3_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_131() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3_2()) return true;
    }
    return false;
  }

  final private boolean jj_3_80() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_273() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_272()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(SELECT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_111()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    if (jj_3R_114()) return true;
    xsp = jj_scanpos;
    if (jj_3_44()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_45()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_46()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_47()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_97()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_71()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_3R_240()) return true;
    return false;
  }

  final private boolean jj_3R_278() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3_80()) return true;
    }
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_3R_214()) return true;
    return false;
  }

  final private boolean jj_3R_257() {
    if (jj_3R_272()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_273()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_121()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_285()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_101()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) jj_scanpos = xsp;
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_3R_101()) return true;
    if (jj_scan_token(AND)) return true;
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_scan_token(VALUES)) return true;
    if (jj_3R_257()) return true;
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(CIRCUMFLEX)) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_213()) return true;
    return false;
  }

  final private boolean jj_3R_271() {
    if (jj_scan_token(AREA)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_scan_token(VERTICAL_BAR)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_87()) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(AMPERSAND)) return true;
    return false;
  }

  final private boolean jj_3R_265() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    return false;
  }

  final private boolean jj_3R_250() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) jj_scanpos = xsp;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_212()) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_270() {
    if (jj_scan_token(LONGITUDE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_278()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) return true;
    }
    }
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3_69() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_38()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3_42() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_269() {
    if (jj_scan_token(LATITUDE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_278()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = parser.checkSomeReservedWords() == false;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_135()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(317)) {
    jj_scanpos = xsp;
    if (jj_scan_token(318)) return true;
    }
    return false;
  }

  final private boolean jj_3_70() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_69()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3_70()) return true;
    }
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_3R_159()) return true;
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_37()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_scan_token(TABLE)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_68() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_245() {
    if (jj_scan_token(CENTROID)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_3R_156()) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(NATURAL)) return true;
    return false;
  }

  final private boolean jj_3_79() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_scan_token(REGION)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_69()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_119()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) jj_scanpos = xsp;
    if (jj_scan_token(JOIN)) return true;
    if (jj_3R_121()) return true;
    xsp = jj_scanpos;
    if (jj_3_68()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_221() {
    if (jj_3R_245()) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3_26()) return true;
    }
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_3R_244()) return true;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_243()) return true;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_3R_242()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_3R_241()) return true;
    return false;
  }

  final private boolean jj_3_66() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_3R_64()) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_3R_240()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_274() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(324)) {
    jj_scanpos = xsp;
    if (jj_scan_token(322)) return true;
    }
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_3R_168()) return true;
    return false;
  }

  final private boolean jj_3_67() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3_79()) return true;
    }
    return false;
  }

  final private boolean jj_3R_288() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_57()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_64()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_66()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_3R_25()) return true;
    if (jj_scan_token(IS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) jj_scanpos = xsp;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  final private boolean jj_3R_291() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_250()) return true;
    return false;
  }

  final private boolean jj_3_78() {
    if (jj_3R_71()) return true;
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_250()) return true;
    return false;
  }

  final private boolean jj_3_77() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_243() {
    if (jj_scan_token(POLYGON)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_286()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    Token xsp;
    if (jj_3R_291()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_291()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_scan_token(TRUNCATE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_89()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_77()) {
    jj_scanpos = xsp;
    if (jj_3_78()) return true;
    }
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(ROUND)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_264() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_scan_token(322)) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(RAND)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_263() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_scan_token(322)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(LOG10)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_65() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_scan_token(SQRT)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_65()) jj_scanpos = xsp;
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_scan_token(SQUARE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) return true;
    }
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_249() {
    if (jj_scan_token(CURRENT_TIMESTAMP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_264()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_scan_token(RADIANS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_scan_token(CURRENT_TIME)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_263()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_226() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_267() {
    if (jj_scan_token(INTERSECTS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_scan_token(POWER)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_3R_237()) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_scan_token(PI)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_3R_236()) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_scan_token(LOG)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3_15()) return true;
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_28()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_13()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_scan_token(FLOOR)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_252() {
    if (jj_3R_267()) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(257)) {
    jj_scanpos = xsp;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_scan_token(EXP)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_scan_token(CIRCLE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_286()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_288()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_266() {
    if (jj_scan_token(CONTAINS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_70()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_scan_token(DEGREES)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_154()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    }
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_3R_153()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_scan_token(CEILING)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) return true;
    }
    return false;
  }

  final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(238)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(36)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_scan_token(ABS)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_38()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_3R_226()) return true;
    return false;
  }

  final private boolean jj_3_64() {
    if (jj_3R_62()) return true;
    if (jj_scan_token(INTERSECT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(36)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_238()) jj_scanpos = xsp;
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_63()) {
    jj_scanpos = xsp;
    if (jj_3_64()) return true;
    }
    return false;
  }

  final private boolean jj_3_63() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_136()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_251() {
    if (jj_3R_266()) return true;
    return false;
  }

  final private boolean jj_3R_231() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) return true;
    }
    return false;
  }

  final private boolean jj_3_62() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_scan_token(BOX)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_286()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_289()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_290()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3_61() {
    if (jj_3R_60()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_61()) {
    jj_scanpos = xsp;
    if (jj_3_62()) return true;
    }
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_scan_token(DISTANCE)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_278()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_278()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_scan_token(CORRESPONDING)) return true;
    return false;
  }

  final private boolean jj_3R_286() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_101()) return true;
    if (jj_3R_102()) return true;
    if (jj_3R_101()) return true;
    return false;
  }

  public AdqlStoXTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[109];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
      jj_la1_5();
      jj_la1_6();
      jj_la1_7();
      jj_la1_8();
      jj_la1_9();
      jj_la1_10();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x28000,0x28000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x10000,0x0,0x1000,0x1c00000,0x0,0x28000,0x1000,0x1000,0x0,0x1000,0x0,0x0,0x28000,0x28000,0x10000,0x0,0x0,0x0,0x10000,0x0,0x1000,0x28000,0x28000,0x0,0x84000,0x28000,0x1000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x0,0x0,0x28000,0x28000,0x30000400,0x30000400,0x0,0x0,0x10000,0x10000,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x200000,0x1000,0x10000,0x0,0x10000,0x4000,0x0,0x0,0x4000,0x0,0x1000,0x10000,0x1000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x10000,0x84000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x800,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x8000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x100,0x110,0x200000,0x0,0x0,0x10,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0xe0000,0x0,0x0,0x0,0xe0000,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2000200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x2000200,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x400,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x400,0x0,0x0,0x0,0xa,0x0,0x0,0x0,0x0,0x10000,0x0,0x400000,0x0,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0xa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x800000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x20000,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x800001,0x0,0x800001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_8() {
      jj_la1_8 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff00000,0x0,0x0,0x0,0x0,0x0,0xfff70610,0x70610,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20610,0x50000,0x8d820,0x8d820,0x80000,};
   }
   private static void jj_la1_9() {
      jj_la1_9 = new int[] {0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x50000,0x0,0x0,0x58000,0x0,0xe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x7ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x7f8,0x58000,0x0,0x4800,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_10() {
      jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x16,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x16,0x16,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[80];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public AdqlStoX(java.io.InputStream stream) {
     this(stream, null);
  }
  public AdqlStoX(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AdqlStoXTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public AdqlStoX(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AdqlStoXTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public AdqlStoX(AdqlStoXTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(AdqlStoXTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 109; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[334];
    for (int i = 0; i < 334; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 109; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
          if ((jj_la1_8[i] & (1<<j)) != 0) {
            la1tokens[256+j] = true;
          }
          if ((jj_la1_9[i] & (1<<j)) != 0) {
            la1tokens[288+j] = true;
          }
          if ((jj_la1_10[i] & (1<<j)) != 0) {
            la1tokens[320+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 334; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 80; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
