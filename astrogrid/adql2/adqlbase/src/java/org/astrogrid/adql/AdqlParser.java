package org.astrogrid.adql ;

import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;

import org.astrogrid.adql.metadata.MetadataQuery ;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.StringReader;
import java.util.HashSet ;
import java.util.HashMap ;
import java.util.Iterator ;
import java.util.ArrayList ;
import java.util.ListIterator ;
import java.util.LinkedHashSet ;

import org.apache.xmlbeans.XmlOptions ;
import org.astrogrid.adql.beans.*; 
// import org.astrogrid.stc.beans.*; 
import org.w3c.dom.Node ;
import org.apache.xmlbeans.SchemaType;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.XmlCursor;

/** 
 * The <code>AdqlParser</code> class is the top of a hierarchy of classes that help parse ADQL queries 
 * into an intermediate XML format, or report back on any errors encountered. 
 * ADQL (the Astronomical Data Query Language) is an IVOA standard for forming astronomical queries into 
 * an SQL-like language. Given that astronomical data is held in a relational database, an ADQL query is 
 * transformed into a suitable SQL dialect for submission to the relevant RDBMS. 
 * The <code>AdqlParser</code> achieves the first part of this process, represented by the first arrow 
 * in the following diagram: 
 * <p>
 *   ADQL ---> XML ---> SQL
 * <p>
 * This first process of parsing into XML is a fundamental step required whether the process is taking place 
 * within a client or a server environment. The second process of producing SQL from the XML suitable for 
 * submission to an RDBMS is more of a server side requirement, and is achieved by another programme, 
 * of which more later.
 * <p>
 * The structure of the AdqlParser execution environment is along the following lines:
 * <blockquote><pre>
 *             AdqlParser
 *                 |
 *    +------------+------------+
 *    |                         |
 *    |                         |
 * AdqlStoX                  AST Tree
 * </pre></blockquote>
 * It represents a roughly two phase process of (i) parsing the ADQL text and (ii) building the XML output. 
 * The AdqlParser is the controlling element and indeed acts as a thick wrapper for a large amount of generated 
 * and tailored code. 
 * <p>
 * The AdqlStoX branch represents a parser generated by the JavaCC framework. There are a number of modules, 
 * although the largest and most intricate is AdqlStoX, served by a further ten subsidiary modules.
 * <p>
 * The AST (Abstract Syntax Tree) is also generated by the JavaCC framework, but is heavily hand crafted. 
 * There are nearly 90 modules in the tree.
 * <p>
 * When you ask AdqlParser to parse a query (or a fragment of a query) it delegates the parse to AdqlStoX. 
 * AdqlStoX will perform the parse and construct the AST, filling the tree with appropriate state whenever 
 * it can (ie: it will attempt to construct some AST even for queries in error provided its error recovery 
 * leaves an identifiable query structure in place). AdqlParser will then invoke the syntax tree to build the XML.
 * <p>
 * This two phase process is really forced by the desire to produce an XML structure. The detailed parsing 
 * module AdqlStoX is a top down parser, but builds the syntax tree as a bottom up process, building leaves 
 * before branches, as it were. In order to avoid a massive over use of copy semantics in producing an XML tree, 
 * AdqlParser lets the the parsing stage finish (top down), plus the complete building of the AST (bottom up), 
 * before invoking the AST from the top down to construct the XML document. 
 * <p>
 * The process of building XML uses the XMLBeans framework, another third party framework. 
 * XMLBeans are a fundamental part of the parser, both constructing the intermediate XML output and essential 
 * for conducting any semantic checking of a query. Semantic checks constitute a third phase. So...
 * <blockquote><pre>
 *  (i)   parsing the ADQL text
 *  (ii)  building the XML output
 *  (iii) conducting any semantic checks. 
 * </pre></blockquote>
 * The semantic checks are are held in routines coded within AdqlParser. 
 * <p>
 * AdqlParser supports an ADQL v2 reference implementation and an Astrogrid live implementation. 
 * Switching support between one and the other is achieved by option settings. 
 * <p>
 * The SupportOption enumeration is used to set supported options for the parser. 
 * The options are split into two sets: one set to cover the Reference Implementation for ADQL v2.0, 
 * and one set to cover the Astrogrid live version. There are currently twelve options in the first set 
 * and five options in the second.
 *  
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Jul 14, 2008
 * 
 */
public class AdqlParser {
	
	private static Log log = LogFactory.getLog( AdqlParser.class ) ;
	   
    private static final boolean DETAILED_DEBUG_PRINT_ENABLED = false ;
    private static final boolean DETAILED_ERROR_REPORT_ENABLED = false ;
    
	private StringBuffer logIndent = null ;
	
	/**
	 * Error message regarding duplicate table aliases.
	 */
	public static final String DUPLICATE_TABLE_ALIAS =
	     "Duplicated table alias: " ;
	
	/**
	 * Error message regarding duplicate aliases (table or otherwise).
	 */
	public static final String TABLE_ALIAS_CLASH =
	     "Alias with same name as a table: " ;
	
	/**
	 * Error message regarding unknown table or table alias.
	 */
	public static final String NONEXISTENT_ALIAS =
	     "Column reference with unknown table or table alias: " ;
	
	/**
	 * Error message regarding a duplicated expression alias.
	 */
	public static final String DUPLICATE_EXPRESSION_ALIAS =
	     "Duplicated expression alias: " ;
	
    /**
     * Error message regarding an expression alias and a table alias which happen to be the same.
     */
    public static final String EXPRESSION_ALIAS_CLASH_WITH_TABLE =
         "Expression alias with same name or alias as a table: " ;
    
	/**
	 * Error message regarding parsing a fragment of ADQL. The passed context was
	 * not identified as a recognised fragment of ADQL,
	 */
	public static final String UNRECOGNIZED_FRAGMENT =
	     "Unrecognized fragment of ADQL: " ;
	
	/**
	 * Error message regarding extra characters found beyond the end of the query.
	 */
	public static final String UNEXPECTED_REMAINDER =     
	     "Unexpected remaining characters found: " ;
	
    /**
     * Error message regarding the use of an unknown table.
     */
    public static final String UNKNOWN_TABLE =
         "Unknown table: " ;
    
    /**
     * Error message regarding the use of an unknown column.
     */
    public static final String COLUMN_NOT_KNOWN_IN_THIS_TABLE =
        "Column not known in this table: " ;
    
    /**
     * Error message regarding premature end of query whilst still
     * in the SELECT list.
     */
    public static final String PREMATURE_EOF_WHILST_IN_SELECTION_LIST =
        "premature end of query whilst searching selection list." ;
    
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String SELECT_ELEMENT = "Select" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
    public static final String QUERYEXPRESSION_ELEMENT = "QueryExpression" ;
    /**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ALLOW_ELEMENT = "Allow" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String RESTRICT_ELEMENT = "Restrict" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String SELECTION_LIST_ELEMENT = "SelectionList" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String FROM_ELEMENT = "From" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String WHERE_ELEMENT = "Where" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String GROUPBY_ELEMENT = "GroupBy" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String HAVING_ELEMENT = "Having" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ORDERBY_ELEMENT = "OrderBy" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String COLUMN_ELEMENT = "Column" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ITEM_ELEMENT = "Item" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String SET_ELEMENT = "Set" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
    public static final String INVALUELIST_ELEMENT = "InValueList" ;
    /**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String CONDITION_ELEMENT = "Condition" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String TABLE_ELEMENT = "Table" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ARG_ELEMENT = "Arg" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String PATTERN_ELEMENT = "Pattern" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String EXPRESSION_ELEMENT = "Expression" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ORDER_ELEMENT = "Order" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String FROM_TABLE_TYPE_ELEMENT = "fromTableType" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String TABLES_ELEMENT = "Tables" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String LITERAL_ELEMENT = "Literal" ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
    public static final String JOINSPECIFICATION_ELEMENT = "JoinSpecification" ;
    /**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
    public static final String AGGREGATE_FUNCTION_TYPE = AggregateFunctionType.type.getShortJavaName() ;
    /**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String INCLUSIVE_SEARCH_TYPE = InclusiveSearchType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String EXCLUSIVE_SEARCH_TYPE = ExclusiveSearchType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ORDER_TYPE = OrderType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ORDER_OPTION_TYPE = OrderOptionType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String TABLE_TYPE = TableType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String JOIN_TABLE_TYPE = JoinTableType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ARRAY_OF_FROM_TABLE_TYPE = ArrayOfFromTableType.type.getShortJavaName() ;
	/**
	 * Fragment context used in parsing a fragment.
	 * @see org.astrogrid.adql.AdqlParser#parseFragmentToXmlBean(String)
	 */
	public static final String ALIAS_SELECTION_ITEM_TYPE = AliasSelectionItemType.type.getShortJavaName() ;
        
	
    /**
     * Suitable array of token kinds for skipping passed an error encountered in a SELECT clause
     */
    public static final int[] SELECTION_LIST_SKIP_TO = { 
    	AdqlStoXConstants.FROM, 
    	AdqlStoXConstants.WHERE,
    	AdqlStoXConstants.GROUPBY,
    	AdqlStoXConstants.HAVING,
    	AdqlStoXConstants.ORDERBY,
        AdqlStoXConstants.SELECT    
    } ;
		
    /**
     * Suitable array of token kinds for skipping passed an error encountered in a WHERE clause
     */
    public static final int[] WHERE_SKIP_TO = { 
    	AdqlStoXConstants.GROUPBY,
    	AdqlStoXConstants.HAVING,
    	AdqlStoXConstants.ORDERBY,
        AdqlStoXConstants.SELECT
    } ;
    
    /**
     * Suitable array of token kinds for skipping passed an error encountered in a FROM clause
     */
    public static final int[] FROM_SKIP_TO = { 
    	AdqlStoXConstants.WHERE,
    	AdqlStoXConstants.GROUPBY,
    	AdqlStoXConstants.HAVING,
    	AdqlStoXConstants.ORDERBY,
        AdqlStoXConstants.SELECT
    } ;
    
    /**
     * Suitable array of token kinds for skipping passed an error encountered in a reference to
     * a table.
     */
    public static final int[] TABLE_REF_SKIP_TO = { 
     	AdqlStoXConstants.COMMA,
    	AdqlStoXConstants.WHERE,
    	AdqlStoXConstants.GROUPBY,
    	AdqlStoXConstants.HAVING,
    	AdqlStoXConstants.ORDERBY,
        AdqlStoXConstants.SELECT
    } ;
         
     private int prettyPrintIndent = 2 ;
     private ArrayList<XmlObject> tableReferences = new ArrayList<XmlObject>() ;
     private ArrayList<XmlObject> columnReferences = new ArrayList<XmlObject>() ;
     private ArrayList<XmlObject> aliasSelections = new ArrayList<XmlObject>() ;    

    /**
     * Enables different areas of syntax checking to be turned off/on at runtime,
     * Provides a somewhat more flexible approach to extending the ADQL syntax.
     */
    public enum SyntaxOption {
        
         /**
         * Bit setting for switching nested join on/off.
         * The following is an example of a nested joing.
         * <blockquote><pre>
         * SELECT * FROM TABA 
         *               INNER JOIN TABB ON TABA.COL1 = TABB.COL1
         *               INNER JOIN TABC ON TABA.COL2 = TABC.COL2 ;
         * </pre></blockquote>               
         */
         NESTED_JOIN            ( 0x00000001 ),
         
         /**
         * Bit setting for switching lax schema on/off.
         * The following shows lax schema on.
         * <blockquote><pre>
         * SELECT * FROM CAT..TABA ;
         * </pre></blockquote>
         */
         LAX_SCHEMA             ( 0x00000002 ),
         
         /**
         * Bit setting for function ownership.
         * <blockquote><pre>
         * SELECT * FROM TABA a WHERE dbo.fPhotoFlags('NOPETRO') = 0x0050 ;
         * </pre></blockquote> 
         */
         FUNCTION_OWNERSHIP     ( 0x00000004 ),
         
         
         /**
         * Bit setting for support of bit manipulation.
         * <blockquote><pre>
         * SELECT * FROM TABA a WHERE a.col1 & a.col2 = 0x0050 ;
         * </pre></blockquote> 
         */
        BITWISE_MANIPULATION   ( 0x00000008 ),
        
         /**
         * Bit setting for support of multiple comment types.
         * <blockquote><pre>
         * -- This is the standard comment type.
         * // This is a C++ style comment.
         * The standard C style comment delineated by slash asterisk is also supported
         * </pre></blockquote> 
         */
        MULTIPLE_COMMENT_TYPES ( 0x00000010 ), 
              
         /**
         * Bit setting for support of qualified sort keys.
         * 
         */
        QUALIFIED_SORT_KEYS    ( 0x00000020 ),
         
         /**
         * Bit setting for support of BOX region
         */
        BOX                    ( 0x00010000 ),
        
         /**
         * Bit setting for support of CENTROID function.
         */
        CENTROID               ( 0x00020000 ),
        
         /**
         * Bit setting for support of CIRCLE region.
         */
        CIRCLE                 ( 0x00040000 ),
        
         POINT                  ( 0x00080000 ),
         
         /**
          * Bit setting for support of POLYGON region.
          */
         POLYGON                ( 0x00100000 ),
         
         /**
          * Bit setting for support of STC REGION function.
          */
         REGION                 ( 0x00200000 ),
         
         /**
          * Bit setting for support of region-based CONTAINS predicate function.
          */
         CONTAINS               ( 0x00400000 ),
         
         /**
          * Bit setting for support of region-based INTERSECTS predicate function.
          */
         INTERSECTS             ( 0x00800000 ),
         
         /**
          * Bit setting for support of AREA function.
          */
         AREA                   ( 0x01000000 ),
         
         /**
          * Bit setting for support of coordinate extraction function.
          */
         COORD                  ( 0x02000000 ),
         
         /**
          * Bit setting for support of DISTANCE utility function.
          */
         DISTANCE               ( 0x04000000 ),
         
         /**
          * Bit setting for support of coordinate system extraction function.
          */
         COORDSYS               ( 0x08000000 ) ;
         
         private long setting ;
         
         SyntaxOption( long setting ) {
             this.setting = setting ;
         }
         
     } ;
     
     /**
     * Array of support options which covers complete support of the region syntax.
     */
    public static final SyntaxOption[] FULL_REGION_SUPPORT = {
         SyntaxOption.BOX, 
         SyntaxOption.CENTROID, 
         SyntaxOption.CIRCLE,
         SyntaxOption.POINT, 
         SyntaxOption.POLYGON, 
         SyntaxOption.REGION, 
         SyntaxOption.CONTAINS, 
         SyntaxOption.INTERSECTS, 
         SyntaxOption.AREA ,
         SyntaxOption.COORD,
         SyntaxOption.DISTANCE,
         SyntaxOption.COORDSYS  
     };
     
     /**
     * Array of support options which covers ADQL version 2.0 support.
     * This is simply a synonym for FULL_REGION_SUPPORT.
     */
     public static final SyntaxOption[] V20 = FULL_REGION_SUPPORT ;
     
     /**
      * Array of support options which covers only that part of version 2.0
      * syntax support offered by AstroGrid.
      */
     public static final SyntaxOption[] V20_AG = {
         SyntaxOption.MULTIPLE_COMMENT_TYPES
     };
     
     /**
      * Array of support options which covers that part of version 2.0
      * syntax support offered by AstroGrid plus a number of extensions
      * to the language. The extensions are:
      * NESTED_JOIN, LAX_SCHEMA, FUNCTION_OWNERSHIP, BITWISE_MANIPULATION,
      * MULTIPLE_COMMENT_TYPES, AND QUALIFIED_SORT_KEYS.
      */
     public static final SyntaxOption[] V20_AGX = {
         SyntaxOption.NESTED_JOIN,
         SyntaxOption.LAX_SCHEMA,
         SyntaxOption.FUNCTION_OWNERSHIP,
         SyntaxOption.BITWISE_MANIPULATION,
         SyntaxOption.MULTIPLE_COMMENT_TYPES,
         SyntaxOption.QUALIFIED_SORT_KEYS
     };
     
     /**
      * Array of support options which covers full support for ADQL version 2.0
      * syntax plus a number of extensions to the language. The extensions are:
      * NESTED_JOIN, LAX_SCHEMA, FUNCTION_OWNERSHIP, BITWISE_MANIPULATION,
      * MULTIPLE_COMMENT_TYPES, AND QUALIFIED_SORT_KEYS.
      */
     public static final SyntaxOption[] V20_X = {
         SyntaxOption.NESTED_JOIN,
         SyntaxOption.LAX_SCHEMA,
         SyntaxOption.FUNCTION_OWNERSHIP,
         SyntaxOption.BITWISE_MANIPULATION,
         SyntaxOption.MULTIPLE_COMMENT_TYPES,
         SyntaxOption.QUALIFIED_SORT_KEYS,
         
         SyntaxOption.BOX, 
         SyntaxOption.CENTROID, 
         SyntaxOption.CIRCLE,
         SyntaxOption.POINT, 
         SyntaxOption.POLYGON, 
         SyntaxOption.REGION, 
         SyntaxOption.CONTAINS, 
         SyntaxOption.INTERSECTS, 
         SyntaxOption.AREA ,
         SyntaxOption.COORD,
         SyntaxOption.DISTANCE,
         SyntaxOption.COORDSYS  
     } ;
     
     private long syntaxSettings = 0  ;
     
     private boolean debugIdentifiers = false ;
     
    
     /**
      * Enables the parser to be run from the command line, though a script
      * will probably make it easier. In this mode, you can...
      * <p>
      * (1) use a pipe to pass a complete query, or <br/>
      * (2) pass a file path to a query as the first argument, or <br/>
      * (3) pass a complete query as the first argument. <br/>
      * <p>
      * The input must be an ADQL/s query passed in one of the above ways.
      * The output is either a query parsed in xml (ADQL/x) in pretty print
      * to stdout or error messages to stderr.
      * <p>
      * A suitable script, which obeys the following pseudo code,
      * should come with the distribution.
      * <blockquote><pre>
      * Establish CLASSPATH to resolve dependencies<br/>
      * 
      * If number of args > 0
      *    java org.astrogrid.adql.AdqlParser args
      * Else
      *    java org.astrogrid.adql.AdqlParser
      * </pre></blockquote>   
      * This mode is not intended as an interactive conversation. If this is 
      * desired, see org.astrogrid.adql.Interactive
      * 
      */
     public static void main( String args[] ) {
                            
         if( args.length > 1 ) {
             System.err.println( "Too many input arguments." ) ;
         }
         else {
             String query ;
             AdqlParser parser = null ;
             if( args.length == 0 ) {
                 System.err.println( "No input argument. Trying stdin." ) ;
                 query = getQueryFromStdin() ;
                 StringReader reader = new StringReader( query ) ;
                 parser = new AdqlParser( reader ) ;
             } 
             else {
                 query = args[0].trim() ; 
                 parser = getFileBasedparser( query ) ; 
                 if( parser == null && query.substring(0,6).equalsIgnoreCase( "SELECT" ) ) {
                     parser = new AdqlParser( new StringReader( query ) ) ;
                 }                
             }
             
             if( parser == null ) {
                 System.err.println( "Cannot resolve input argument either to a file or a query." ) ;
             }
             else {
                 try {
                     System.out.println( parser.parseToXmlText() + '\n' ) ;
                 }
                 catch( AdqlException aex ) {
                     System.err.println( "Following errors reported: " ) ;
                     String[] messages = aex.getErrorMessages() ;
                     for( int i=0; i<messages.length; i++ ) {
                         System.err.println( messages[i] ) ;
                     }
                 }
                 catch( Exception ex ) {
                     System.err.println( "Possible internal parser error: " ) ;
                     ex.printStackTrace( System.err ) ;
                 }
             }
                      
         }
         
     } // end main( String[] )
     
     
     private static AdqlParser getFileBasedparser( String path ) {
         AdqlParser parser = null ;
         try {
             parser = new AdqlParser( new FileReader( new File( path ) ) ) ;
         }
         catch( FileNotFoundException fnfex ) {
             ; 
         }
         return parser ;
     }
     
     private static String getQueryFromStdin() {
         StringBuffer buffer = new StringBuffer( 1024 ) ;
         try {
             int ch = System.in.read() ;
             while( ch != -1 ) {
                 buffer.append( (char)ch ) ;
                 if( ch == ';' )
                     break ;
                 ch = System.in.read() ;
             }
             if( buffer.charAt(  buffer.length()-1 ) != ';' ) {
                 buffer.append( ';' ) ;
             }
         }
         catch( Exception iox ) {
             System.err.println( "Error reading stdin: \n" + iox.getLocalizedMessage() ) ;
         }        
         return buffer.toString() ;
     }
     
     private String defaultUserDefinedFunctionPrefix = "udf_" ;

          
     /**
     * Generates a new instance of a parser with the source of the ADQL query presented as an InputStream.
     *  
     * @param stream
     */
    public AdqlParser( java.io.InputStream stream ) {
         this.adqlstox = new AdqlStoX( stream ) ;
         setSyntaxToDefaultSettings() ;
         initParserFields() ;
     }
     
     /**
     * Generates a new instance of a parser with the source of the ADQL query presented as an InputStream
     * with the given encoding.
     * 
     * @param stream
     * @param encoding
     */
    public AdqlParser( java.io.InputStream stream, String encoding ) {
         this.adqlstox = new AdqlStoX( stream, encoding ) ;
         setSyntaxToDefaultSettings() ;
         initParserFields() ;
     }
     
     /**
     * Generates a new instance of a parser with the source of the ADQL query presented as a Reader.
     * 
     * @param The Reader that will provide the query.
     */
    public AdqlParser( java.io.Reader stream ) {
         this.adqlstox = new AdqlStoX( stream ) ;
         setSyntaxToDefaultSettings() ;
         initParserFields() ;
     }
     
     /**
     * Generates a new instance of a parser with the source of the ADQL query presented as a AdqlStoXTokenManager.
     * 
     * @param tm The AdqlStoXTokenManager
     */
    public AdqlParser( AdqlStoXTokenManager tm ) {
         this.adqlstox = new AdqlStoX( tm ) ;
         setSyntaxToDefaultSettings() ;
         initParserFields() ;
     }
     
    
     /**
     * Reinitializes an existing parser with the source of the ADQL query presented as an InputStream.
     * 
     * @param stream The InputStream that will provide the query.
     */
    public void ReInit( java.io.InputStream stream ) {
         ReInit( stream, null ) ;
      }
         
     /**
     * Reinitializes an existing parser with the source of the ADQL query presented as an InputStream
     * within the given encoding.
     * 
     * @param stream
     * @param encoding
     */
    public void ReInit( java.io.InputStream stream, String encoding ) {
         this.resetIndent() ;
         this.adqlstox.ReInit( stream, encoding ) ; 
         initCollections();
         initParserFields() ;
     }

    /**
     * Reinitializes an existing parser with the source of the ADQL query presented as a Reader.
     * 
     * @param stream The Reader that will provide the query.
     */
     public void ReInit( java.io.Reader stream ) {
         this.resetIndent() ;
         this.adqlstox.ReInit( stream ) ;
         initCollections();
         initParserFields() ;
     }
     
     /**
      * Reinitializes an existing parser with the source of the ADQL query presented as an AdqlStoXTokenManager.
      * 
      * @param tm The AdqlStoXTokenManager
      */
     public void ReInit(AdqlStoXTokenManager tm) {
         this.resetIndent() ;
         this.adqlstox.ReInit( tm ) ;
         initCollections();
         initParserFields() ;
     }
     
     /**
     * Sets a parser's syntax support to the default settings, which is currently
     * at the level of ADQL version 2.0.
     */
    public void setSyntaxToDefaultSettings() {
        this.syntaxSettings = 0;
        this.setSyntax( V20 ) ;
     }
     
     private void initCollections() {
         if( this.aliasSelections != null ) {
             this.aliasSelections.clear() ;
         }
         if( this.columnReferences != null ) {
             this.columnReferences.clear() ;
         }
         if( this.tableReferences != null ) {
             this.tableReferences.clear() ;
         }
         if( this.reservedWordsEncountered != null ) {
             this.reservedWordsEncountered.clear();
         }
     }
     
     private void initParserFields() {
         if( adqlstox.parser == null ) {
             adqlstox.parser = this ;
         }
         if( adqlstox.tracker == null ) {
             adqlstox.tracker = new Tracker() ;
             if( log.isTraceEnabled() ) {
                 adqlstox.tracker.setTraceBufferEnabled( true ) ;
             }
         }
         else {
             adqlstox.tracker.Reinit() ;
             if( log.isTraceEnabled() ) {
                 adqlstox.tracker.flushTraceBuffer() ;
             }
         }   
     }
    
    /**
     * The generated JavaCC parser for which AdqlParser is the wrapper.
     */
    protected AdqlStoX adqlstox ;
    
	private StringBuffer uBuffer = new StringBuffer() ;    
    private boolean semanticProcessing = false ;
    private MetadataQuery metadataQuery = null ;
    
	/**
     * This is the principle method for parsing complete queries.
     * 
	 * @return SelectDocument. An XMLBeans representation of a complete query.
	 * @throws AdqlException if an error has been detected.
	 */
	public SelectDocument exec() throws AdqlException {
        if( log.isTraceEnabled() ) enterTrace( "exec()" ) ; 
        SelectDocument selectDoc = SelectDocument.Factory.newInstance() ; 
		try {           
			adqlstox.query_specification_A() ;
            if( adqlstox.tracker.isTraceBufferEnabled() ) {
                adqlstox.tracker.writeTraceBuffer() ;
            }
			checkForRemainingSource() ;	
            AST_Select selectNode = (AST_Select)adqlstox.jjtree.rootNode() ;
            selectNode.buildXmlTree( selectDoc.addNewSelect() ) ;
            checkForTrailingComment( selectDoc ) ;     
            if( selectNode.isCommentPresent() ) {
                selectNode.writeComment( selectDoc ) ;
            }
			if( DETAILED_DEBUG_PRINT_ENABLED ) {
				XmlOptions opts = getSaveOptions( true ) ; ;
                              
                // Create an error listener.
                ArrayList errorList = new ArrayList() ;
                opts.setErrorListener( errorList ) ;
                
                // Validate the XML.
                boolean isValid = selectDoc.validate(opts);
                
                log.debug( "selectDoc validity is " + isValid 
                         + "\nCompilation before cross validation produced...\n" 
				         + selectDoc.xmlText(opts) ) ;
			}
            if( isSemanticProcessing() ) {
                HashMap<String, XmlObject> tables = checkAliases() ;
                checkColumnReferences( tables) ;
                if( metadataQuery != null ) {
                     HashMap<String, XmlObject> tables2 = checkTablesForExistence() ;
                     checkColumnsForExistence( tables2 ) ;
                }
            } 
			if( adqlstox.tracker.numberOfErrors() > 0 ) {
                generatePossibleReservedWordHints() ;
	    		throw new AdqlException( adqlstox.tracker ) ;
	    	}
			return selectDoc ;
		} 
		catch ( ParseException pex ) {
            generatePossibleReservedWordHints() ;
			adqlstox.tracker.setError( pex ) ;
	    	throw new AdqlException( adqlstox.tracker ) ;
		} 
		finally {
			if( log.isDebugEnabled() ) {
//                if( parser.tracker.numberOfErrors() > 0 ) {
//                    log.debug( "First token: " + ((AST_Select)parser.jjtree.rootNode()).getFirstToken().image ) ;
//                }
                logReportOnErrors( selectDoc ) ;                
			}
            
            if( log.isTraceEnabled() ) exitTrace( "exec()" ) ;
		}
	} 
    
    private void generatePossibleReservedWordHints() {
        if( reservedWordsEncountered.size() > 0 ) {
            StringBuffer b = new StringBuffer() ;
            b.append( "Possible incorrect use of reserved word(s): " ) ;
            Iterator<String> it = reservedWordsEncountered.iterator() ;
            while( it.hasNext() ) {
                b.append( (String) it.next() ) ;
                if( it.hasNext() ) {
                    b.append( ", " ) ;
                }
                else {
                    b.append('.') ;
                }           
            }
            b.append( " Try enclosing within double quotes." ) ;  
            this.adqlstox.tracker.setWarningMessage( b.toString() ) ;
        }    
    }
    
    /**
     * Returns the <code>XmlOptions</code> required to produce
     * a text representation of the emitted XML.
     * If <code>prettyPrint</code> is true, the text will be
     * indented according to the <code>prettyPrintIndent</code> setting.
     * 
     * @param prettyPrint
     * @return XmlOptions
     */
    public XmlOptions getSaveOptions( boolean prettyPrint ) {
        XmlOptions opts = new XmlOptions();
        opts.setSaveOuter() ;
//        opts.setSaveImplicitNamespaces( ImplicitNamespaces ) ;
        opts.setSaveNamespacesFirst() ;
        opts.setSaveAggressiveNamespaces() ;
        if( prettyPrint ) {     
           opts.setSavePrettyPrint() ;
           opts.setSavePrettyPrintIndent( prettyPrintIndent ) ; 
        }
        return opts ;
    }
	
	private void logReportOnErrors( XmlObject xmlObject ) {
        if( DETAILED_ERROR_REPORT_ENABLED ) {
        	 ArrayList list = adqlstox.tracker.getErrors() ;
    	     if( list.size() > 0 ) {
    	     	 StringBuffer buffer = new StringBuffer() ;
    	     	 buffer.append( "Errors encountered..." ) ;
                 Iterator it = list.listIterator() ;	                 
                 int i = 1 ;
                 while( it.hasNext() ) {
                      Tracker.Error e = (Tracker.Error)it.next() ;
                      buffer
                         .append( "\nError No " )
                         .append( i )
                         .append( ":\n   " ) 
                         .append( e.getShortMessage() ) 
                         .append( "\nat position:\n   " ) 
                         .append( e.toPosition() ) ;
                      i++ ;
                 }
                 log.debug( buffer.toString() ) ;
    	     }
             if( xmlObject != null ) {
                 XmlOptions opts = getSaveOptions( true ) ;
                    log.debug( "Compilation produced: " 
                             + xmlObject.xmlText(opts) ) ;
             }
        }	
	}

	
	/**
     * Parses a complete query into a SelectDocument XMLBean.
     *  
	 * @return the query as a SelectDocument
	 * @throws AdqlException
	 */
	public SelectDocument parseToXmlBeans() throws AdqlException { 
		return exec() ;
	}
	
	/**
     * Parses a complete query into XML Text. The text is pretty printed
     * if the input parameter is set to true.
     * 
	 * @param prettyPrint A boolean for requesting pretty print.
	 * @return XML text.
	 * @throws AdqlException if the parse fails.
	 */
	public String parseToXmlText( boolean prettyPrint ) throws AdqlException {
        XmlOptions opts = getSaveOptions( prettyPrint ) ;
		return exec().xmlText(opts) ; 
	}
	
	/**
     * Parses a complete query into XML text formatted for pretty print.
     * 
	 * @return Pretty print text.
	 * @throws AdqlException if the parse fails.
	 */
	public String parseToXmlText() throws AdqlException {
		return parseToXmlText( true ) ;
	}
	
	/**
     * Parses a complete query into a DOM Node.
     * 
	 * @return a DOM Node
	 * @throws AdqlException if the parse fails.
	 */
	public Node parseToXmlDom() throws AdqlException {
		return exec().getDomNode() ;
	}
	
	/**
     * Parses a fragment of a query into XML text. The text can be 
     * requested as pretty printed.
     * 
	 * @param contextPath of the query fragment
	 * @param prettyPrint boolean requesting pretty print indentation.
	 * @return the XML text.
	 * @throws AdqlException if the parser fails.
	 */
	public String parseFragmentToXmlText( String contextPath
	                                      , boolean prettyPrint ) throws AdqlException {
        XmlOptions opts = getSaveOptions( prettyPrint ) ;
		return execFragment( contextPath ).xmlText(opts) ; 
	}
	
	/**
     * Parses a fragment of a query into XML text formatted with pretty print 
     * indentation.
     * 
	 * @param contextPath of the query fragment
	 * @return the pretty printed XML text.
	 * @throws AdqlException if the parser fails.
	 */
	public String parseFragmentToXmlText( String contextPath ) throws AdqlException {
		return parseFragmentToXmlText( contextPath, true ) ; 
	}
	
	/**
     * Parses a query fragment into a suitable XMLBean, or throws an exception.
     *  
	 * @param contextPath
	 * @return A suitable XmlObject.
	 * @throws AdqlException if the parse fails.
	 */
	public XmlObject parseFragmentToXmlBean( String contextPath ) throws AdqlException {
		return execFragment( contextPath ) ;
	}
      
    /**
     * Parses a query fragment into a suitable XMLBean, or throws an exception.
     * It will return any header or trailer comments into the passed array.
     * This method is probably only of use within a GUI environment where
     * the SELECT clause itself is treated as a fragment.
     * <p/>
     * Here are examples of header and trailer comments:
     * <blockquote><pre>
     * -- This is a header comment
     * SELECT * FROM "FIRST" 
     * -- This is a trailer comment
     * </pre></blockquote>  
     * 
     * @param contextPath
     * @param headerAndTrailerComments An input/output parameter
     * @return A suitable XmlObject.
     * @throws AdqlException if the parse fails.
     */
    public XmlObject execFragment( String contextPath, String[] headerAndTrailerComments ) throws AdqlException {
        if( log.isTraceEnabled() ) enterTrace( "execFragment(String, String[] )" ) ;
        XmlObject xo = execFragment( contextPath ) ;
        if( headerAndTrailerComments != null ) {
            if( headerAndTrailerComments.length >= 2 ) {
                if( ((SimpleNode)adqlstox.jjtree.rootNode()).isCommentPresent() ) {
                    headerAndTrailerComments[0] = ((SimpleNode)adqlstox.jjtree.rootNode()).firstToken.specialToken.image ;                   
                }
                String trailingComment = getTrailingComment() ;
                if( trailingComment != null ) 
                    headerAndTrailerComments[1] = trailingComment ;
            } 
        }
        if( log.isTraceEnabled() ) exitTrace( "execFragment(String, String[] )" ) ;
        return xo ;       
    }
    
    /**
     * Writes header and trailer comments into an existing parsed query.
     * The comments are written in front of and behind the passed child object.
     * The parent object is required to achieve this process.
     * 
     * @param parent The parent of the child within the existing parsed query.
     * @param child  The child object around which the comments will be placed.
     * @param comments The array of header and trailer comments.
     */
    public void writeHeaderAndTrailerComments( XmlObject parent, XmlObject child, String[] comments ) {
        if( log.isTraceEnabled() ) enterTrace( "writeHeaderAndTrailerComments()" ) ;
            XmlCursor cursor = null ;
            XmlObject xo = null ;
            try {
                if( comments == null ) {
                    return ;
                }
                if( comments.length != 2) {
                    return ;
                }
                cursor = parent.newCursor() ;
                cursor.toFirstChild() ;
                do {
                    
                    if( cursor.isStart() ) {
                        xo = cursor.getObject() ;
                        if( xo == child ) {
                            if( comments[0] != null ) {
                                if( comments[0].length() > 0 ) {
                                    cursor.insertComment( prepareComment( comments[0] ) ) ; 
                                }
                            }                            
                            cursor.toEndToken() ;
                            cursor.toNextToken() ;
                            if( cursor.isStart() || cursor.isEnddoc() ) {
                                if( comments[1] != null ) {
                                    if( comments[1].length() > 0 ) {
                                        cursor.insertComment( prepareComment( comments[1] ) ) ;
                                    }
                                }  
                                
                            }
                            break ;
                        }
                    }
                } while( cursor.toNextToken() != XmlCursor.TokenType.NONE ) ; 
            
            }
            catch( Exception ex ) {
                log.debug( "Problem encountered whilst writing a comment.", ex ) ;
            }
            finally {
                if( cursor != null )
                    cursor.dispose();
                if( log.isTraceEnabled() ) exitTrace( "writeHeaderAndTrailerComments()" ) ;
            }

    }
	

    /**
     * This is the principle method for parsing a fraction of a query. It is 
     * probably only of use within a GUI environment.
     * <p/>
     * The parser has already been primed to accept query input (eg: a Reader).
     * This method takes a contextPath in order to prime the parser as to where to
     * begin the query parsing. For example. the following fragment:
     * <br/>
     * WHERE A.ERROR IS BETWEEN 0.023 AND 0.0235
     * <br/>
     * would need the context path:
     * <br/>
     * SELECT/WHERE
     * <br/>
     * Context paths are XPath like, but are needed only to the point of eliminating
     * ambiguity. Generally speaking, a parent and child relationship is sufficient.
     * Sometimes a type attribute is required.
     * 
     * @param contextPath
     * @return An XmlObject representing the fraction compiled.
     * @throws AdqlException
     */
    public XmlObject execFragment( String contextPath ) throws AdqlException {
        if( log.isTraceEnabled() ) enterTrace( "execFragment(String contextPath)" ) ;
		try {		
		    ContextPath cp = new ContextPath( contextPath ) ;
		    ContextPath.Element child = cp.getChild() ;
		    String childName = child.getName() ;
			ContextPath.Element parent = null ;
			String parentName = null ;
			
			if( log.isDebugEnabled() ) {
			   log.debug( "cp.getChild().getName(): " + cp.getChild().getName() ) ;
			   log.debug( "cp.getChild().getType(): " + cp.getChild().getType() ) ;
			   log.debug( "cp.getParent().getName(): " + cp.getParent().getName() ) ;
			   log.debug( "cp.getParent().getType(): " + cp.getParent().getType() ) ;
			}
		
//. <xs:element name="Select" type="tns:selectType">		
		
//.	<xs:element name="Allow" type="tns:selectionOptionType" minOccurs="0"/>//.	<xs:element name="Restrict" type="tns:selectionLimitType" minOccurs="0"/>//.	<xs:element name="SelectionList" type="tns:selectionListType"/>//	<xs:element name="InTo" type="tns:intoType" minOccurs="0"/>//.	<xs:element name="From" type="tns:fromType" minOccurs="0"/>//.	<xs:element name="Where" type="tns:whereType" minOccurs="0"/>//.	<xs:element name="GroupBy" type="tns:groupByType" minOccurs="0"/>//.	<xs:element name="Having" type="tns:havingType" minOccurs="0"/>//.	<xs:element name="OrderBy" type="tns:orderExpressionType" minOccurs="0"/>//	<xs:element name="StartComment" type="xs:string" minOccurs="0"/>//	<xs:element name="EndComment" type="xs:string" minOccurs="0"/>

//. <xs:element name="Condition" type="tns:searchType" minOccurs="2" maxOccurs="2"/>
//. <xs:element name="Column" type="tns:columnReferenceType" maxOccurs="unbounded"/>

//.	<xs:element name="Item" type="tns:orderType" maxOccurs="unbounded"/>
//. <xs:element name="Item" type="tns:literalType" maxOccurs="unbounded"/>
//. <xs:element name="Item" type="tns:selectionItemType" maxOccurs="unbounded"/>

//. <xs:element name="Arg" type="tns:scalarExpressionType"/>
//. <xs:element name="Arg" type="tns:selectionItemType" minOccurs="0" maxOccurs="unbounded"/>

//.?  <xs:element name="Literal" type="tns:literalType"/>
// Do we support units in the current version?...
//?	<xs:element name="Unit" type="xs:string" minOccurs="0"/>

//. <xs:element name="Expression" type="tns:scalarExpressionType"/>
				
// These 3 from xMatch:
// <xs:element name="Table" type="tns:xMatchTableAliasType" minOccurs="2" maxOccurs="unbounded"/>
// <xs:element name="Nature" type="tns:comparisonType"/>
// <xs:element name="Sigma" type="tns:numberType"/>		

//. <xs:element name="Pattern" type="tns:atomType"/>

// aliasSelectionItemType. Check. Probably not required.
//. exclusiveSearchType: NOT IN
//. orderType
//. inclusiveSearchType: IN
//. <xs:element name="Expression" type="tns:scalarExpressionType"/>

// These two probably need experimentation to distinguish between them...
// <xs:element name="Set" type="tns:inclusionSetType"/>
//. <xs:element name="selection" type="tns:selectType"/>

// <xs:element name="Region" type="reg:regionType"/>

//. <xs:element name="Table" type="tns:fromTableType" maxOccurs="unbounded"/>

// This from InTo:
// <xs:element name="TableName" type="xs:string"/>

// This from OrderBy:
//. <xs:element name="Expression" type="tns:scalarExpressionType"/>
//. <xs:element name="Order" type="tns:orderOptionType" minOccurs="0"/>

// This from user defined function:
// <xs:element name="Name" type="xs:string"/>
// <xs:element name="Params" type="tns:scalarExpressionType" minOccurs="0" maxOccurs="unbounded"/>

// This from join table:
// <xs:element name="Qualifier" type="tns:jointTableQualifierType"/>
//. <xs:element name="Tables" type="tns:ArrayOfFromTableType"/>		
//. <xs:element name="Condition" type="tns:comparisonPredType"/>
// <xs:element name="fromTableType" type="tns:fromTableType" nillable="true" maxOccurs="unbounded"/>
			// Unit test done.		
			if( childName.equalsIgnoreCase( SELECT_ELEMENT ) ) {
			    fQuerySpecification() ;
			} 
            // New for version 2 of ADQL
			else if( childName.equalsIgnoreCase( QUERYEXPRESSION_ELEMENT ) ) {
			    fQueryExpression() ;
			}
			else if( childName.equalsIgnoreCase( ALLOW_ELEMENT ) ) {
			    fSetQuantifier() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( RESTRICT_ELEMENT ) ) {
			    fSetLimit() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( SELECTION_LIST_ELEMENT ) ) {
			    fSelectionList() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( FROM_ELEMENT ) ) {
			    fFromClause() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( WHERE_ELEMENT ) ) {
			    fWhereClause() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( GROUPBY_ELEMENT ) ) {
			    fGroupBy() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( HAVING_ELEMENT ) ) {
			    fHaving() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( ORDERBY_ELEMENT ) ) {
			    fOrderBy() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( COLUMN_ELEMENT ) ) {
			    fColumnReference() ;
			}
			else if( childName.equalsIgnoreCase( ITEM_ELEMENT ) ) {
			    parentName = cp.getParent().getName() ;
			    // Unit test done.
			    if( parentName.equalsIgnoreCase( SELECTION_LIST_ELEMENT ) ) {
			        fDerivedColumn() ;
			    }
			    // Unit test done.
			    else if( parentName.equalsIgnoreCase( ORDERBY_ELEMENT ) ) {
			        fSortSpecification() ;
			    }
			    // Unit test done.
			    else if( parentName.equalsIgnoreCase( INVALUELIST_ELEMENT ) ) {
			        fInValueListExpression() ;
			    }
			}
			else if( childName.equalsIgnoreCase( JOINSPECIFICATION_ELEMENT ) ) {
			    parentName = cp.getParent().getName() ;
			    // Join table comparison ...
			    // Unit test done.
			    if( parentName.equalsIgnoreCase( TABLE_ELEMENT ) ) {
			        fJoinSpecification() ;
			    }
			}
			else if( childName.equalsIgnoreCase( ARG_ELEMENT ) ) {
			    parent = cp.getParent() ;
			    // Unit test done.
			    if( parent.getType().equalsIgnoreCase( AGGREGATE_FUNCTION_TYPE ) ) {
			        fSetFunctionSpecifictationPartFragment() ;
			    }
			    // Unit test done.
			    else {
			        fValueExpression() ;
			    }
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( PATTERN_ELEMENT ) ) {
			    fPattern() ;
			}
			// Unit test done.
			else if( childName.equalsIgnoreCase( TABLE_ELEMENT ) ) {
			    fTableReference() ;
			}
			// Adjustment made for:
			// /Select[@type='selectType']/SelectionList[@type='selectionListType']/Item[@type='aliasSelectionItemType']/Expression[@type='mathFunctionType']
			else if( childName.equalsIgnoreCase( EXPRESSION_ELEMENT ) ) {
			    parent = cp.getParent() ;
			    // Unit test done 
			    if( parent.getType().equalsIgnoreCase( INCLUSIVE_SEARCH_TYPE )
			            ||
			            // Unit test done 
			            parent.getType().equalsIgnoreCase( EXCLUSIVE_SEARCH_TYPE ) 
			            ||
			            // Unit test done.
			            parent.getType().equalsIgnoreCase( ORDER_TYPE ) 
			            ||
			            // Unit test done.
			            parent.getType().equalsIgnoreCase( ALIAS_SELECTION_ITEM_TYPE ) ) {
			        fValueExpression() ;
			    }
			    else {
			        throw new ParseException( UNRECOGNIZED_FRAGMENT + contextPath ) ;	
			    }
			}
			else if( childName.equalsIgnoreCase( ORDER_ELEMENT ) ) { 
			    // Unit test done.
			    if( child.getType().equalsIgnoreCase( ORDER_OPTION_TYPE ) ) {		  
			        fOrderingSpecification() ;
			    }
			    else {
			        parent = cp.getParent() ;
			        ContextPath.Element grandParent = cp.getElement( cp.size() - 3 ) ;
			        // Unit test done.
			        if( parent.getName().equalsIgnoreCase( ITEM_ELEMENT )
			                ||
			                grandParent.getName().equalsIgnoreCase( ORDERBY_ELEMENT ) ) {
			            fOrderingSpecification() ; 
			        }
			        else {
			            throw new ParseException( UNRECOGNIZED_FRAGMENT + contextPath ) ;	
			        }
			    }
			}
			else if( childName.equalsIgnoreCase( FROM_TABLE_TYPE_ELEMENT ) ) {
			    // Unit test done.
			    if( child.getType().equalsIgnoreCase( TABLE_TYPE ) ) {
			        fTableReferenceWithinJoinFromArray() ;
			    }
			    else {
			        throw new ParseException( UNRECOGNIZED_FRAGMENT + contextPath ) ;	
			    }
			}
			else if( childName.equalsIgnoreCase( TABLES_ELEMENT ) ) {
			    // Unit test done.
			    if( child.getType().equalsIgnoreCase( ARRAY_OF_FROM_TABLE_TYPE ) ) {
			        fJoinFromArray() ; 
			    }
			    else {
			        throw new ParseException( UNRECOGNIZED_FRAGMENT + contextPath ) ;	
			    }
			}
			else if( childName.equalsIgnoreCase( CONDITION_ELEMENT ) ) {                  
			    fSearchCondition() ;
			}
			// Unit test done.
			else {
			    throw new ParseException( UNRECOGNIZED_FRAGMENT + contextPath ) ;
			}
			checkForRemainingSource() ;

			if( adqlstox.tracker.numberOfErrors() > 0 ) {
			    throw new AdqlException( adqlstox.tracker ) ;
			}
			return (XmlObject)adqlstox.jjtree.rootNode().getGeneratedObject() ;

		}
		catch( ParseException pex ) {
		    adqlstox.tracker.setError( pex ) ;
		    throw new AdqlException( adqlstox.tracker ) ;
		}
		finally {
		    if( log.isDebugEnabled() ) {
		        try {
		            XmlObject xo = (XmlObject)adqlstox.jjtree.rootNode().getGeneratedObject() ;
		            logReportOnErrors( xo ) ;
		        }
		        catch( Throwable th ) {
		            ; // Ignore
		        }
		    }
		    if( log.isTraceEnabled() ) exitTrace( "execFragment(String contextPath)" ) ;
		}

	}
    
   private void fJoinFromArray() throws ParseException {
       adqlstox.table_array_fragment() ;
       JoinTableType joinTable = JoinTableType.Factory.newInstance() ;
       AST_TableArrayFragment tableArrayNode = (AST_TableArrayFragment)adqlstox.jjtree.rootNode() ;
       tableArrayNode.buildXmlTree( joinTable.addNewTables() ) ; 
    }
   
   private void fTableReferenceWithinJoinFromArray() throws ParseException {
       adqlstox.table_reference_A() ;     
       ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
       AST_TableReference tableNode = (AST_TableReference)adqlstox.jjtree.rootNode() ;
       tableNode.buildXmlTree(tableArray.addNewFromTableType() ) ;
   }
   
   private void fOrderingSpecification() throws ParseException {
       adqlstox.ordering_specification_S() ;
       OrderType orderType = OrderType.Factory.newInstance() ;
       AST_OrderingSpecification orderSpecNode = (AST_OrderingSpecification)adqlstox.jjtree.rootNode() ;
       orderSpecNode.buildXmlTree( orderType.addNewOrder() ) ;
   }
   
   private void fTableReference() throws ParseException {
       adqlstox.table_reference_A() ;
       FromType from = FromType.Factory.newInstance() ;
       AST_TableReference tableNode = (AST_TableReference)adqlstox.jjtree.rootNode() ;
       tableNode.buildXmlTree( from.addNewTable() ) ;
   }
    
    private void fPattern () throws ParseException {
        adqlstox.pattern_A() ;
        LikePredType lpt = LikePredType.Factory.newInstance() ;
//        AST_CharacterStringLiteral patternNode = (AST_CharacterStringLiteral)parser.jjtree.rootNode() ;
        AST_CharacterValueExpression patternNode = (AST_CharacterValueExpression)adqlstox.jjtree.rootNode() ;
        patternNode.buildXmlTree( lpt.addNewPattern() ) ;
    }
    
    private void fValueExpression() throws ParseException {
        adqlstox.value_expression_A( AdqlParser.ARG_ELEMENT ) ;
        ComparisonPredType compPred = ComparisonPredType.Factory.newInstance() ;
        AST_ValueExpression valueExpressionNode = (AST_ValueExpression)adqlstox.jjtree.rootNode() ;
        valueExpressionNode.buildXmlTree( compPred.addNewArg() ) ;
    }
    
    private void fSetFunctionSpecifictationPartFragment() throws ParseException {
        adqlstox.set_function_specification_part_fragment() ;
        ComparisonPredType compPred = ComparisonPredType.Factory.newInstance() ;
        AST_SetFunctionSpecificationPartFragment sfsNode = (AST_SetFunctionSpecificationPartFragment)adqlstox.jjtree.rootNode() ;
        sfsNode.buildXmlTree( compPred.addNewArg() ) ;
    }
    
    private void fSearchCondition() throws ParseException {
        adqlstox.search_condition_S() ;  
        WhereType where = WhereType.Factory.newInstance() ;
        AST_SearchCondition searchConditionNode = (AST_SearchCondition)adqlstox.jjtree.rootNode() ;
        searchConditionNode.buildXmlTree( where.addNewCondition() ) ;
    }
    
    private void fJoinSpecification() throws ParseException {
        adqlstox.join_specification_S() ;
        JoinTableType joinTable = JoinTableType.Factory.newInstance() ;
        AST_JoinSpecification jsNode = (AST_JoinSpecification)adqlstox.jjtree.rootNode() ;
        jsNode.buildXmlTree( joinTable.addNewJoinSpecification() ) ; 
    }
    
    private void fInValueListExpression() throws ParseException {
        adqlstox.value_expression_A( null ) ; 
        InValueListType ivlt = InValueListType.Factory.newInstance() ;
        AST_ValueExpression inValueListNode = (AST_ValueExpression)adqlstox.jjtree.rootNode() ;
        inValueListNode.buildXmlTree( ivlt.addNewItem() ) ;  
    }
    
    private void fQuerySpecification() throws ParseException {
        adqlstox.query_specification_A() ;
        checkForRemainingSource() ;
        SelectDocument selectDoc = SelectDocument.Factory.newInstance() ;
        AST_Select selectNode = (AST_Select)adqlstox.jjtree.rootNode() ;
        selectNode.buildXmlTree( selectDoc.addNewSelect() ) ;
//        XmlObject xmlObject = (XmlObject)selectNode.getGeneratedObject() ;               
        if( isSemanticProcessing() ) {
            HashMap<String, XmlObject> tables = checkAliases() ;
            checkColumnReferences( tables) ;
            if( metadataQuery != null ) {
                 HashMap<String, XmlObject> tables2 = checkTablesForExistence() ;
                 checkColumnsForExistence( tables2 ) ;
            }
        } 
    }
    
    private void fQueryExpression() throws ParseException {
        adqlstox.query_expression_A() ;
        checkForRemainingSource() ;
        AST_QueryExpression  qeNode = (AST_QueryExpression)adqlstox.jjtree.rootNode() ;
        qeNode.buildXmlTree( SubQueryType.Factory.newInstance() ) ;    
    }
    
    private void fSetQuantifier() throws ParseException {
        adqlstox.set_quantifier_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_Allow allowNode = (AST_Allow)adqlstox.jjtree.rootNode() ;
        allowNode.buildXmlTree( select.addNewAllow() ) ;     
    }
    
    private void fSetLimit() throws ParseException {
        adqlstox.set_limit_A() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_Restrict restrictNode = (AST_Restrict)adqlstox.jjtree.rootNode() ;
        restrictNode.buildXmlTree( select.addNewRestrict() ) ;  
    }
    
    private void fSelectionList() throws ParseException {
        adqlstox.select_list_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_SelectionList selectionListsNode = (AST_SelectionList)adqlstox.jjtree.rootNode() ;
        selectionListsNode.buildXmlTree( select.addNewSelectionList() ) ; 
    }
    
    private void fFromClause() throws ParseException {
        adqlstox.from_clause_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_From fromNode = (AST_From)adqlstox.jjtree.rootNode() ;
        fromNode.buildXmlTree( select.addNewFrom() ) ;  
    }
    
    private void fWhereClause() throws ParseException {
        adqlstox.where_clause_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_Where whereNode = (AST_Where)adqlstox.jjtree.rootNode() ;
        whereNode.buildXmlTree( select.addNewWhere() ) ;
    }
    
    private void fGroupBy() throws ParseException {
        adqlstox.group_by_clause_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_GroupBy groupByNode = (AST_GroupBy)adqlstox.jjtree.rootNode() ;
        groupByNode.buildXmlTree( select.addNewGroupBy() ) ; 
    }
    
    private void fHaving() throws ParseException {
        adqlstox.having_clause_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_Having havingNode = (AST_Having)adqlstox.jjtree.rootNode() ;
        havingNode.buildXmlTree( select.addNewHaving() ) ;
    }
    
    private void fOrderBy() throws ParseException {
        adqlstox.order_by_clause_S() ;
        SelectType select = SelectType.Factory.newInstance() ;
        AST_OrderByClause orderByNode = (AST_OrderByClause)adqlstox.jjtree.rootNode() ;
        orderByNode.buildXmlTree( select.addNewOrderBy() ) ;      
    }
    
    private void fSortSpecification() throws ParseException {
        adqlstox.sort_specification_A( null ) ; 
        OrderExpressionType orderExpression = OrderExpressionType.Factory.newInstance() ;
        AST_SortSpecification sortSpecNode = (AST_SortSpecification)adqlstox.jjtree.rootNode() ;
        sortSpecNode.buildXmlTree( orderExpression.addNewItem() ) ;
    }
    
    private void fColumnReference() throws ParseException {
        adqlstox.column_reference_A( "to-do" ) ;
        SelectionListType selectList = SelectionListType.Factory.newInstance() ;
        AST_ColumnReference colRefNode = (AST_ColumnReference)adqlstox.jjtree.rootNode() ;
        colRefNode.buildXmlTree( selectList.addNewItem() ) ; 
    }
    
    private void fDerivedColumn() throws ParseException {
        adqlstox.derived_column_S( AdqlParser.ITEM_ELEMENT ) ; 
        SelectionListType selectList = SelectionListType.Factory.newInstance() ;
        AST_DerivedColumn derivedColNode = (AST_DerivedColumn)adqlstox.jjtree.rootNode() ;
        derivedColNode.buildXmlTree( selectList.addNewItem() ) ; 
    }
	
	
    /**
     * Crude check of table aliases and aliased expressions
     */   
    private HashMap<String,XmlObject> checkAliases() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace( "checkTableAliases" ) ;
        HashMap<String,XmlObject> tables = new HashMap<String,XmlObject>() ;
        
        ListIterator<XmlObject> it = tableReferences.listIterator() ; 
        while( it.hasNext() ) {
            Object obj = it.next() ;
            //
            // There are normal tables and derived tables 
            // pertinent to checking aliases...
            if( obj instanceof TableType ) {

                TableType tt = (TableType)obj ;            
                //
                // Tables may be duplicated, so...
                tables.put( tt.getName(), tt ) ;
                //
                // And we allow for catalog and schema being used,
                // which may also be duplicated...
                if( tt.isSetSchema() ) {
                    tables.put( formTableQualifier( tt ), tt ) ;
                } 
                //
                // But table aliases must not be duplicated in any sense...
                if( tt.isSetAlias() ) {
                    if( tables.containsKey( tt.getAlias() ) ) {
                        String message = DUPLICATE_TABLE_ALIAS + tt.getAlias() ;
                        ParseException pex = new ParseException( message ) ;
                        adqlstox.tracker.setError( pex ) ;
                    }
                    else {
                        tables.put( tt.getAlias(), tt ) ;
                    } 
                }  
            }
            //
            // And here are the derived tables...
            else if( obj instanceof DerivedTableType ) {
                
                DerivedTableType dtt = (DerivedTableType)obj ;   
                if( tables.containsKey( dtt.getAlias() ) ) {
                    String message = DUPLICATE_TABLE_ALIAS + dtt.getAlias() ;
                    ParseException pex = new ParseException( message ) ;
                    adqlstox.tracker.setError( pex ) ;
                }
                else {
                    tables.put( dtt.getAlias(), dtt ) ;
                }         
            }
          
        }
        //
        //
        if( log.isDebugEnabled() ) {
            log.debug( "Print of tables..." ) ;
            Iterator<String> tit = tables.keySet().iterator() ;
            while( tit.hasNext() ) {
                log.debug( tit.next() ) ;
            }
        }
        
        //
        // Having formed a collection containing all tables
        // we can now check aliased expressions...
        HashSet<String> aliasedExpressionSet = new HashSet<String>() ;
        it = aliasSelections.listIterator() ;
        while( it.hasNext() ) {
            AliasSelectionItemType asit = (AliasSelectionItemType)it.next() ;            
            //
            // The alias in aliased expressions also cannot be duplicated...
            if( aliasedExpressionSet.add( asit.getAs() ) == false ) {
                String message = DUPLICATE_EXPRESSION_ALIAS + asit.getAs() ;
                ParseException pex = new ParseException( message ) ;
                adqlstox.tracker.setError( pex ) ;
            }
            
            //
            // The alias cannot be a table name or table alias...
            if( tables.containsKey( asit.getAs() ) ) {
                String message = EXPRESSION_ALIAS_CLASH_WITH_TABLE + asit.getAs() ;
                ParseException pex = new ParseException( message ) ;
                adqlstox.tracker.setError( pex ) ;
            }
        }
        
        if( log.isTraceEnabled() ) exitTrace( "checkTableAliases" ) ;
        return tables ;
    }
	
    private void checkColumnReferences( HashMap<String, XmlObject> tables ) {
        if( log.isTraceEnabled() ) enterTrace( "checkColumnReferences" ) ;
        
        ListIterator<XmlObject> iterator = columnReferences.listIterator() ;
        while( iterator.hasNext() ) {
            String qualifiedName ;
            Object obj = iterator.next() ;
            if( obj instanceof ColumnReferenceType ) {
                ColumnReferenceType crt = (ColumnReferenceType)obj ;
                if( !crt.isSetTable() )
                    continue ;
                qualifiedName = formTableQualifier( crt ) ;
                if( !tables.containsKey( qualifiedName ) ) {
                    String message = NONEXISTENT_ALIAS + qualifiedName + '.' + crt.getName() ;
                    ParseException pex = new ParseException( message ) ;
                    adqlstox.tracker.setError( pex ) ;
                }
            }
            else if( obj instanceof AllSelectionItemType ) {
                AllSelectionItemType asit = (AllSelectionItemType)obj ;
                qualifiedName = formTableQualifier( asit ) ;
                if( !tables.containsKey( qualifiedName ) ) {
                    String message = NONEXISTENT_ALIAS + qualifiedName + ".*" ;
                    ParseException pex = new ParseException( message ) ;
                    adqlstox.tracker.setError( pex ) ;
                }
            }
             
        }
        
        if( log.isTraceEnabled() ) exitTrace( "checkColumnReferences" ) ;
    }
    
    private HashMap<String, XmlObject> checkTablesForExistence() {
        if( log.isTraceEnabled() ) enterTrace( "checkTablesForExistence" ) ;
        //
        // Check that tables are indeed known tables...
        
        // Hash map to hold valid tables...
        HashMap<String, XmlObject> validTables = new HashMap<String, XmlObject>() ;
        
        ListIterator<XmlObject> it = tableReferences.listIterator() ;
        while( it.hasNext() ) { 
            Object obj = it.next() ;
            if( obj instanceof TableType ) {

                TableType tt = (TableType)obj ;
                String key = formTableQualifier( tt ) ;
                
                if( !metadataQuery.isTable( key ) ) {
                    //
                    // Table invalid...
                    adqlstox.tracker.setError( new ParseException( UNKNOWN_TABLE + key ) ) ;
                }
                else {
                    //
                    // Table valid:
                    // Add the table to the valid tables collection.
                    // This could be twice!
                    // Once for table name.
                    // Once for the table alias if it exists.
                    validTables.put( tt.getName(), tt ) ;
                    if( tt.isSetAlias() ) {
                        validTables.put( tt.getAlias(), tt ) ;
                    }
                }
            }
        }
  
        if( log.isTraceEnabled() ) exitTrace( "checkTablesForExistence" ) ;
        return validTables ;        
    }

    private void checkColumnsForExistence( HashMap<String, XmlObject> tables ) {
        if( log.isTraceEnabled() ) enterTrace( "checkColumnsForExistence" ) ;
        String tableQualifier ;
        ListIterator<XmlObject> it = columnReferences.listIterator() ;
        while( it.hasNext() ) {
            
        	XmlObject obj = it.next() ;
            if( obj instanceof AllSelectionItemType ) 
                continue ;
            ColumnReferenceType crt = (ColumnReferenceType)obj ;
           
            //
            // First check that the table the column refers to exists...
            tableQualifier = formTableQualifier( crt ) ;
             
            if( !tables.containsKey( tableQualifier ) ) {
                //
                // Table invalid...
                // We don't bother to continue. The table would already have been flagged,
                // and it is pointless to festoon the diagnostics with extra messages.
                continue ;
            }
            //
            // Ensure we get the real table name and not
            // a derived table or some alias...  
            obj = tables.get( tableQualifier ) ;
            if( obj instanceof DerivedTableType ) 
                continue ;           
            TableType tt = (TableType)obj ;
            tableQualifier = formTableQualifier( tt ) ;
            
            //
            // Now check that the column really exists in this table...
            String columnName = crt.getName() ; 
            if( !metadataQuery.isColumn( tableQualifier, columnName ) ){  
                String message ;
                //
                // Column invalid...
                if( tt.isSetAlias() ) {
                    message = COLUMN_NOT_KNOWN_IN_THIS_TABLE + tt.getAlias() + "." + columnName + " for table " + tableQualifier ;
                }
                else {
                    message = COLUMN_NOT_KNOWN_IN_THIS_TABLE + tableQualifier + "." + columnName ;
                }
                ParseException pex2 = new ParseException( message ) ;
                adqlstox.tracker.setError( pex2 ) ;                
            }  
            
        } // end while
  
        if( log.isTraceEnabled() ) exitTrace( "checkColumnsForExistence" ) ;
       
    }

    
    private boolean isEof() {
        if( adqlstox.token.kind == AdqlStoXConstants.EOF )
            return true ;
        adqlstox.getNextToken() ;
        return false ;
    }
	
	private void checkForTrailingComment( XmlObject parent ) {
	    if( log.isTraceEnabled() ) enterTrace( "checkForTrailingComment" ) ;
	    XmlCursor cursor = null ;
	    Token commentLinkedToken = null ;
	    try {

	        do  {
	            if( adqlstox.token.specialToken != null ) {
	                if( adqlstox.token.specialToken.kind == AdqlStoXConstants.COMMENT ) {
	                    commentLinkedToken = adqlstox.token ;
	                }
	            }
	        } while( isEof() == false ) ;

	        if( commentLinkedToken != null ) {

	            if( log.isDebugEnabled() ) { 
	                log.debug( "commentLinkedToken.image: \"" + commentLinkedToken.image + "\" contains comment: " + commentLinkedToken.specialToken.image ) ;   
	            }

	            cursor = parent.newCursor() ;
	            cursor.toEndToken() ;
//              String comment = commentLinkedToken.specialToken.image ;          
//              cursor.insertComment( SimpleNode.prepareComment( comment ) ) ;     
                
                Token tmpToken = commentLinkedToken.specialToken ;
                while( tmpToken.specialToken != null ) tmpToken = tmpToken.specialToken;
                  // The above line walks back the special token chain until it
                  // reaches the first special token after the previous regular
                  // token.
                while (tmpToken != null) {
                    cursor.insertComment( prepareComment( tmpToken.image ) ) ;
                  tmpToken = tmpToken.next;
                } 

	        }

	    }	    catch( Exception ex ) {	        log.debug( "Problem encountered whilst writing end comment.", ex ) ;	    }	    finally {	        if( cursor != null )	            cursor.dispose();
	        if( log.isTraceEnabled() ) exitTrace( "checkForTrailingComment" ) ;	    }	
	}
    
    private String getTrailingComment() {
        Token commentLinkedToken = null ;
    
            do  {
                if( adqlstox.token.specialToken != null ) {
                    if( adqlstox.token.specialToken.kind == AdqlStoXConstants.COMMENT ) {
                        commentLinkedToken = adqlstox.token ;
                    }
                }
            } while( isEof() == false ) ;
            
        if( commentLinkedToken != null )
            return commentLinkedToken.specialToken.image ;
        return null ;
    }
    
    boolean lookForBoolean() {
       int i = 0 ;	
       Token t;
       boolean found = false ;
       do {
           t = adqlstox.getToken(i++);
           if( t.kind == AdqlStoXConstants.OR
               ||
               t.kind == AdqlStoXConstants.AND 
               ||
               t.kind == AdqlStoXConstants.NOT ) {
               found = true ;
               break ;
           }
       } while (t.kind != AdqlStoXConstants.EOF );
       return found ;    	
    }
    
    /**
     * Crude utility function to prepare an ADQL comment for inclusion into XML.
     * In effect this strips out all ADQL comment markers (SQL, C and C++ style  ones). 
     * If a C or C++ style comment has been used but multiple comment types are not
     * supported, then a warning message is set within the tracker object.
     * 
     * @param comment to be prepared.
     * @return The comment stripped of its comment markers.
     */
    public String prepareComment( String comment ) {
        String c = comment.trim();
        if( c.startsWith( "--") ) {
            return comment.replaceAll( "--", "" ) ;
        }
        else { 

            if( isSyntaxSet( SyntaxOption.MULTIPLE_COMMENT_TYPES ) ) {
                this.adqlstox.tracker.setWarningMessage( "Multiple comment types not supported." ) ;
            }            
            if( c.startsWith( "//") ) {
                return comment.replaceAll( "//", "" ) ;
            }
            else if( c.startsWith( "/*" ) ) {
                return comment.replaceAll( "/\\*", "" ).replaceAll( "\\*/", "" ) ;
            }

        }
        return comment ;
    }
    
    
    private void checkForRemainingSource() throws ParseException {
        if( log.isTraceEnabled() ) enterTrace( "checkForRemainingSource" ) ;
        try {
            if( adqlstox.getToken(1).kind != AdqlStoXConstants.EOF ) {
                if( log.isDebugEnabled() ) {
                    log.debug( "parser.getToken(1).image: \"" + adqlstox.getToken(1).image + "\"" ) ;
                }
                ArrayList<Token> rTokens = new ArrayList<Token>() ;
                int i = 1 ;
                Token t = adqlstox.getToken(i) ;
                try {
                    while( t.kind != AdqlStoXConstants.EOF ) {
                        rTokens.add( t ) ;
                        t = adqlstox.getToken(++i) ;
                    }
                }
                catch( Exception pex ) {
                    ; // do nothing
                }
                StringBuffer buffer = new StringBuffer( 32 + (rTokens.size() * 8) ) ;
                buffer.append( UNEXPECTED_REMAINDER ) ;
                ListIterator<Token> iterator = rTokens.listIterator() ;
                while( iterator.hasNext() ) {
                    buffer.append( ((Token)iterator.next()).image ).append( ' ' ) ;
                }
                throw new ParseException( buffer.toString() ) ;
            }
        }
        finally {
            if( log.isTraceEnabled() ) exitTrace( "checkForRemainingSource" ) ;
        }
    }
 
    /**
     * Utility routine to check whether a token kind matches a given array.
     * 
     * @param kindArray
     * @param kind
     * @return true if kind is matched within the array
     */
    protected boolean matches( int[] kindArray, int kind ) {
    	for( int i=0; i < kindArray.length; i++ ) {
    		if( kind == kindArray[i] ) {
    		   if( log.isDebugEnabled() ) {
    		   	  log.debug( "Match found on token: " + kind ) ;
    		   }	
    		   return true ;	
    		}
    	}
    	log.debug( "No match found" ) ;
    	return false ;
    }
    
    
    private String arrayToString( int[] intArray ) {
    	StringBuffer buffer = new StringBuffer() ;
    	for( int i=0; i<intArray.length; i++ ) {
    		buffer.append( intArray[i] ).append( " " ) ;
    	} 
    	return buffer.toString() ; 	
    }
    
    
    private StringBuffer initUtilityBuffer( String prefix ) {
    	if( uBuffer.length() > 0 ) {
    		uBuffer.delete( 0, uBuffer.length() ) ;
    	}
    	if( prefix != null ) {
    	   uBuffer.append( prefix ) ;
    	}
    	return uBuffer ;
    }

	/**
	 * Utility routine to enter a structured message in the trace log that the given method 
	 * has been entered. Almost essential for syntax debugging.
	 * 
	 * @param entry: the name of the method entered
	 * @see        org.astrogrid.AdqlParser#exitTrace(String)
	 */
	public void enterTrace( String entry ) {
		log.trace( getIndent().toString() + "enter: " + entry ) ;
		indentPlus() ;
	}

    /**
     * Utility routine to enter a structured message in the trace log that the given method 
	 * has been exited. Almost essential for syntax debugging.
	 * 
     * @param entry: the name of the method exited
     * @see        org.astrogrid.AdqlParser#enterTrace(String)
     */
    public void exitTrace( String entry ) {
    	indentMinus() ;
		log.trace( getIndent().toString() + "exit : " + entry ) ;
	}
	
    /**
     * Utility method used to maintain the structured trace log.
     * @see        org.astrogrid.AdqlParser#indentMinus()
     */
    public void indentPlus() {
		getIndent().append( ' ' ) ;
	}
	
    /**
     * Utility method used to maintain the structured trace log.
     * @see        org.astrogrid.AdqlParser#indentPlus()
     */
    public void indentMinus() {
        if( logIndent.length() > 0 ) {
            getIndent().deleteCharAt( logIndent.length()-1 ) ;
        }
	}
	
    /**
     * Utility method used for indenting the structured trace log.
     */
    public StringBuffer getIndent() {
	    if( logIndent == null ) {
	       logIndent = new StringBuffer() ;	
	    }
	    return logIndent ;	
	}
    
    private void resetIndent() {
        if( logIndent != null ) { 
            if( logIndent.length() > 0 ) {
               logIndent.delete( 0, logIndent.length() )  ;
            }
        }   
    }
	
	/**
	 * Error "recovery" routine. Does not actually recover an encountered error,
	 * but will force the underlying AdqlStoX parser to skip over tokens until it
	 * finds one that matches <code>kindArray</code> is encountered. The parsing will
	 * then take up from a new position.
	 * 
	 * @param kindArray
	 * @return
	 */
	protected boolean errorSkipTo( int[] kindArray ) {
	    if( log.isTraceEnabled() ) enterTrace ( "errorSkipTo()" ) ;
	    try {
	        log.debug( "Syntax error around token.image: " + adqlstox.token.image
	                + "\nSkipping to one of " + arrayToString(kindArray) ) ;
	        boolean eofEncountered = false ;

	        if( !matches( kindArray, adqlstox.getToken(1).kind ) ) {
	            Token t;        
	            do {
	                t = adqlstox.getNextToken();
	                log.debug( "Token: " + t.image ) ;
	                if( t.kind == AdqlStoXConstants.EOF ) {
	                    eofEncountered = true ;
	                    break ;
	                }
	            } while ( !matches( kindArray, adqlstox.getToken(1).kind ) );

	        }	
	        return eofEncountered ;
	    }
	    finally {
	        if( log.isTraceEnabled() ) exitTrace ( "errorSkipTo()" ) ;
	    }
    }
    
	/**
	 * Error "recovery" routine. Does not actually recover an encountered error,
	 * but will force the underlying AdqlStoX parser to skip over tokens until it
	 * finds one that is not matched by any within <code>kindArray</code>. 
	 * The parsing will then take up from a new position.
	 * 
	 * @param kindArray
	 * @return
	 */
	protected void errorSkipPast( int[] kindArray, ParseException pex ) 
	{
	    if( log.isTraceEnabled() ) enterTrace ( "errorSkipPast()" ) ;	
	    log.debug( "Syntax error around token.image: " + adqlstox.token.image
	            + "\nSkipping to one of " + arrayToString( kindArray ) ) ;
	    try {
	        adqlstox.tracker.setError( pex ) ;
	        Token t;
	        while( !matches( kindArray, adqlstox.getToken(1).kind ) ) {
	            t = adqlstox.getNextToken() ;
	            if( t.kind == AdqlStoXConstants.EOF ) {
	                return ;	
	            }   	
	        }
	    }
	    finally {
	        if( log.isTraceEnabled() ) exitTrace ( "errorSkipPast()" ) ;
	    }
	}
    /**
     * Routine for matching brackets, by reading ahead until the end of the query.
     * If unmatched brackets are encountered, will raise an error in the <code>Tracker</code>.
     * 
     * @param startAt; ie: offset from the current parser position.
     * @return true if the rest of the query has matched brackets, false otherwise
     */
    protected boolean checkForMatchingBrace( int startAt ) {      if( log.isTraceEnabled() ) enterTrace ( "checkForMatchingBrace()" ) ;
      boolean retCode = false ;      try {
          Token tok = null ;          int i = startAt ;
          if( log.isDebugEnabled() ) {
              log.debug( "startAt: " + startAt ) ;
          }
          if( i == -1 ) {
              tok = adqlstox.getToken(0) ;
              while( tok.kind != AdqlStoXConstants.EOF ) {
                  if( tok.kind == AdqlStoXConstants.LEFT_PAREN ) {
                      break ;
                  }
                  tok = adqlstox.getToken(++i);
              }
          }          tok = adqlstox.getToken(i) ;
          if( log.isDebugEnabled() ) {
              log.debug( "Token: " + tok.image ) ;
          }
          if( tok.kind == AdqlStoXConstants.LEFT_PAREN ) {            
              int nesting = 0 ;
              while( tok.kind != AdqlStoXConstants.EOF ) {
                  if( tok.kind == AdqlStoXConstants.LEFT_PAREN ) {
                      nesting++;
                  }
                  else if( tok.kind == AdqlStoXConstants.RIGHT_PAREN ) {
                      nesting--;
                      if( nesting == 0 ) {
                          retCode = true ;
                          break ;
                      }
                  }
                  tok = adqlstox.getToken(++i);
              }
              if( retCode == false ) {
                  adqlstox.tracker.setError( "Unmatched left bracket" ) ;
              }
              
          }
          return retCode ;                }      finally {      	 if( log.isDebugEnabled() ) {      	    log.debug( "retCode: " + retCode ) ;	      	 }      	 if( log.isTraceEnabled() ) exitTrace ( "checkForMatchingBrace()" ) ;      }
          }
    
    /**
     * Routine for matching brackets, by reading ahead until a given position.
     * If unmatched brackets are encountered, will raise an error in the <code>Tracker</code>.
     * 
     * @param startAt; ie: offset from the current parser position.
     * @return true if no unmatched brackets are encountered, false otherwise
     */
    protected boolean checkForMatchingBraces( Token fromHere, Token toHere ) {
        if( log.isTraceEnabled() ) enterTrace ( "checkForMatchingBraces()" ) ;
        try {    
            if( log.isDebugEnabled() ) {
                log.debug( "fromHere: " + fromHere.image 
                         + " toHere: " + toHere.image ) ;
            }
            Token t = fromHere ;
            int nesting = 0 ;
            while( t != toHere ) {
                if( t.kind == AdqlStoXConstants.LEFT_PAREN ) {
                    nesting++;
                }
                else if( t.kind == AdqlStoXConstants.RIGHT_PAREN ) {
                    nesting--;
                }
                t = t.next ;
            }
            if( nesting == 0 ) {
                return true ;
            }
            else if( nesting == 1 ) {
                adqlstox.tracker.setError( "Unmatched left bracket" ) ;
            }
            else if( nesting > 1 ) {
                adqlstox.tracker.setError( "More than one unmatched left bracket" ) ;
            }
            else if( nesting == -1 ) {
                adqlstox.tracker.setError( "Unmatched right bracket" ) ;
            }
            else if( nesting < -1 ) {
                adqlstox.tracker.setError( "More than one unmatched right bracket" ) ;
            }   
            return false ;
        }
        finally {
             if( log.isTraceEnabled() ) exitTrace ( "checkForMatchingBraces()" ) ;
        }
    }
    
    /**
     * Utility routine to aid in skipping past errors encountered in the Select list.
     * It is an attempt at making the detection of multiple errors in a complex Select list.
     * It is invoked on each sublist; ie: each member (or value expression) of the select list.
     * 
     * @param first. Boolean to indicate this is the first entry in the Select list.
     * @param pex. Generalized error exception already raised.
     * @throws ParseException. A more targetted exception, or the one already passed in.
     */
    protected void selectSublistError( boolean first, ParseException pex ) throws ParseException {
      if( log.isTraceEnabled() ) enterTrace ( "selectSublistError()" ) ;
      try {
         StringBuffer buffer = null ;
         if( pex.getMessage() == null ) {
            buffer = initUtilityBuffer( "Encountered " ) ;
         }
         else {
            buffer = initUtilityBuffer( pex.getMessage() );
         }
         Token t = adqlstox.getToken(1) ;
         log.debug( "syntax error on: " + t.image ) ;    
           do {    
                 buffer.append( t.image ) ;
                 if( !t.image.equals( " " ) )
                    buffer.append( ' ' ) ;      
                 if( first && t.kind == AdqlStoXConstants.COMMA ) {
                    t = adqlstox.getNextToken() ;
                    if( t.kind != AdqlStoXConstants.COMMA ) {
                        break ;
                    }
                 }
                 if( t.kind == AdqlStoXConstants.FROM ) {  
                     adqlstox.tracker.setError( buffer.toString() ) ;             
                    throw new ParseException( buffer.toString() ) ;
                 }
               t = adqlstox.getNextToken();
               if( t.kind == AdqlStoXConstants.EOF )
                   break ;
               t = adqlstox.getToken(1) ;
           } while (t.kind != AdqlStoXConstants.COMMA );
           adqlstox.tracker.setError( buffer.toString() ) ;
      }
      finally {
         if( log.isTraceEnabled() ) exitTrace ( "selectSublistError()" ) ;
      }
    }

    

    /**
     * Checks for marginal conditions when processing the Select list;
     * ie: That a sublist does not start with a comma, or alternatively ends with multiple commas.
     * An aid to supporting the diagnosis of multiple errors in the Select list.
     */
    protected void selectSublistEnsureNotComma() {
        if( log.isTraceEnabled() ) enterTrace ( "selectSublistEnsureNotComma()" ) ;
        try {
           Token t = adqlstox.getToken(1) ;
           while (t.kind == AdqlStoXConstants.COMMA ) {   
               adqlstox.tracker.setError( "Encountered " + t.image ) ;         
               t = adqlstox.getNextToken();
               t = adqlstox.getToken(1) ;
           } ;
        }
        finally {
           if( log.isTraceEnabled() ) exitTrace ( "selectSublistEnsureNotComma()" ) ;
        }   
    }

    
    /**
     * Checks for marginal conditions when processing the Select list;
     * ie: That a sublist does not start with a comma, or alternatively ends with multiple commas,
     * or that the FROM is not accidentally trapped by a simple syntax error.
     * An aid to supporting the diagnosis of multiple errors in the Select list, and beyond.
     */
    protected void selectSublistEnsureCommaOrFrom() {
        if( log.isTraceEnabled() ) enterTrace ( "selectSublistEnsureCommaOrFrom()" ) ;
        boolean bError = false ;
        try {
           Token t = adqlstox.getToken(1) ;
           StringBuffer buffer = adqlstox.parser.initUtilityBuffer( "Encountered " ) ;
           while (t.kind != AdqlStoXConstants.FROM
                  &&
                  t.kind != AdqlStoXConstants.EOF) {  
               // If the next token is not a comma, loop looking for a comma
               // (or EOF or FROM clause)       
               if( t.kind != AdqlStoXConstants.COMMA ) {              
                  buffer.append( t.image ); 
                  if( !t.image.equals( " " ) )
                     buffer.append( ' ' ) ;   
                  t = adqlstox.getNextToken();
                  t = adqlstox.getToken(1) ;
                  bError = true ;
                  continue ;
               }
               
               // If the next token is a comma, ensure it is not followed immediately
               // by another comma...
               if( adqlstox.getToken(2).kind == AdqlStoXConstants.COMMA ) {    
                  buffer.append( t.image ) ;
                  if( !t.image.equals( " " ) )
                     buffer.append( ' ' ) ;  
                  t = adqlstox.getNextToken();
                  t = adqlstox.getToken(1) ;
                  bError = true ;
                  continue ;
               }
               
               break ;
           } ;
           if( bError == true ) {
               adqlstox.tracker.setError( buffer.toString() ) ;
           }
        }
        finally {
           if( log.isTraceEnabled() ) exitTrace ( "selectSublistEnsureCommaOrFrom()" ) ;
        } 
       
    }

    // Jeff. This requires a deal more work.
    int ffoCountAhead = 0 ;
    int ffoDefaultValue = 0 ;
    int ffoReturnValue = 0 ;
    Token ffoFirstToken = new Token() ;
    
    /**
     * A utility routine that attempts to type a value expression by looking for a first
     * operator within the given expression. The "given expression" is given in the sense 
     * that the parser is currently positioned on some value expression.
     * <br/><br/>
     * For example the following expression would return the kind 
     * <code>AdqlStoXConstants.PLUS_SIGN</code> by encountering the + sign:
     * <p><blockquote><pre>
     *     sin(col1) + cos(col2)
     * </pre></blockquote>
     * 
     * @param countAhead. The number of tokens to be examined before abandoning the search.
     * @param defaultValue. To be returned if no operator is encountered before the countAhead, or EOF.
     * @return The operator encountered, or the defaultValue.
     */
    protected int findFirstOperator( int countAhead, int defaultValue ) {
//        if( log.isTraceEnabled() ) enterTrace ( "findFirstOperator()" ) ;
        try {
            if( this.ffoFirstToken != adqlstox.getToken( 1 ) 
                ||
                this.ffoCountAhead != countAhead
                ||
                this.ffoDefaultValue != defaultValue ) {
           
                this.ffoCountAhead = countAhead ;
                this.ffoDefaultValue = defaultValue ; 
                this.ffoReturnValue = defaultValue ;
                this.ffoFirstToken = adqlstox.getToken( 1 ) ;
                int count = countAhead - 2 ;
                    
                forLoop: for( int i=2; i<count; i++ ) {
//                    if( log.isDebugEnabled() ) {
//                        log.debug( "Examining Token: " + parser.getToken( i ).image ) ;
//                    }
                    switch( adqlstox.getToken( i ).kind ) {
                    case AdqlStoXConstants.PLUS_SIGN :
                    case AdqlStoXConstants.MINUS_SIGN :
                    case AdqlStoXConstants.ASTERISK :
                    case AdqlStoXConstants.SOLIDUS :
                        this.ffoReturnValue = 0 ;
                        break forLoop ;
                    case AdqlStoXConstants.CONCATENATION_OPERATOR :
                        this.ffoReturnValue = 1 ;
                        break forLoop ;
                    case AdqlStoXConstants.AMPERSAND :
                    case AdqlStoXConstants.VERTICAL_BAR :
                    case AdqlStoXConstants.CIRCUMFLEX :
                    case AdqlStoXConstants.TILDE :
                        this.ffoReturnValue = 2 ;
                        break forLoop ;
                    case AdqlStoXConstants.COMMA :
                    case AdqlStoXConstants.LEFT_PAREN :
                    case AdqlStoXConstants.SELECT :
                    case AdqlStoXConstants.FROM :
                    case AdqlStoXConstants.WHERE :
                    case AdqlStoXConstants.EOF :
                        break forLoop ;
                    default :
                        ; // do nothing
                    }
                }               
            }
            return this.ffoReturnValue ; 
        }
        finally {
//            if( log.isTraceEnabled() ) exitTrace ( "findFirstOperator()" ) ;
        }
    }
    
    /**
     * Utility routine that checks the depth of qualification of a database object.
     *  
     * @param partsToCheck. The number of parts to check in the chain.
     * @return True is the qualifaction is of this depth, false otherwise.
     */
    protected boolean ifQualifiedPartsEqual( int partsToCheck ) {
//        if( log.isTraceEnabled() ) enterTrace ( "countQualifiedParts()" ) ;
        boolean retValue = false ;
        int count = 0 ;
        int limit = partsToCheck * 2 ;
        try {
            forLoop: for( int i=1; i<limit; i=i+2 ) {
                Token t = adqlstox.getToken(i) ;
//                if( log.isDebugEnabled() ) {
//                    log.debug( "Examining: " + t.image ) ;
//                }
                if( t.kind == AdqlStoXConstants.REGULAR_IDENTIFIER
                        ||
                        t.kind == AdqlStoXConstants.DELIMITED_IDENTIFIER ) {

                    count++ ;
                    if( adqlstox.getToken(i+1).kind != AdqlStoXConstants.PERIOD ) {
                        break forLoop ;
                    }             
                }
            }
        
            if( count == partsToCheck ) {
                retValue = true ;
            }
//            if( log.isDebugEnabled() ) {
//                log.debug( "partsToCheck: " + partsToCheck + "; count: " + count + "; retValue: " + retValue ) ;
//            }
        }
        finally {           
//            if( log.isTraceEnabled() ) exitTrace ( "countQualifiedParts()" ) ;
        }        
        return retValue ;
    }
    
    /**
     * Utility routine for discovering a .* qualification
     * 
     * @param countAhead: Number of tokens to search ahead.
     * @return True if .* qualification encountered, false otherwise.
     */
    protected boolean findPeriodAsterisk( int countAhead ) {
        if( log.isTraceEnabled() ) enterTrace ( "findPeriodAsterisk()" ) ;
        int count = countAhead - 2 ;
        try {
            for( int i=2; i<count; i++ ) {
                switch( adqlstox.getToken( i).kind ) {
                case AdqlStoXConstants.PERIOD_ASTERISK :
                    return true ;
                case AdqlStoXConstants.COMMA :
                    return false ;
                default :
                    ; // do nothing
                }
            }
            return false ;
        }
        finally {
             if( log.isTraceEnabled() ) exitTrace ( "findPeriodAsterisk()" ) ;
        }
      }
    
    /**
     * Utility routine for searching ahead to find a JOIN operator.
     * 
     * @param countAhead. Number of tokens to search ahead.
     * @return True if a join operator is encountered, false otherwise.
     */
    protected boolean findJoinOperator( int countAhead ) {
        if( log.isTraceEnabled() ) enterTrace ( "findJoinOperator()" ) ;
        int count = countAhead - 2 ;
        try {
            //
            // We're looking for the join operator.
            // If we encounter a comma, a where, a left parenthesis
            // or indeed end of file, then this cannot be a join.
            //
            // NB: With a bracket we assume it is a derived table,
            // which, of course, may contain a join!. Needs further study. 
            // The assumption of derived table may be weak.
            
            if( adqlstox.getToken(1).kind == AdqlStoXConstants.LEFT_PAREN ) {
                return true ;
            }
                    
            for( int i=2; i<count; i++ ) {
                switch( adqlstox.getToken( i).kind ) {
                case AdqlStoXConstants.JOIN :
                    return true ;
                case AdqlStoXConstants.COMMA :
                case AdqlStoXConstants.ON :
                case AdqlStoXConstants.USING :
                case AdqlStoXConstants.WHERE :
                case AdqlStoXConstants.LEFT_PAREN :
                case AdqlStoXConstants.EOF :
                    return false ;
                default :
                    ; // do nothing
                }
            }
            return false ; 
        }
        finally {
            if( log.isTraceEnabled() ) exitTrace ( "findJoinOperator()" ) ;
        }
    }

    /**
     * Gets the depth of the indent used in pretty printing the intermediate XML output.
     * 
     * @return the prettyPrintIndent
     */
    public int getPrettyPrintIndent() {
        return this.prettyPrintIndent ;
    }


    /**
     * Sets the indent depth used for pretty printing the intermediate XML,
     * if a text output from parsing is requested.
     * 
     * @param prettyPrintIndent The size of the indent to be used.
     */
    public void setPrettyPrintIndent( int prettyPrintIndent ) {
        this.prettyPrintIndent = prettyPrintIndent ;
    }
     
    /**
     * Returns the default user defined function prefix.
     * 
     * @return the defaultUserDefinedFunctionPrefix
     */
    public String getDefaultUserDefinedFunctionPrefix() {
        return defaultUserDefinedFunctionPrefix;
    }

    /**
     * Sets the user defined function prefix. User defined functions can be forced to begin with 
     * a known prefix, eg fPhotoFlags( String astring ), where the prefix is "f". This method 
     * sets that prefix for syntactical checking of user defined functions. If not set, the prefix
     * defaults to "udf_".
     * 
     * @param prefix the defaultUserDefinedFunctionPrefix to set
     */
    public void setUserDefinedFunctionPrefix( String prefix ) {
        this.defaultUserDefinedFunctionPrefix = prefix;
    }
    
    /**
     * Resets the user defined function prefix to the default "udf_".
     */
    public void resetUserDefinedFunctionPrefix() {
        this.defaultUserDefinedFunctionPrefix = "udf_";
    }
         
    /**
     * Called from within modules involved in parsing when a table
     * reference is encountered. The reference is saved in a collection 
     * of table references for use within semantic checking.
     * 
     * @param t A table reference.
     */
    protected void addTableReference( Object t ) {
        this.tableReferences.add( (XmlObject)t ) ;
    }
    
    /**
     * Called from within modules involved in parsing when a column 
     * reference is encountered. The reference is saved in a collection 
     * of column references for use within semantic checking.
     * 
     * @param c A column reference.
     */
    protected void addColumnReference( XmlObject c ) {
        this.columnReferences.add( c ) ;
    }
    
    /**
     * Called from within modules involved in parsing when an alias 
     * selection item is encountered. The alias is saved in a collection 
     * of aliases for use within semantic checking.
     * 
     * @param as An alias selection item.
     */
    protected void addAliasSelection( AliasSelectionItemType as ) {
        this.aliasSelections.add( as ) ;
    }

    /**
     * Returns the metadata query interface.
     * 
     * @return the metadataQuery interface.
     */
    public MetadataQuery getMetadataQuery() {
        return metadataQuery;
    }

    /**
     * Sets the MetadataQuery interface that will be used to make
     * queries against the metadata of a catalogue. The interface is used
     * in semantic checking; eg: to check on the existence of tables,
     * columns and user-defined functions. Semantics checks must be turned
     * on for this to be effective.
     * 
     * @param metadataQuery the metadataQuery to set
     */
    public void setMetadataQuery( MetadataQuery metadataQuery ) {
        this.metadataQuery = metadataQuery;
    }
    
    /**
     * Used to test whether the parser is supporting checks against catalogue
     * metadata.
     * 
     * @return true if the MetadataQuery interface has been set.
     */
    public boolean isMetadataQueryEnabled() {
        return metadataQuery != null ;
    }
    
    /**
     * Removes the MetadataQuery interface. No meta data queries will be made. 
     */
    public void unsetMetadataQueryEnabled() {
        metadataQuery = null ;
    }

    /**
     * Whether the parser is set for checking semantics.
     * 
     * @return the semanticProcessing
     */
    public boolean isSemanticProcessing() {
        return semanticProcessing;
    }    

    /**
     * Sets semantic processing on/off.
     * 
     * @param The semanticProcessing to set
     */
    public void setSemanticProcessing( boolean semanticProcessing ) {
        this.semanticProcessing = semanticProcessing;
    }
    
    /**
     * Searches the given SelectDocument (an already parsed query) looking 
     * for an XML Processing Instruction with the given name. Does NOT search
     * beyond the selection list. If found, the given Processing Instruction
     * is removed.
     * 
     * @param doc A query parsed into the given SelectDocument XMLBean.
     * @param name The name of an XML Processing Instruction
     */
    public static void RemoveProcessingInstruction( SelectDocument doc, String name ) {
        XmlCursor cursor = doc.newCursor() ;
        try {
            while( !cursor.toNextToken().isNone() ) {
                if( cursor.isProcinst() ) {
                    if( cursor.getName().getLocalPart().equals( name ) )  {
                        cursor.removeXml() ;
                        break ;
                    }
                }
                else if( cursor.isStart()
                         &&
                         cursor.getObject().schemaType() == SelectionListType.type ) {
                    //
                    // None found by the time SelectionList encountered...
                    break ;               
                }
            } // end while
        }
        finally {
            cursor.dispose();
        }      
    }
    
    /**
     * Writes a Processing Instruction, with the given name and contents,
     * into an already parsed query. The preference is to write the PI
     * before the Select, but if there is a PI with the same name upto
     * the selection list, then that position will be used.
     * 
     * @param doc A query parsed into the given SelectDocument XMLBean.
     * @param name The name of an XML Processing Instruction
     * @param content The contents of the Processing Instruction.
     */
    public static void WriteProcessingInstruction( SelectDocument doc, String name, String content ) {
        if( log.isTraceEnabled() ) log.trace( "enter: WriteProcessingInstruction()" ) ;
        
        String mangledContent = content.replaceAll( ">", "&gt_;" ).replaceAll( "<", "&lt_;" ) ;
        XmlCursor cursor = doc.newCursor() ;
        try {
            while( !cursor.toNextToken().isNone() ) {
                if( cursor.isProcinst() ) {
                    if( cursor.getName().getLocalPart().equals( name ) )  {
                       // OK. There's already one here. We'll use it...
                        cursor.setTextValue( content ) ;
                        return ;
                    }
                }
                else if( cursor.isStart() ) {
                    
                    SchemaType type = cursor.getObject().schemaType() ;
                    //
                    // Preference is to write before the SELECT
                    if( type == SelectType.type ) {
                        //
                        // Remember where the SELECT is located...
                        cursor.push() ;
                    }
                    //
                    // But we search for existing ones down to the SelectionList...
                    else if( type == SelectionListType.type ) {                       
                        break ;  
                    }
                }          
            } // end while
            cursor.pop() ;
            cursor.insertProcInst( name, mangledContent ) ;
        }
        finally {
            cursor.dispose();
            if( log.isTraceEnabled() ) log.trace( "exit: WriteProcessingInstruction()" ) ;
        }      
    } // end of writeProcessingInstruction
    
    /**
     * Searches the given SelectDocument (an already parsed query) looking 
     * for an XML Processing Instruction with the given name. Does NOT search
     * beyond the selection list.
     * 
     * @param doc A query parsed into the given SelectDocument XMLBean.
     * @param name The name of an XML Processing Instruction
     * @return The contents of the found Processing Instruction, null otherwise.
     */
    public static String ReadProcessingInstruction( SelectDocument doc, String name ) {
        String content = null ;
        XmlCursor cursor = doc.newCursor() ;
        try {
            while( !cursor.toNextToken().isNone() ) {
                if( cursor.isProcinst() ) {
                    if( cursor.getName().getLocalPart().equals( name ) )  {
                       // Found it...
                        content = cursor.getTextValue().replaceAll( "&gt_;", ">" ).replaceAll( "&lt_;", "<" ) ;
                        break ;
                    }
                }
                else if( cursor.isStart()
                         &&
                         cursor.getObject().schemaType() == SelectionListType.type ) {
                    break ;               
                }
            } // end while
            return content ;
        }
        finally {
            cursor.dispose();
        }      
    } // end of readProcessingInstruction
    
    private String formTableQualifier( TableType tt ) {
        if( tt.isSetSchema() ) {
            if( tt.isSetCatalog() ) {
                return tt.getCatalog() + '.' + tt.getSchema() + '.' + tt.getName() ;
            }
            else {
                return tt.getSchema() + '.' + tt.getName() ;
            }
        }
        else {
            return tt.getName() ;
        }
    }
    
    private String formTableQualifier( ColumnReferenceType tt ) {
        if( tt.isSetSchema() ) {
            if( tt.isSetCatalog() ) {
                return tt.getCatalog() + '.' + tt.getSchema() + '.' + tt.getTable() ;
            }
            else {
                return tt.getSchema() + '.' + tt.getTable() ;
            }
        }
        else {
            return tt.getTable() ;
        }
    }
    
    private String formTableQualifier( AllSelectionItemType tt ) {
        if( tt.isSetSchema() ) {
            if( tt.isSetCatalog() ) {
                return tt.getCatalog() + '.' + tt.getSchema() + '.' + tt.getTable() ;
            }
            else {
                return tt.getSchema() + '.' + tt.getTable() ;
            }
        }
        else {
            return tt.getTable() ;
        }
    }
    
    /**
     * Used to test whether the given syntax option is supported.
     * 
     * @param option to be tested
     * @return true if option supported, false otherwise.
     */
    public boolean isSyntaxSet( SyntaxOption option ) {
        return (syntaxSettings & option.setting) == option.setting ;
    }
    
    /**
     * Used to test whether the given array of syntax options are supported.
     * 
     * @param Arry of options to be tested.
     * @return True if all options are supported, false otherwise.
     */
    public boolean isSyntaxSet( SyntaxOption[] options ) {
        for( int i=0; i<options.length; i++ ) {
            if( (syntaxSettings & options[i].setting) != options[i].setting ) {
                return false ;
            }
        }
        return true ;
    }
    
    /**
     * Turns on support for the given option. This method will not disturb any other option setting.
     * 
     * @param option The option to be set.
     */
    public void setSyntax( final SyntaxOption option ) {
        this.syntaxSettings = this.syntaxSettings | option.setting ;
    }
    
    /**
     * Sets support for an array of syntax options for a parser. 
     * This method will not disturb any other syntax options.
     * 
     * @param options The array of options to be set.
     */
    public void setSyntax( final SyntaxOption[] options ) {
        for( int i=0; i<options.length; i++ ) {
            this.syntaxSettings = this.syntaxSettings | options[i].setting ;
        }
    }
 
    /**
     * Turns off support for the given option. This method will not disturb any other option setting.
     * 
     * @param option The option to be set off.
     */
    public void unsetSyntax( final SyntaxOption option ) {
        this.syntaxSettings = this.syntaxSettings & ~option.setting ;
    }
    
    /**
     * Unsets an array of options as supported by a parser. This method will not
     * disturb any other support options.
     * 
     * @param options The array of options to be unset.
     */
    public void unsetSyntax( final SyntaxOption[] options ) {
        for( int i=0; i<options.length; i++ ) {
            this.syntaxSettings = this.syntaxSettings & ~options[i].setting ;
        }
    }
    
    /**
     * Resets all support options to nothing.
     */
    public void resetSyntax() {
        this.syntaxSettings = 0 ;
    }
    
    /**
     * Sets strict support for the given options and only the given options.
     * 
     * @param options The array of options to be set.
     */
    public void setStrictSyntax( final SyntaxOption[] options ) {
        syntaxSettings = 0 ;
        setSyntax( options ) ;
    }
    
    /**
     * Tests whether the given array of options and only those are supported.
     * 
     * @return true if and only if the given options are supported
     */
    public boolean isStrictSyntax( final SyntaxOption[] options ) {
        long ordBits = 0 ;
        for( int i=0; i<options.length; i++ ) {
            ordBits = ordBits | options[i].setting ;
        }
         return ( syntaxSettings ^ ordBits ) == 0; 
    }

    /**
     * @return the debugIdentifiers
     */
    public boolean isDebugIdentifiers() {
        return debugIdentifiers;
    }


    /**
     * @param debugIdentifiers the debugIdentifiers to set
     */
    public void setDebugIdentifiers(boolean debugIdentifiers) {
        this.debugIdentifiers = debugIdentifiers;
    }
    
    private HashMap<Integer, String> reservedWordHints = new HashMap<Integer, String>() ;
    
    /**
     * The misuse of a reserved word will produce an error, but one that may be difficult to interpret. 
     * The parser can be primed to look for the misuse of a restricted list of reserved words. If
     * this is done, a more accurate error message can be emitted. This method allows such a restricted
     * list to be set up. The recommendation is not to set up more than 20, but feel free to 
     * experiment. It is obviously a matter of judgement, but if - for instance - you have a table
     * name "first", then please add it to the hints.
     * <p/>
     * The method is non-destructive. Those words already within the hints collection are not overwritten.
     * The method will vet each entry and will only accept those which are defined as SQL or ADQL reserved words.
     * The method fails silently.
     * 
     * @param reservedWords The array of reserved words to be used as hints.
     */
    public void addReservedWordHints( String[] reservedWords ) {
        String rsw ;       
        for( int i=0; i<reservedWords.length; i++ ) {            
            rsw = "\"" + reservedWords[i] + "\"" ;
            for( int j=0; j<AdqlStoXConstants.tokenImage.length; j++ ) {                
                if( rsw.equalsIgnoreCase( AdqlStoXConstants.tokenImage[j] ) ) {
                    reservedWordHints.put( new Integer(j), reservedWords[i] ) ;                    
                }                
            } // end jfor           
        } // end ifor
    }
    
    /**
     * Removes words from the collection of hints used by the parser to diagnose the misuse
     * of SQL and ADQL reserved words.
     * 
     * @param reservedWords The list of reserved words to be removed from the hints collection.
     */
    public void removeReservedWordHints( String[] reservedWords ) {
        String rsw ;       
        for( int i=0; i<reservedWords.length; i++ ) {            
            rsw = "\"" + reservedWords[i] + "\"" ;
            for( int j=0; j<AdqlStoXConstants.tokenImage.length; j++ ) {                
                if( rsw.equalsIgnoreCase( AdqlStoXConstants.tokenImage[j] ) ) {
                    reservedWordHints.remove( new Integer(j) ) ;                    
                }                
            } // end jfor           
        } // end ifor
    }
    
    /**
     * Empties the collection of hints used to diagnose the misuse of reserved words.
     */
    public void clearReservedWordHints() {
        reservedWordHints.clear() ;
    }
    
    private LinkedHashSet<String> reservedWordsEncountered = new LinkedHashSet<String>() ;
    
    /**
     * This method is the principle method used in attempting to detect clashes; that is: the misuse
     * of reserved words. It is called at certain points within parsing. 
     * <p/>
     * The current parsing token is examined. If the token represents a REGULAR_IDENTIFIER 
     * or a DELIMITED_IDENTIFIER, then no problem is likely to occur regarding reserved words
     * and the method returns false. That means no further checking will be undertaken if any syntax
     * error is encountered during parsing.
     * <p/>
     * If the token is not a REGULAR_IDENTIFIER or a DELIMITED_IDENTIFIER, then the method will return
     * false, but also does the following. The token is compared
     * to the reserved words hint collection. If the token is found within the hints collection, then
     * it is added to a special collection of reserved word hints encountered during parsing. If there
     * is a subsequent failure in parsing, this latter collection is used to guess at a possible misuse
     * of ADQL or SQL reserved words.
     * 
     * @return True if the current token is a Regular Identifier or a Delimited Identifier.
     */
    protected boolean checkSomeReservedWords() {
        Token t = adqlstox.getToken(1) ;
        if( t.kind == AdqlStoXConstants.REGULAR_IDENTIFIER 
            ||
            t.kind == AdqlStoXConstants.DELIMITED_IDENTIFIER ) {
            return false ;
        }
        else if( this.reservedWordHints.size() > 0 ) {
            if( this.reservedWordHints.containsKey( new Integer(t.kind) ) ) {
                this.reservedWordsEncountered.add( t.image ) ;
            }
        }
        return true ;
    }
    
    /**
     * ADQL is based upon SQL92, which has a list of reserved words. This method returns
     * that list, with some minor modifications ( "dec" has been removed ).
     * 
     * @return The array of SQL92 reserved words.
     */
    public static String[] getSQLReservedWords() {
        int rwCount = AdqlStoXConstants.ZONE - AdqlStoXConstants.ABSOLUTE + 1 ;
        ArrayList<String> rwList = new ArrayList<String>( rwCount ) ;
        for( int i=0; i<rwCount; i++ ) {
            String rw = AdqlStoXConstants.tokenImage[AdqlStoXConstants.ABSOLUTE+i] ;
            rwList.add( rw.substring( 1, rw.length()-1 ) ) ;
        }
        return (String[]) rwList.toArray( new String[rwCount] ) ;      
    }
    
    /**
     * ADQL has its own set of reserved words (eg: REGION). This method returns
     * that list.
     * 
     * @return The array of ADQL reserved words.
     */
    public static String[] getADQLReservedWords() {
        int rwCount = AdqlStoXConstants.TRUNCATE - AdqlStoXConstants.AREA + 1 ;
        ArrayList<String> rwList = new ArrayList<String>( rwCount ) ;
        for( int i=0; i<rwCount; i++ ) {
            String rw = AdqlStoXConstants.tokenImage[AdqlStoXConstants.AREA+i] ;
            rwList.add( rw.substring( 1, rw.length()-1 ) ) ;
        }
        return (String[]) rwList.toArray( new String[rwCount] ) ;     
    }
    
}
