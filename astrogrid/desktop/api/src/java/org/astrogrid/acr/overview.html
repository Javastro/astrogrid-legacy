<html>
<body>
<h1>AstroGrid Client Runtime API</h1>

<h1>2 Minute Introduction</h1>
The AstroGrid Client Runtime (ACR) simplifies working with Virtual Observatory services. It
<ul>
	<li>is a process that runs in the background on the user's desktop</li>
	<li>provides a set of functions that do VO work. The functions can be accessed in a variety of ways by the user or other desktop programs.</li>
	<li>calls VO web services via SOAP and Http to implement the functions</li>
	<li>provides a single point of configuration, caching, authentication and upgrade.</li>
	<li>simplifies client programming - no extensive libraries or knowledge of VO architecture is required</li>
</ul>

The ACR provides a graphical user interface (known as the AstroGrid Workbench). However, this document is concerned with how to 
call functions in the ACR programmatically. The ACR API (not ACRAPI :-) ) 
<ul>
	<li>is accessible through: direct method call from java; remote method call from another Java process (JavaRMI); remote method call from 
		any other process (XMLRPC); and via a http-get interface.
	</li>
	<li>attempts to present a suitable level of abstraction for client programmers. An API function may involve one or more SOAP calls to VO services, and hides the complexity of 
		communicating via XML</li>
	<li>provides helper methods for building datastructures, working with results</li>
	<li>provides reusable gui dialogues (e.g. file chooser) that can be called from client code</li>
	<li>provides small GUI applications for working with the VO that can be managed by client code</li>
</ul>

<h1>10 Minute Tutorial</h1>
It's pretty simple to get access to the ACR functions and start calling them. This tutorial covers this first stage.
<p />

The next stage is to understand how the VO services interrelate, and what can be done 
with each of them - this will take a little longer and is outside the scope of this tutorial. Keep in mind that the VO is a new system, 
and not all the IVOA standards have settled yet. Where possible, the api documentation contains references to the relevant standards, plus examples of 
how to use the api.

<h2>Architecture</h2>
The system architecture of the ACR looks something like this
<p />
<img src="org/astrogrid/acr/doc-files/acr-schematic.png" />
<p/>
On the left there's 4 different kinds of client for the ACR (there's some overlap between application and scripting). <p/>
Different kinds of client will call the ACR functions using one of 5 possible access methods (light blue boxes). The features provided by each access method is identical wherever
possible, apart from the 'GUI' access method, which only provides functions whose inputs can be entered simply by a user.<p />
No matter what the access method, the same implemementation of the function is called. <p/>
Related functions are gathered into <b>components</b>. Components are in turn gathered into <b>modules</b>. The modules present by default in the acr are
<dl>
	<dt>{@linkplain org.astrogrid.acr.astrogrid Astrogrid}</dt>
	<dd>access vo services</dd>
	<dt>{@linkplain org.astrogrid.acr.ui UI}</dt>
	<dd>control the workbench user interface</dd>
	<dt>{@linkplain org.astrogrid.acr.dialogs Dialogs}</dt>
	<dd>gui dialogs that prompt for input</dd>
	<dt>{@linkplain org.astrogrid.acr.system System}</dt>
	<dd>Configuration of the ACR, and management of the access methods</dd>
	<dt>{@linkplain org.astrogrid.acr.builtin Builtin}</dt>
	<dd>Internals of the ACR</dd>
</dl>
<p/>
Calling an API functions causes the ACR to communicate with external VO servers, by SOAP messages over the network.
<p/>

<h2>Choosing an Access Method</h2>
The access method you choose to call the ACR depends on a few factors:
<ul>
	<li>If you're coding in Java, you've the most choice. Choose  <b>RMI</b> if you want all the features and type safety of the API while keeping your code out of the ACR; choose <b>XMLRPC</b> if you prefer 
		something more lightweight, but less typed; Choose <b>XMLRPC</b> if you're implementing a new component that's going to be plugged into the ACR.</li>
	<li>If you're coding in another language, <b>XMLRPC</b> is the best choice. Most popular languages provide an XMLRPC client library - if your chosen language lacks once, fall back to <b>HTTP</b> (or consider writing the 
		xmlrpc client yourself)</li>
</ul>
<h3>RMI</h3>
You need the following jars on the classpath (all bundled in this distribution)
<ul>
	<li> <tt>acr-interface-*.jar</tt> - the interfaces documented in this javadoc</li>
	<li> <tt>rmi-lite-1.0.jar</tt>- (<a href="http://rmi-lite.sourceforge.net/">http://rmi-lite.sourceforge.net/</a>) - simplifies Java RMI by generating stub classes via reflection</li>
	<li> <tt>commons-logging-1.0.3.jar</tt> - (<a href="http://jakarta.apache.org/commons/logging/">http://jakarta.apache.org/commons/logging/</a>) - interface to various logging libraries</li>
   <li><tt>xerces-2.4.0.jar</tt>  - (<a href="http://xml.apache.org">http://xml.apache.org</a>) - xml parser - to ensure that <tt>Document</tt> objects can be transported via RMI</li>
   <li><tt>xml-apis-1.0.b2</tt> - (<a href="http://xml.apache.org">http://xml.apache.org</a>)  - supporting interfaces for the xml parser</li>
</ul>


Use the following code to access the ACR:
 <pre>
 import org.astrogrid.acr.builtin.ACR;
 import org.astrogrid.acr.Finder;
 Finder f = new Finder();
 ACR acr = f.find(); 
 </pre>
 {@link org.astrogrid.acr.Finder} takes care of connecting to the acr server. If it can't find a running service, it'll attempt to create one - either in-process or externally. 
It returns an instance of  {@link org.astrogrid.acr.builtin.ACR} . This allows you to retreive components (services) from the ACR, which you can then call methods on. The components of the acr
are arranged into modules, which correspond to <i>packages</i> in this javadoc. For example, to write some data to myspace, first retreive the {@link org.astrogrid.acr.astrogrid.Myspace} component, 
and then call the methods on it.
<pre>
import org.astrogrid.acr.astrogrid.Myspace;
import java.net.URI;
...
Myspace ms = (Myspace)acr.getService(Myspace.class);
URI file = new URI("#votable/results.txt");
String data= "some data";
if (!ms.exists(file)) {
	ms.createFile(file);
	}
ms.write(file, data);
</pre>
 
 See the javadoc of individual components for examples of their use.
 <p/>
 The RMI access method can also be used from other JVM-based programming languages, provided the jars are added to the classpath.
  See <a href="org/astrogrid/acr/astrogrid/doc-files/runAppDemo.groovy">runAppDemo.groovy</a> for an example of calling the ACR interface
 from Groovy (<a href="http://groovy.codehaus.org/">http://groovy.codehaus.org/</a>).
 
 
<h3>Direct</h3>
Very similar to RMI, but running in the same JVM as the ACR. You need all the jars in the acr-implementation distribution (<a href="http://www.astrogrid.org/maven/org.astrogrid/distributions/?P=astrogrid-desktop-1.1*.tar.gz*">astrogrid-desktop-1.1*.tar.gz</a>) on your classpath. Then access the ACR in the same way as for RMI - create a 
<tt>Finder</tt>, and from this get an <tt>ACR</tt> object. If there's no ACR already running and the implementation classes are on the classpath, an in-process acr will be created. There's no difference to the 
programming api.

<p/>

If you're implementing a new component for inclusion in the ACR, you should follow the same programming style as the other components - constructor injection. Wrap the returned <tt>ACR</tt>
object in a {@link org.astrogrid.acr.opt.AcrPicoContainer}, and use this to inject dependencies into your new component.

<h3>XMLRPC</h3>
There's XMLRPC libraries for a range of languages. See <a href="http://www.xmlrpc.com/">http://www.xmlrpc.com/</a> for a list. <p/>

The details of how to create and configure the xmlrpc client vary between language and library. The general principle is the same:
<ul>
	<li>a running acr will write a file in the user's home directory called <tt>.astrogrid-desktop</tt>. This contains a single line like <br />
		<tt>http://localhost:8001/a6d4c15eaaefe3c/</tt><br />
		This is the address of the ACR's internal webserver - it changes each time the ACR is run</li>
	<li>In your program, read the line from the file, and append <tt>xmlrpc</tt> to it. This gives the URL of the XMLRPC server</li>
	<li>Pass this url to the xmlrpc client library to configure it</li>
	<li>Functions of the api can be called using the form <tt>module-name.component-name.function-name</tt>. The javadoc for each component states the module-name and component-name to use. </li>
	<li>Documentation for individual functions may contain further notes about how to call the function via xmlrpc. The most significant change is that it's mostly strings that are passed as inputs and outputs - 
		the javadoc should note when this is not the case</li>			
	<li>make sure the acr is running before you attempt to run your program - there's not way for the program to start an ACR if it needs it.</li>
	<li>use the standard xmlrpc methods <tt>system.listMethods</tt>, <tt>system.methodHelp</tt>, and <tt>system.methodSignature</tt> to get information
		on methods at runtime.</li>
</ul>

<h4>Python Example</h4>
Here's the equivalent of the rmi example in Python, using the xmlrpc access method. Python comes bundled with an xmlrpc library, so nothing needs to be installed.
<pre>
import xmlrpclib as x
import os
#boilerplate - read the info file and configure the server
prefix = file(os.path.expanduser("~/.astrogrid-desktop")).next().rstrip()
server = x.Server(prefix + "xmlrpc")	
file = "#votable/results.txt"
data= "some data"
if not server.astrogrid.myspace.exists(file) :
	server.astrogrid.myspace.createFile(file)
server.astrogrid.myspace.write(file, data)
</pre>

See <a href="org/astrogrid/acr/astrogrid/doc-files/run-app-demo.py">run-app-demo.py</a>  for a larger example of working with the ACR in python via XMLRPC

<h4>Perl Example</h4>
Perl doesn't ship with an xmlrpc client by default, but the <a href="http://search.cpan.org/~kmacleod/Frontier-RPC-0.07b4/lib/Frontier/Client.pm">Frontier XMLRPC client</a>
can be downloaded from CPAN.<p />
Perl isn't my strong point, so this is less slick
<pre>
use Frontier::Client;

# create the server
# don't know how to find current user's home dir, or how to read in files nicely - hopefuly someone can show me how to do this
open(CONFIG_FILE,"/home/noel/.astrogrid-desktop") || die("Could not open acr config - check ACR is running");
$prefix=&lt;CONFIG_FILE&gt;
close(CONFIG_FILE);
chomp $prefix;
$url = $prefix . "xmlrpc";
$server = Frontier::Client->new(url => $url);
$file = "#votable/results.txt";
$data = "some data";
if ($server->call('astrogrid.myspace.exists',$file)) {
	$server->call('astrogrid.myspace.createFile',$file);
}
$server->call('astrogrid.myspace.write',$file,$data);
	
</pre>

<h4>C++ Example</h4>
See <a href="org/astrogrid/acr/doc-files/talk_to_acr_server.cpp">talk_to_acr_server.cpp</a> (thanks to Richard Holbrey)

<h3>HTTP-GET</h3>
If your language of choice lacks an XMLRPC library, but has a way to fetch a HTTP url, this interface can be
used as a fallback. Starting from the URL given in the <tt>.astrogrid-desktop</tt> file (or choosing the option 'Modules > Html Interface' in the Workbench), there's a series of
web pages that can be explored in a web browser, or called programatically.
<p/>
The pages are arranged into a hierarchy of <i>module</i> : <i>component</i> : <i>function</i> : <i>result-type</i>.
Modules, components and function were introduced previously. The result-type is a choice between
	<ul><li><tt>html</tt> - which will return an html-formatted result (possibly styling xml into html)</li>
			<li><tt>plain</tt> - which will return a plain-text result</li>
	</ul>
<p />		
When exploring in a web browser, on function pages there are forms to enter parameters and execute the function. The same can be done programatically by constructing URLs of the form
<pre>
	<i>server-context</i>/<i>module</i>/<i>component</i>/<i>function</i>/<i>result-type</i>?<i>parameters</i>
</pre>
For example, the following URL retreives information about the job <tt>jes:galahad.star.le.ac.uk/143.210.36.238/noelwinstanley@uk.ac.le.star/1441</tt>, displaying the result as plain text.
<pre>
http://localhost:8001/a6d4c15eaaefe3c/astrogrid/jobs/getJobInformation/plain?jobURN=jes:galahad.star.le.ac.uk/143.210.36.238/noelwinstanley@uk.ac.le.star/1441	
</pre>
The parameter names to use are documented on the function pages. It is also possible to perform a HTTP-POST of the parameters - this is better suited when the parameters are large (e.g documents)
<h1>Future Work</h1>
There's probably omissions in this API - it's hard to predict all uses of the system. Please email with feature requests or 'how do I do' questions. Some additions that are planned are
<ul>
	<li>community - information methods to return username, community, other identity info (useful when building workflows, etc)</li>
	<li>applications - ability to get more information about execution of an application (log messages), and registration of callbacks for completion notification</li>
	<li>jobs - callbacks for completion and progress information</li>
	<li>more dialogs - registry chooser, application chooser, query builder</li>	
	<li>ivorn bookmarks component - maintain bookmarks of 'favourite' registry locations. maybe extend to other identifiers too</li>
	<li>support calling services using other IVOA protocols - the Cone, SIAP, SSAP family, SkyNode, VOStore (when standardized)</li>
	<li>integration of services with these protocols into the application launcher / job monitor system</li>
</ul>

There's a bunch of optimizations that can be made to the implementation to take advantage of the new xquery interface to the registry (means it's possibly to 
query for and return just the data required, rather than entire records). This will not change the public interfaces though.
		
		
</body>
</html>