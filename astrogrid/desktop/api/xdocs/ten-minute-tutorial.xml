<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
<properties>
        <author email="noel.winstanley@manchester.ac.uk">Noel Winstanley</author>
        <title>Ten Minute Tutorial</title>
</properties>
<body>

	<section name="10 Minute Tutorial">
		<p>
			It's quite straightforward to connect to the Astro Runtime
			and start calling functions. This tutorial covers that first step.
		</p>
	</section>

		<section name="Architecture">
			<p>
				The architecture of a system that uses AR to access VO
				services looks something like this:
			</p>
			<img  src="images/acr-schematic.gif" border="1" />
			<p>
				The left of the figure lists the different kinds of client that might use the
				AR (there's some overlap between application and
				scripting).
			</p>
			<p>
				Clients call the AR 
				using one of four possible access methods (green circles). The feature set provided by each access method
				is identical between access methods, wherever possible. (Some technical limitations apply to
				XMLRPC, and in particular to REST)
			</p>
			<p>
				No matter what the access method, the same
				implemementation of the function is called.
			</p>
			<!--  expand and improv e this list -->
			<p>
				Related functions are gathered into <b>components</b>. Related components are in turn gathered into
				<b>modules</b>. The modules present in the AR are shown in the figure as blue boxes. They are"
				<dl>
					<dt>
						<tt>ivoa</tt>
					</dt>
					<dd>
						Access DAL services and query resource registries.
					</dd>
					<dt>
						<tt>astrogrid</tt>
					</dt>
					<dd>
						Access AstroGrid services: Myspace file storage, CEA task servers,
						DSA asynchronous catalog query, JES Workflow engine.
					</dd>
					<dt><tt>cds</tt></dt>
					<dd>
						Access CDS services: e.g. Vizier, Simbad name resolver
					</dd>
					<dt>
						<tt>plastic</tt>
					</dt>
					<dd>
						Exchange messages with other client-side applications.
					</dd>
					<dt>
						<tt>util</tt>
					</dt>
					<dd>
						Helper components for working with datatypes. 
						Provides basic access to the STIL table library.
					</dd>					
					<dt>
						<tt>dialogs</tt>
					</dt>
					<dd>Gui dialogs that can be used to prompt for input, and larger UI components (e.g. myspace browser)</dd>
					<dt>
						<tt>system</tt>
					</dt>
					<dd>
						configuration and internal services
					</dd>
				</dl>
			</p>
		</section>

		<section name="Installation"><p>
		As can be seen from the figure, you need to have a running AR service before
		applications can connect to it. AR is available as as stand-alone application,
		and is also bundled with the AstroGrid Workbench. Either can be downloaded
		from <a href="http://www.astrogrid.org/desktop">www.astrogrid.org/desktop</a>
		</p>
		</section>
		
		<section name="Choosing an Access Method">
			<p>
				The access method you choose to call the AR depends on
				a few factors:
				<ul>
					<li>
						If you're coding in Java, you've the most
						choice. Choose
						<b>RMI</b>
						if you want all the features and type safety of
						the API;
						<b>XMLRPC</b>
						if you prefer something more lightweight, but
						less typed; Choose
						<b>Direct</b>
						if you plan to compile and link directly to AR
					</li>
					<li>
						If you're coding in another language,
						<b>XMLRPC</b>
						is the best choice. Most popular languages
						provide an XMLRPC client library - if your
						chosen language lacks once, fall back to
						<b>REST</b>
						(or consider writing the xmlrpc client yourself)
					</li>
				</ul>
			</p>
			<p>
			We'll now describe each access method in turn - feel free to skip the 
			appropriate section.</p>
		</section>

		<section name="RMI">
			<p>
				You need to add the  jars in the <tt>rmi</tt> directory 
				to your application's classpath. These are:
				<ul>
					<li>
						<tt>acr-interface-*.jar</tt>
						- the AR interfaces
					</li>
					<li>
						<tt>rmi-lite-1.0.jar</tt>
						- (
						<a href="http://rmi-lite.sourceforge.net/">
							http://rmi-lite.sourceforge.net/
						</a>
						) - simplifies Java RMI by generating stub
						classes via reflection
					</li>
					<li>
						<tt>commons-logging-1.0.3.jar</tt>
						- (
						<a
							href="http://jakarta.apache.org/commons/logging/">
							http://jakarta.apache.org/commons/logging/
						</a>
						) - interface to various logging libraries
					</li>
					<li>
						<tt>xerces-2.4.0.jar</tt>
						- (
						<a href="http://xml.apache.org">
							http://xml.apache.org
						</a>
						) - xml parser - to ensure that
						<tt>Document</tt>
						objects can be transported via RMI
					</li>
					<li>
						<tt>xml-apis-1.0.b2</tt>
						- (
						<a href="http://xml.apache.org">
							http://xml.apache.org
						</a>
						) - supporting interfaces for the xml parser
					</li>
				</ul>
</p><p>
				Use the following code to access the ACR:
				<source>
import org.astrogrid.acr.builtin.ACR; 
import org.astrogrid.acr.Finder; 

Finder f = new Finder();
ACR acr = f.find();
				</source>
</p><p>
				<tt>Finder</tt> takes care of
				connecting to the AR service. If it can't find a running
				service, it'll attempt to create one - either in-process (if the AR implementation
				libraries are on the classpath)
				or externally (via webstart, or prompting the user). 
</p>
			<p>
			<tt>Finder</tt>
				returns an instance of <tt>ACR</tt> . From this you can
				retreive components (services) from the AR, which you
				can then call functions on. The components of the AR are
				arranged into modules, which correspond to
				<i>packages</i>
				in the javadoc. For example, to write some data to
				myspace, first retreive the
				<tt>org.astrogrid.acr.astrogrid.Myspace</tt> component, and then
				call the methods on it. e.g.

				<source>
import org.astrogrid.acr.astrogrid.Myspace; 
import java.net.URI;
 ... 
Myspace ms = (Myspace)acr.getService(Myspace.class); 
URI file =	new URI("#votable/results.txt"); 
String data= "some data"; 
if (!ms.exists(file)) { 
 	ms.createFile(file);
} 
ms.write(file, data);
</source>

				See the javadoc of individual components for examples of
				their use. Extensive examples of calling AR from Java over RMI
				are present in the <tt>examples/java</tt> directory.
			</p>
			<p>

				The RMI access method can also be used from other
				JVM-based programming languages, provided the jars are
				added to the classpath. See the <tt>examples/recipes/groovy</tt>
				directory for an example of calling the AR interface from  Groovy
				(
				<a href="http://groovy.codehaus.org/">
					http://groovy.codehaus.org/
				</a>
				).
			</p>
		</section>
		<section name="Direct">
			<p>
				Very similar to RMI, but running in the same JVM as the
				AR. You need all the jars of the AR implementation on your classpath
				(available as a zip from the download site). Then access the AR in the same way
				as for RMI - create a
				<tt>Finder</tt>
				, and from this get an
				<tt>ACR</tt>
				object. If there's no ACR already running and the
				implementation classes are on the classpath, an
				in-process acr will be created. There's no difference to
				the programming api.
			</p>
		</section>

		<section name="XMLRPC">
			<p>
				There's XMLRPC libraries for a range of languages. See
				<a href="http://www.xmlrpc.com/">
					http://www.xmlrpc.com/
				</a>
				for a list. For convenience, the libraries required for XMLRPC in java are
				available in the <tt>xmlrpc</tt> directory.
			</p>
			<p>

				The details of how to create and configure the xmlrpc
				client varies between language and library. The general
				method of connecting to the AR is the same however
				(and is similar to the procedure to connect to any PLASTIC hub):
				<ul>
					<li>
						a running AR will write a file in the user's
						home directory called
						<tt>.astrogrid-desktop</tt>
						. This contains a single line like
<source>
http://localhost:8001/a6d4c15eaaefe3c/
</source>
						This is the address of the ACR's internal
						webserver - the file changes each time the ACR
						is run, and is deleted when the ACR exits.
					</li>
					<li>
						In your program, read the line from the file,
						and append
						<tt>xmlrpc</tt>
						to it. This gives the URL of the XMLRPC server
					</li>
					<li>
						Pass this url to your xmlrpc client library to
						configure it
					</li>
					<li>
						Functions of the api can be called using the
						form
						<tt>
							module-name.component-name.function-name
						</tt>
						. The Javadoc for each component states the
						module-name and component-name to use. Function
						names are the same as in the Javadoc.
					</li>
					<li>If preferred, refer to the <a href="xmlrpc.html">API docs for XMLRPC</a>. 
					This is generated automatically from the definitive Javadoc, but have the 
					component and method names rewritten to conform to the format used in
					the XMLRPC access method.
					</li>
					<li>
						Documentation for individual functions may
						contain further notes about how to call the
						function via xmlrpc. The most significant change
						is that it's mostly strings that are passed as
						inputs and outputs - the javadoc should note
						when this is not the case.
					</li>
				</ul>
					
			Make sure the AR is running before you attempt
						to start your program -unlike RMI or Direct, 
						this method does not automatically
						start an AR if not already present.
			</p><p>
			Use the standard xmlrpc methods
						<tt>system.listMethods</tt>
						,
						<tt>system.methodHelp</tt>
						, and
						<tt>system.methodSignature</tt>
						to get information on methods at runtime.
						This is the same information as is present in the 
						documentation - however it isn't as nicely formatted.
			</p>
		
		<subsection name="Python Example">
			<p>
				Here's am example that uses the XMLRPC access method, from Python.
				The code performs the same AR operations as the previous RMI example.
			</p><p>	
				 Python comes
				bundled with an xmlrpc library, so nothing additional needs to be
				installed.
				<source>
import xmlrpclib as x 
import os

#boilerplate - read	the info file and configure the xmlrpc server 
prefix = file(os.path.expanduser("~/.astrogrid-desktop")).next().rstrip()
acr = x.Server(prefix + "xmlrpc") 

#now create some parameters and call some AR methods
file ="#votable/results.txt" 
data = "some data" 
if not acr.astrogrid.myspace.exists(file) :
	acr.astrogrid.myspace.createFile(file)
acr.astrogrid.myspace.write(file, data)
</source>

There are plenty more examples of using python and XMLRPC to work with AR in the
<tt>examples/commandline</tt> and <tt>examples/python-worflows</tt> directories.

			</p>
		</subsection>
		<subsection name="Other languages">
			<p>
			See the <tt>examples/recipes</tt> directory for examples 
			of connecting to AR using XMLRPC in Perl, C++
			and other languages.
			</p>
		</subsection>
</section>

		<section name="REST">
			<p>
				If your language of choice lacks an XMLRPC library, but
				has a way to fetch a HTTP url, the REST-like access method can be
				used as a fallback. Starting from the URL given in the
				<tt>.astrogrid-desktop</tt>
				file (or by pressing the  'Advanced &gt; AR Web interface
				Interface' button in the user interface), there's a series of web
				pages that can be explored in a web browser, or called
				programatically.
			</p>
			<p></p>
			<p>
				The pages are arranged into a hierarchy of
				<i>module</i>
				:
				<i>component</i>
				:
				<i>function</i>
				:
				<i>result-type</i>
				. Modules, components and function were introduced
				previously. The result-type is a choice between
				<ul>
					<li>
						<tt>html</tt>
						- which will return an html-formatted result
						(possibly styling xml into html)
					</li>
					<li>
						<tt>plain</tt>
						- which will return a plain-text result
					</li>
				</ul>
			</p>
			<p></p>
			<p>
				When exploring in a web browser, on function pages there
				are forms to enter parameters and execute the function.
				The equivalent URL to use to call the function programattically
				is given at the foot of these pages.
				The same can be done programatically by constructing
				URLs of the form
				<source>
<i>server-context</i>/<i>module</i>/<i>component</i>/<i>function</i>/<i>result-type</i>?<i>parameters</i>
</source>
				For example, the following URL retreives information
				about the job
				<tt>
					jes:galahad.star.le.ac.uk/143.210.36.238/noelwinstanley@uk.ac.le.star/1441
				</tt>
				, displaying the result as plain text.
				<source>
http://localhost:8001/a6d4c15eaaefe3c/astrogrid/jobs/getJobInformation/plain?jobURN=jes:galahad.star.le.ac.uk/143.210.36.238/noelwinstanley@uk.ac.le.star/1441
				</source>
				The parameter names to use are documented on the
				function pages. It is also possible to perform a
				HTTP-POST of the parameters - this is better suited when
				the parameters are large (e.g documents)
			</p>
			<p>See the <tt>examples/recipes/sh</tt> directory for examples of using
			the REST interface from bash scripts - using the <tt>curl</tt> commandline tool
			to fetch the URL.
			</p>
	</section>

	<section name="The Next Step">
		<p>
		This tutorial showed how to connect to the Astro Runtime and call some functions.
		</p>
		<p>
		The next step is to explore the functions of the different
		parts of the AR API (and the VO services behind them), and begin to 
		understand how they interrelate and what can be done with each of them.
		Examine some <tt>examples</tt> to understand how different components
		can cooperate together, while referring to the 
	 <a href="/apidocs/index.html">API Javadoc</a>.
	 Where possible, the documentation for each component contains
		references to the relevant standards, plus simple examples of how to
		use the api. 
		</p>
	</section>
	<section name="Questions?">
		<p>
			If you're using the AR in your own project, or are considering doing so, we'd
			love to hear from you. Furthermore, if you've questions on how to use particular parts
			of the API, we'll do our best to help. There are some <a href="mail-lists.html">Mailing Lists</a> set
			up for this.
			
		</p>
	</section>
</body>
</document>