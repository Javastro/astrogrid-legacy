/* AdqlTransformer.java
 * Created on 27-Oct-2005
 *
 * Copyright (C) AstroGrid. All rights reserved.
 *
 * This software is published under the terms of the AstroGrid 
 * Software License version 1.2, a copy of which has been included 
 * with this distribution in the LICENSE.txt file.  
 *
**/
package org.astrogrid.desktop.modules.adqlEditor;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.geom.Rectangle2D;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.xmlbeans.XmlCursor;

import org.astrogrid.desktop.modules.adqlEditor.nodes.*;

/**
 * @author jl99
 *
 */
public class AdqlTransformer {
    
    protected static final Log log = LogFactory.getLog( AdqlTransformer.class ) ;
    
    private static final boolean DEBUG_ENABLED = false ;
    private static final boolean TRACE_ENABLED = false ;
    
    private Transformer textTransformer ;
    private Transformer htmlTransformer ;
    private Pattern nbsp = Pattern.compile( "\\xA0" ) ;    
    private int to, from ;
    
    
    public static Source getFullTextStyleSource() {
        return new StreamSource( AdqlTransformer.class.getResourceAsStream( "ADQL10toSQL_TEXT_FULL.xsl" ) ) ;
    }
    
    public static Source getFullHtmlStyleSource() {
        return new StreamSource( AdqlTransformer.class.getResourceAsStream( "ADQL10toSQL_HTML_FULL.xsl" ) ) ;
    }

    /**
     * 
     */
    public AdqlTransformer() {

        try {
            textTransformer = TransformerFactory.newInstance().newTransformer( getFullTextStyleSource() );
            htmlTransformer = TransformerFactory.newInstance().newTransformer( getFullHtmlStyleSource() );
        } catch(TransformerConfigurationException tce ) {
           // Error generated by the parser
           log.error( "\n** Transformer Factory error", tce ) ;
        } 
        
    }
    
    
    public synchronized String transformToAdqls( String adqlx, String spaceCharacter ) {
        StreamSource source = new StreamSource( new StringReader( adqlx ) ) ;
        StreamResult result = new StreamResult( new StringWriter() ) ;
        String retVal = "" ;
        try {
            textTransformer.setParameter( "spaceCharacter", spaceCharacter ) ;
            textTransformer.transform( source, result ) ;
            retVal = ((StringWriter)result.getWriter()).toString() ; 
        }
        catch( Exception ex ) {
            log.error ( ex ) ;
        }
        return retVal ;
    }
    
    public String transformToAdqls( String adqlx ) {
        return transformToAdqls( adqlx, "&#160;" ) ;
    }
    
    //
    // These require care to improve them. The basic algorithm works but is
    // buggy. There are some variations here. The current used variation is crude
    // and very cpu intensive, but until I understand it more best stick to the
    // simple if crude.
    //
    // Some points. I often end up with a negative index. Somehow I get a breakpoint set 
    // to the beginning of a display entry. ie: arraySize comes back with [0]
    
    public synchronized String transformDisplayValues( AdqlNode entry
                                                     , AdqlTree tree
                                                     , boolean expanded
                                                     , boolean leaf ) {
        if( TRACE_ENABLED ) log.debug( "enter: AdqlTransformer.transformDisplayValues()" ) ;
        XmlCursor cursor = entry.getXmlObject().newCursor() ;
        String xmlString = cursor.xmlText() ;
        cursor.dispose() ;
        
        //
        // First pass estimates line breaks required...
        ArrayList breakPoints = this.getBreakPoints( entry, tree, xmlString ) ;
            
        StreamSource source = new StreamSource( new StringReader( xmlString ) ) ;
        StreamResult result = new StreamResult( new StringWriter() ) ;
        String retVal = "" ;
        try {

 
            source = new StreamSource( new StringReader( xmlString ) ) ;
            result = new StreamResult( new StringWriter() ) ;
//            htmlTransformer.setParameter( "keywordColor", "Red" ) ;
//            htmlTransformer.setParameter( "defaultColor", "Cyan" ) ;
            htmlTransformer.transform( source, result ) ;
            retVal = ((StringWriter)result.getWriter()).toString() ; 
            // retVal = retVal.replaceFirst( "xmlns=\"http://www.ivoa.net/xml/ADQL/v1.0\"", "" ) ;
            
            if( breakPoints != null && breakPoints.size() > 0 ) {
                char[] nbs = { (char)160 } ;
                String nbsString = new String( nbs ) ;
                Pattern p = Pattern.compile( nbsString );
                Matcher m = p.matcher( retVal ) ;
                StringBuffer sb = new StringBuffer( retVal.length() + ( breakPoints.size() * 4 ) + 32 );
                int foundCount = 0 ;
                ListIterator iterator = breakPoints.listIterator() ;
//                int replaceRankOrder = ((Integer)breakPoints.get( 0 )).intValue() ;
                int replaceRankOrder = ((Integer)iterator.next()).intValue() ;
                while( m.find() ) {
                    foundCount++ ;
                    if( replaceRankOrder == foundCount ) {
                        m.appendReplacement( sb, "<br></br>" ) ;
                        if( iterator.hasNext() ) {
                            replaceRankOrder = ((Integer)iterator.next()).intValue() ;
                        }
                        else {
                            break ;
                        }
                    } 
                    else {
                        m.appendReplacement( sb, " " ) ;
                        // m.appendReplacement( sb, nbsString ) ;
                    }
                }
                m.appendTail(sb);
                retVal = sb.toString() ;
            }
        }
        catch( Exception ex ) {
            ex.printStackTrace() ;
        }
        return retVal ;
    }
    
    private ArrayList getBreakPoints( AdqlNode entry, AdqlTree tree, String xmlString ) {
        ArrayList arrayList = null ;
      
        int availablePixels = entry.getUseableWidth() ; 
        if( availablePixels > 0 ) {
            StreamSource source = new StreamSource( new StringReader( xmlString ) ) ;
            StreamResult result = new StreamResult( new StringWriter() ) ;
            String textVal ;
            
            try {
                textTransformer.setParameter( "spaceCharacter", "\u00A0" ) ;
                textTransformer.transform( source, result ) ;
                textVal = ((StringWriter)result.getWriter()).toString() ;    
                //
                // The following works after a fashion.
                // 
               
                FontMetrics fm = tree.getFontMetrics( tree.getFont() ) ;
                int requiredPixels = fm.stringWidth( textVal ) ;
                int charPixels = fm.charWidth( 'm' ) ;
                
                if( requiredPixels > availablePixels ) { 
                    int charCount = 0 ;
                    int nbsCount = 0 ;
                    int lineCharCount = 0 ;
                    int lineCharSize = availablePixels / charPixels ;
                    int textSearchSize = textVal.length() - 1 ;
                    arrayList = new ArrayList();
                    for( int i=0; i<textSearchSize; i++, lineCharCount++ ) {
                        if( textVal.charAt(i) == (char)160 ) {
                            nbsCount++ ;
                        }       
                        if( lineCharCount == lineCharSize ) {
                            arrayList.add( new Integer( nbsCount ) ) ;
                            lineCharCount = 0 ;
                        }
                    }

                }
                
            }
            catch( Exception ex ) {
                ex.printStackTrace() ;
            }
            
        }     
        return arrayList ;
      
    }
    
    private ArrayList getBreakPoints2( AdqlNode entry, AdqlTree tree, String xmlString ) {
        ArrayList arrayList = null ;
        //
        // Not sure when this gets updated (re resizing)
        // Update: seems to be OK. ie: when resizing I get the new size,
        // even if not yet painted.
        int availablePixels = entry.getUseableWidth() ; 

        if( availablePixels > 0 ) {
            StreamSource source = new StreamSource( new StringReader( xmlString ) ) ;
            StreamResult result = new StreamResult( new StringWriter() ) ;
            String textVal ;
            
            try {
                textTransformer.setParameter( "spaceCharacter", "\u00A0" ) ;
                textTransformer.transform( source, result ) ;
                textVal = ((StringWriter)result.getWriter()).toString() ;    
                //
                // The following works after a fashion, but needs refinement.
                
                //
                // This may be too crude.
                Graphics g = tree.getGraphics() ;
                if( g == null )
                    return arrayList ;
                FontMetrics fm = g.getFontMetrics() ;
                if( fm == null )
                    return arrayList ;
                Rectangle2D sRect = fm.getStringBounds( textVal, g ) ;           
                int requiredPixels = (int)sRect.getWidth() ;
               
                if( requiredPixels > availablePixels ) { 
                    //
                    // It is possible that at the margin one more line may be required.
                    // Reason... We search backwards for a suitable space to break the line,
                    // and thus may create the need for another line due to the search backwards.
                    int linesRequired = ( requiredPixels / availablePixels ) 
                                      + ( requiredPixels % availablePixels > 0 ? 1 : 0 ) ;
 //                   int textLength = textVal.length() ;
                    arrayList = new ArrayList() ;
                    int index ;
                    from = 0 ;
                    //
                    // The condition here should be linesRequired-1, but see comment above.
                    // We are allowing for one more line.
                    for( int i=0; i<linesRequired; i++ ) {
                        index = findOneLine3( textVal, g, fm, availablePixels ) ;
                        if( index < 1 )
                            break ;
                        arrayList.add( new Integer(index) ) ;
                    }

                }
                
            }
            catch( Exception ex ) {
                ex.printStackTrace() ;
            }
            
        }     
        return arrayList ;
      
    }
    
    private int findOneLine( String text, int from, Graphics g, FontMetrics fm, int available ) {
        if( (int)fm.getStringBounds( text, from, text.length()-1, g ).getWidth() < available )
            return -1 ;
        int 
          pLineSize,
          textLength = text.length(),
          to = (textLength - from) / 2,
          p1 = from,
          q1 = to,
          q2 = textLength - 1 ;
        do {
            pLineSize = (int)fm.getStringBounds( text, from, to, g ).getWidth() ;
            if( pLineSize < available ) {
                p1 = q1 ;
                q1 = q2 ;
                to = (q1 - p1) / 2 ;				  // bump it up
            }
            else if( pLineSize > available ) {
                q2 = q1 ;
                q1 = (q1 - p1) / 2 ;                  // drag it down
                to = q1 ;
            }
            break ;
        } while ( q1 - p1 > 2 );
             
        int index = text.lastIndexOf( (char)160, to ) ; 
        int count = 0 ;
        for(int i=0 ; i<text.length(); i++ ) {
            if( text.charAt(i) == (char)160 ) {
                count++ ;
            }
        }       
        return count ;
    }
    
    private int findOneLine2( String text, int from, Graphics g, FontMetrics fm, int available ) {
        if( (int)fm.getStringBounds( text, from, text.length()-from, g ).getWidth() <= available )
            return -1 ;
        int 
          to = (text.length() - from) / 2,
          split = (int)fm.getStringBounds( text, from, to, g ).getWidth() ;
            
        if( split < available ) {
            do {        
                split = (int)fm.getStringBounds( text, from, ++to, g ).getWidth() ;
            } while( split < available ) ;
        }
        else if( split > available ){
            do {
                split = (int)fm.getStringBounds( text, from, --to, g ).getWidth() ;
            } while( split > available ) ;
            to++ ;
        }
             
        int index = text.lastIndexOf( (char)160, to ) ; 
        int count = 0 ;
        for(int i=0 ; i<index; i++ ) {
            if( text.charAt(i) == (char)160 ) {
                count++ ;
            }
        }       
        return count ;
    }
    
    private int findOneLine3( String text, Graphics g, FontMetrics fm, int available ) {
        to = from+1 ;
        int split = 0 ;
        
        if( from < 0 || from > text.length() )
            return -1 ;

        try {
            if( (int)fm.getStringBounds( text, from, text.length(), g ).getWidth() <= available )
                return -1 ;
        }
        catch( Exception ex ) {
            ex.printStackTrace() ;
            return -1 ;
        }
   
        do {
            if( from > to+1 )
                break ;
            split = (int)fm.getStringBounds( text, from, ++to, g ).getWidth() ;
        } while( split <= available ) ;
        
        int index = text.lastIndexOf( (char)160, to ) ; 
        if( index < 1 )
            return 0 ;
        to = index ;
        int count = 0 ;
        for( int i=0 ; i<=index; i++ ) {
            if( text.charAt(i) == (char)160 ) {
                count++ ;
            }
        }  
        from = from + to ;
        return count ;
    }

}// end of class AdqlTransformer
