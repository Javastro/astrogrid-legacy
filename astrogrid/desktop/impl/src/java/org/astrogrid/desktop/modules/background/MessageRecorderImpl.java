/*$Id: MessageRecorderImpl.java,v 1.2 2005/11/02 09:29:51 nw Exp $
 * Created on 25-Oct-2005
 *
 * Copyright (C) AstroGrid. All rights reserved.
 *
 * This software is published under the terms of the AstroGrid 
 * Software License version 1.2, a copy of which has been included 
 * with this distribution in the LICENSE.txt file.  
 *
**/
package org.astrogrid.desktop.modules.background;

import org.astrogrid.acr.astrogrid.ExecutionInformation;
import org.astrogrid.acr.system.SystemTray;
import org.astrogrid.desktop.modules.system.StoreInternal;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.picocontainer.Startable;


import java.io.IOException;
import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;

import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;
import javax.swing.SwingUtilities;
import javax.swing.event.EventListenerList;
import javax.swing.event.TableModelListener;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

import jdbm.RecordManager;
import jdbm.btree.BTree;
import jdbm.helper.FastIterator;
import jdbm.helper.LongComparator;
import jdbm.helper.StringComparator;
import jdbm.helper.Tuple;
import jdbm.helper.TupleBrowser;

/** Implementation of a listener to JMS messages that collates and records them to a persistent store.
 * @author Noel Winstanley nw@jb.man.ac.uk 25-Oct-2005
 * @todo integrate systemtray.
 * @todo later match up event recorder with events being generated by the bridge.
 */
public class MessageRecorderImpl implements Startable, MessageRecorder{
    /**
     * Commons Logger for this class
     */
    static final Log logger = LogFactory.getLog(MessageRecorderImpl.class);

    /** vairant constructor, used when systray isn't available. */
    public MessageRecorderImpl(MessagingInternal m, StoreInternal store) throws IOException {
        this(m,store,null);
    }
    /** Construct a new MessageRecorderImpl
     * @throws IOException
     * @throws JMSException
     * 
     */
    public MessageRecorderImpl(MessagingInternal m, StoreInternal store, SystemTray sysTray) throws IOException {
        super();
        this.m = m;
        this.sysTray = sysTray;

        this.folders = Folders.findOrCreate(store.getManager());
        this.messages = new Messages(store.getManager());
    }
    protected final SystemTray sysTray;
    protected final MessagingInternal m;
    protected final Folders folders;
    protected final Messages messages;

    public TreeModel getFolderList() {
        return folders;
    }
    
    public TableModel getMessageList() {
        return messages;
    }
    
    public void deleteFolder(Folder f) throws IOException {
        folders.deleteFolder(f);
        messages.deleteFolder(f.getKey());
    }
    
    public void displayMessages(Folder f) throws IOException {
        messages.displayFolder(f.getKey());
    }
    
    public void deleteMessage(int row) throws IOException {
        messages.deleteMessage(row);
    }
    
    public Message getMessage(int row) throws IOException {
        return messages.getMessage(row);
    }
    
    public void updateMessage(Message m) throws IOException {
        messages.updateMessage(m);
    }
    
    public void updateFolder(Folder f) throws IOException {
        folders.updateFolder(f);
    }
    
    public Message[] listFolder(Folder f) throws IOException{
        return messages.listFolder(f.getKey());
    }
       
    public static class FolderImpl implements Serializable, Folder {
        public FolderImpl(String key, String parentKey) {
            this.key = key;
            this.parentKey = parentKey;
            children = new ArrayList();        
        }
        public final String key; // gloablly unique key.
        public final List children; // keys of children
        public final  String parentKey; // key of parent (null for root)
        private Serializable userObject;
        public void setUserObject(Serializable s) { 
            this.userObject = s;
        }
        public Serializable getUserObject() {
            return userObject;
        }
        public String getKey() {
            return key;
        }
        public String toString() {
            return userObject == null ? key : userObject.toString();
        }
    }
    
    
    public static class MessageImpl implements Serializable, Message{
        public MessageImpl(String summary,String text, Date timestamp) {
            this.summary = summary;
            this.text = text;
            this.unread = true;
            this.timestamp = timestamp;
        }
        private boolean unread;
        public Long key;
        private final String summary;
        private final String text;
        private final Date timestamp;
        public boolean isUnread() {
            return unread;
        }
        public void setUnread(boolean b) {
            this.unread= b;
        }
        public String getSummary() {
            return this.summary;
        }
        public String getText() {
            return this.text;
        }  
        public Date getTimestamp() {
            return this.timestamp;
        }
    }
        
    // keys for well-known folders.
    public static final String ROOT = "/";
        public static final String ALERTS = "Alerts";
        public static final String TASKS = "Tasks";
        public static final String JOBS = "Jobs";
    
    /** represents a collection of folders 
     * 
     * very little checking on methods - clients use with care.
     * */
    private static class Folders implements TreeModel {
        /** key that the folders are stored under in the JDBM */ 
        private final static String TREE_NAME = "recorder.folders";
        private static Comparator comp = new StringComparator();       
        /** factory method for folders object */
        public static Folders findOrCreate(RecordManager rec) throws IOException {
            long code = rec.getNamedObject(TREE_NAME);
            if (code ==0) {
                Folders fs =  new Folders(BTree.createInstance(rec,comp),rec);
                fs.initialize();
                return fs;
            } else {
                return new Folders(BTree.load(rec,code),rec);
            }      
    }
    
        private Folders(BTree tree, RecordManager rec) throws IOException {
            this.b = tree;
            this.rec = rec;
            this.root = (FolderImpl)getFolder(ROOT); // will reurn null the first time
        }
        private FolderImpl root;
        private final BTree b;
        private final RecordManager rec;        
        private final  EventListenerList listenerList = new EventListenerList();        
        
        // initialie the first time..
        private void initialize() throws IOException {
            rec.setNamedObject(TREE_NAME,b.getRecid());
            root = new FolderImpl(ROOT,null);
            FolderImpl jobs = new FolderImpl(JOBS,ROOT);
            FolderImpl tasks = new FolderImpl(TASKS,ROOT);
            FolderImpl alerts = new FolderImpl(ALERTS,ROOT);
            // don't think we need any user objects here.
            root.children.add(ALERTS);
            root.children.add(TASKS);
            root.children.add(JOBS);            
            b.insert(ROOT,root,false);
            b.insert(JOBS,jobs,false);
            b.insert(TASKS,tasks,false);
            b.insert(ALERTS,alerts,false);
            rec.commit();            
            final TreeModelEvent e = new TreeModelEvent(this, new Object[]{root});                    
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    Object[] listeners = listenerList.getListenerList();
                    for (int i = listeners.length-2; i >= 0; i-=2) {
                        if (listeners[i] == TreeModelListener.class) {
                            ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
                        }
                }
                }
            });
        }
        
        
        //
        /** retrive a folder 
         * @throws IOException*/
        public Folder getFolder(String key) throws IOException {
             return (Folder)b.find(key);
        }
        
        public synchronized Folder createFolder(String parentKey, String newKey) throws IOException {
            final FolderImpl f = new FolderImpl(newKey,parentKey);
            b.insert(newKey,f,false);
            if (parentKey != null) {
                FolderImpl parent = (FolderImpl)getFolder(parentKey);
                parent.children.add(newKey);
                b.insert(parentKey,parent,true);
            }
            rec.commit();
            FolderImpl parent = (FolderImpl)getFolder(f.parentKey);
            final TreeModelEvent e = new TreeModelEvent(this
                    , getPathToRoot(parent) 
            , new int[]{parent.children.indexOf(f.key)}
            , new Object[]{f});
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    Object[] listeners = listenerList.getListenerList();
                    for (int i = listeners.length-2; i>=0; i-=2) {
                        if (listeners[i]==TreeModelListener.class) {                   
                            ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
                        }          
                    }
                }
            });
            return f;
        }
        
        
        public synchronized void deleteFolder(Folder g) throws IOException {
            FolderImpl doomed = (FolderImpl)g;
            if (doomed == null) {
                return;
            }
            FolderImpl parent = (FolderImpl)getFolder(doomed.parentKey);
            // adjust parent
            int pos = parent.children.indexOf(doomed.key);
            parent.children.remove(pos);
            b.insert(parent.key,parent,true);
            // delete child.
            b.remove(doomed.key);
            rec.commit();
            final TreeModelEvent e =  new TreeModelEvent(this
                    , getPathToRoot(parent) 
            , new int[]{pos}
            , new Object[]{doomed});
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {            
                    Object[] listeners = listenerList.getListenerList();
                    for (int i = listeners.length-2; i>=0; i-=2) {
                        if (listeners[i]==TreeModelListener.class) {
                            ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
                        }          
                    }
                }
            });                        
        }
        
        public synchronized void updateFolder(Folder g) throws IOException {
            FolderImpl f = (FolderImpl)g;
            b.insert(f.getKey(),f,true); // overwrites previous definition.
            rec.commit();            
            FolderImpl parent = (FolderImpl)getFolder(f.parentKey);
            final TreeModelEvent e = new TreeModelEvent(this
                    , getPathToRoot(parent) 
            , new int[]{parent.children.indexOf(f.key)}
            , new Object[]{f}); 
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {               
                    Object[] listeners = listenerList.getListenerList();
                    for (int i = listeners.length-2; i>=0; i-=2) {
                        if (listeners[i]==TreeModelListener.class) {        
                            ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
                        }          
                    }
                }
            });
        }
        /** cribed from DefaultTreeModel - wish that class was more reusable.
         * Builds the parents of node up to and including the root node,
         * where the original node is the last element in the returned array.
         * The length of the returned array gives the node's depth in the
         * tree.
         * 
         * @param aNode the TreeNode to get the path for
         * @throws IOException
         */
        private Folder[] getPathToRoot(Folder aNode) throws IOException {
            return getPathToRoot(aNode, 0);
        }

        /**
         * Builds the parents of node up to and including the root node,
         * where the original node is the last element in the returned array.
         * The length of the returned array gives the node's depth in the
         * tree.
         * 
         * @param aNode  the TreeNode to get the path for
         * @param depth  an int giving the number of steps already taken towards
         *        the root (on recursive calls), used to size the returned array
         * @return an array of TreeNodes giving the path from the root to the
         *         specified node 
         * @throws IOException
         */
        private Folder[] getPathToRoot(Folder aNode, int depth) throws IOException {
            Folder[]              retNodes;
        // This method recurses, traversing towards the root in order
        // size the array. On the way back, it fills in the nodes,
        // starting from the root and working back to the original node.

            /* Check for null, in case someone passed in a null node, or
               they passed in an element that isn't rooted at root. */
            if(aNode == null) {
                if(depth == 0)
                    return null;
                else
                    retNodes = new Folder[depth];
            }
            else {
                depth++;
                if(aNode == root)
                    retNodes = new Folder[depth];
                else {
                    Folder parent = getFolder(((FolderImpl)aNode).parentKey);
                    retNodes = getPathToRoot(parent, depth);
                }
                retNodes[retNodes.length - depth] = aNode;
            }
            return retNodes;
        }

        
        
        // Tree-model methods.
        /**
         * @see javax.swing.tree.TreeModel#getRoot()
         */
        public Object getRoot() {
            return root;
        }

        public int getChildCount(Object parent) {
            FolderImpl f = (FolderImpl)parent;
            return f.children.size();
        }

        public boolean isLeaf(Object node) {
           FolderImpl f =(FolderImpl)node;
        try {
            //is a leaf if it has a message folder associated.
            return 0 != rec.getNamedObject(f.key);
        } catch (IOException e) {
            return false;
        }
        }

        public void addTreeModelListener(TreeModelListener l) {
            listenerList.add(TreeModelListener.class, l);
        }

        public void removeTreeModelListener(TreeModelListener l) {
            listenerList.remove(TreeModelListener.class, l);
        }

        public Object getChild(Object parent, int index) {
            String id = (String)((FolderImpl)parent).children.get(index);
            try {
                return getFolder(id);
            } catch (IOException e) {
                logger.error(e);
                throw new RuntimeException(e);
            }
        }

        public int getIndexOfChild(Object parent, Object child) {
            FolderImpl p = (FolderImpl)parent;
            FolderImpl c= (FolderImpl)child;
            return p.children.indexOf(c.key);
        }


        public void valueForPathChanged(TreePath path, Object newValue) {
            // doesn't apply - this isn't a user-editable tree.
        }
    }
    
    
    
    private static class Messages extends AbstractTableModel implements TableModel {

        private Messages(RecordManager rec) {
            this.rec = rec;
            this.messageList = new ArrayList();
            this.comp = new LongComparator();
            this.df = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.SHORT,SimpleDateFormat.SHORT);
        }
        private final DateFormat df;
        private final RecordManager rec;
        private final List messageList; // the actual model.
        private final Comparator comp;
        private BTree currentFolder = null;
        public void displayFolder(String key) throws IOException {
            this.currentFolder = findStoreFor(key);
            messageList.clear();
            populateList(this.currentFolder,messageList);
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {               
             fireTableDataChanged(); 
                }
            });
         }
                
        private BTree findStoreFor(String id) throws IOException {
            long code = rec.getNamedObject(id);
            if (code == 0) {
                BTree b= BTree.createInstance(rec,comp);
                rec.setNamedObject(id,b.getRecid());
                return b;
            } else {
                return BTree.load(rec,code);
            }
        }
        private void populateList(BTree b,List l) throws IOException {
            TupleBrowser tb = b.browse();
            Tuple t = new Tuple();
            while (tb.getNext(t)) {
                l.add(t.getValue());
            }
            
        }
 
        public org.astrogrid.desktop.modules.background.MessageRecorderImpl.Message[] listFolder(String key) throws IOException {
            List l = new ArrayList();
            BTree b = findStoreFor(key);
            populateList(b,l);
            return (Message[])l.toArray(new Message[]{});
        }

        public Message getMessage(int row) throws IOException {
            return (Message)messageList.get(row);
        }

        public synchronized void deleteFolder(String key) throws IOException {
            long code = rec.getNamedObject(key);
            if (code == 0) { 
                return ; // not there.
            }
            rec.delete(code);
            currentFolder = null;
            messageList.clear();
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {               
            fireTableDataChanged();
                }
            });
        }
        
        public synchronized void addMessage(String id,Message m) throws IOException {
            BTree b = findStoreFor(id);
            final int oldSize = b.size();
            Long key = new Long(System.currentTimeMillis()); 
            // check key is free.
            while (b.find(key) != null) {
                key = new Long(key.longValue() + 1); // scan forwards.
            }
            ((MessageImpl)m).key = key;
            b.insert(key,m,false);
            rec.commit();
            if (currentFolder != null && b.getRecid() == currentFolder.getRecid()) {
                messageList.add(m);
                SwingUtilities.invokeLater(new Runnable() {
                    public void run() {                   
                fireTableRowsInserted(oldSize,oldSize);
                    }
                });
            }
        }
        
        public synchronized void updateMessage(Message m) throws IOException {
            currentFolder.insert(((MessageImpl)m).key,m,true);            
            rec.commit();
            // probably will have updated messageList already, due to aliasing. howver, to be sure..
            final int pos = messageList.indexOf(m);
            messageList.set(pos,m);
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {               
            fireTableRowsUpdated(pos,pos);
                }
            });
        }
        
        public synchronized void deleteMessage(final int row) throws IOException {
            MessageImpl msg = (MessageImpl)messageList.remove(row);
            currentFolder.remove(msg.key);
            rec.commit();
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {               
            fireTableRowsDeleted(row,row);
                }
            });
        }
                
        // table model methods.
        public int getColumnCount() {
            return 2; 
        }
        
        public int getRowCount() {
            return messageList.size();
        }

        public Object getValueAt(int rowIndex, int columnIndex) {
            Message m = (Message)messageList.get(rowIndex);
            switch (columnIndex) {
                case 1: return df.format(m.getTimestamp());
                case 0:return m.getSummary();
               default:
                   return null;
            }
        }
        
     
        public Class getColumnClass(int columnIndex) {
            switch (columnIndex) {
                case 1: return String.class;
                case 0: return String.class;
                default: return null;
            }
        }
        public String getColumnName(int column) {
            switch(column) {
                case 1: return "Date";
                case 0: return "Subject";
                default: return "";
            }
        }
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            return false;
        }
        public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
            // does nothing - not editable.
        }
    }
    
    /** user-object for folders used to store alerts. */
    public static class AlertFolderSummary implements Serializable {
        public AlertFolderSummary(String label) {
            this(label,0);
        }
        public AlertFolderSummary(String label, int unread) {
            this.label = label;
            this.unread = unread;
        }
        public int unread;
        public final String label;
                
        public String toString() {
            if (unread == 0) {
                return label;
            } else {
                return "<html><b>" + label + " (" + unread + ")</b></html>";
            }
        }
    }
    
    /** simple recorder - listens to all alert messages
     * expects them to be text messages
     * @author Noel Winstanley nw@jb.man.ac.uk 26-Oct-2005
     *
     */
    private class AlertRecorder implements MessageListener {

        public void onMessage(javax.jms.Message arg0) {
            try {
                //@todo update once format of alert messages is known.
            if (arg0 instanceof TextMessage) {
                TextMessage t = (TextMessage)arg0;
                MessageImpl m = new MessageImpl(
                        t.getStringProperty("summary")
                        ,t.getText(), new Date(t.getJMSTimestamp()));
                String id = t.getStringProperty("level");
                id = id == null ? "info" : id;
                // check the folder exists, creating if necessary..
                Folder f = folders.getFolder(id);
                if (f == null) {
                    f = folders.createFolder(ALERTS,id);
                    f.setUserObject(new AlertFolderSummary(id,1));
                } else {
                    ((AlertFolderSummary)f.getUserObject()).unread++;
                }
                folders.updateFolder(f);                
                messages.addMessage(id,m);
            } else {
                logger.warn("Unrecognized message type " + arg0.toString());
            }
            } catch (JMSException e) {
                logger.error("Failed to process message",e);
            } catch (IOException e) {
                logger.error("Failed to persist message",e);
            }
        }
    }
    
    /** user object used for folders that contain cea-tasks. */
    public static class TaskFolderSummary implements Serializable {
        public TaskFolderSummary(String label) {
            this(label,ExecutionInformation.UNKNOWN);
        }
        public TaskFolderSummary(String label, String phase) {
            this.label = label;
            this.phase = phase;
        }
        private final String label;
        public String phase;
        public String toString() {
            StringBuffer sb = new StringBuffer("<html>");
            if (phase == null || phase.equals(ExecutionInformation.UNKNOWN)) {
                sb.append("<font style='color:blue'>");
            }else if (ExecutionInformation.ERROR.equals(phase)) {
                    sb.append("<font style='color:red'>");
            } else if(ExecutionInformation.INITIALIZING.equals(phase)) {              
                    sb.append("<font style='color:blue'>"); 
            } else if (ExecutionInformation.PENDING.equals(phase)) {              
                sb.append("<font style='color:blue'>"); 
            } else if (ExecutionInformation.RUNNING.equals(phase)) {               
                    sb.append("<font style='color:green'>"); 
            } else {
                    sb.append("<font>"); // nothing
            }
            sb.append(StringUtils.abbreviate(label,label.length()-1,20));            
            sb.append("</font></html>");
            return sb.toString();
        }
        
    }
    
    /** records all events on the user's queue */
    private class EventRecorder implements MessageListener {

        //@todo problem for long-running applicaitions, or apps running over midnight -fix later.
        private final String today;       
        public EventRecorder() throws IOException {          
             DateFormat df = SimpleDateFormat.getDateInstance(SimpleDateFormat.SHORT);
             today = df.format(new Date());            
            Folder todayFolder = folders.getFolder(today);
                if (todayFolder == null) { // not yet been created
                    todayFolder = folders.createFolder(TASKS,today);
                }                       
        }
            
        
        public void onMessage(javax.jms.Message arg0) {
            try {
                MessageImpl m;
                String id = arg0.getStringProperty("cea_application_id");
                String type = arg0.getStringProperty("type");
                Date d = new Date(arg0.getJMSTimestamp());
                Folder f = folders.getFolder(id);
                if (f == null) { // create a folder dated today, and place another wihitin it.
                    String name= arg0.getStringProperty("cea_application_name");
                    f = folders.createFolder(today,id);
                    f.setUserObject(new TaskFolderSummary(name));
                    folders.updateFolder(f);
                }
                if (arg0 instanceof TextMessage) { // results probably
                    TextMessage t = (TextMessage)arg0;          
                    //@todo style results as a table, format interesting args.
                    m = new MessageImpl(type,t.getText(),d); 
                } else if (arg0 instanceof MapMessage) {
                    MapMessage map = (MapMessage)arg0;
                    StringBuffer sb = new StringBuffer();
                    sb.append("<dl>");
                    for (Enumeration e = map.getMapNames(); e.hasMoreElements(); ) {
                        String key = (String)e.nextElement();
                        sb.append("<dt>").append(key).append("</dt>");
                        sb.append("<dd>").append(map.getString(key)).append("</dd>");                       
                    }
                    sb.append("</dl>");
                    m = new MessageImpl(type,sb.toString(),d);
                    if (type.equals("status-change")) {
                        ((TaskFolderSummary)f.getUserObject()).phase = map.getString("phase"); 
                        folders.updateFolder(f);
                    }
                } else {
                    logger.warn("Unrecognized message type " + arg0.toString());
                    return;
                }
                messages.addMessage(id,m);
            } catch (JMSException e) {
                logger.error("Failed to process message",e);
            } catch (IOException e) {
                logger.error("Failed to persist message",e);
            }
        }
    }

    public void start() {
        try {         
        m.addAlertSubscriber(new AlertRecorder());
        m.addEventProcessor(null,new EventRecorder());// null == all events.
        } catch (Exception e) {
            logger.error("COuld not start recorder",e);
        }
    }

    public void stop() {

    }

}


/* 
$Log: MessageRecorderImpl.java,v $
Revision 1.2  2005/11/02 09:29:51  nw
minor bug fix

Revision 1.1  2005/11/01 09:19:46  nw
messsaging for applicaitons.
 
*/