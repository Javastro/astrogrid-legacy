/*$Id: MessageRecorderImpl.java,v 1.1 2005/11/10 12:05:43 nw Exp $
 * Created on 25-Oct-2005
 *
 * Copyright (C) AstroGrid. All rights reserved.
 *
 * This software is published under the terms of the AstroGrid 
 * Software License version 1.2, a copy of which has been included 
 * with this distribution in the LICENSE.txt file.  
 *
**/
package org.astrogrid.desktop.modules.ag;

import org.astrogrid.acr.astrogrid.ApplicationInformation;
import org.astrogrid.acr.astrogrid.ExecutionInformation;
import org.astrogrid.acr.astrogrid.ExecutionMessage;
import org.astrogrid.acr.astrogrid.ParameterBean;
import org.astrogrid.acr.astrogrid.Registry;
import org.astrogrid.acr.astrogrid.ResourceInformation;
import org.astrogrid.acr.ivoa.SiapInformation;
import org.astrogrid.acr.nvo.ConeInformation;
import org.astrogrid.acr.system.SystemTray;
import org.astrogrid.applications.beans.v1.cea.castor.MessageType;
import org.astrogrid.applications.beans.v1.cea.castor.ResultListType;
import org.astrogrid.applications.beans.v1.parameters.ParameterValue;
import org.astrogrid.desktop.modules.ag.recorder.FolderImpl;
import org.astrogrid.desktop.modules.ag.recorder.Folders;
import org.astrogrid.desktop.modules.ag.recorder.MessageContainerImpl;
import org.astrogrid.desktop.modules.ag.recorder.Messages;
import org.astrogrid.desktop.modules.ag.recorder.ResultsExecutionMessage;
import org.astrogrid.desktop.modules.ag.recorder.StatusChangeExecutionMessage;
import org.astrogrid.desktop.modules.background.ConeApplicationDescription;
import org.astrogrid.desktop.modules.background.SiapApplicationDescription;
import org.astrogrid.desktop.modules.system.StoreInternal;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.exolab.castor.xml.CastorException;
import org.exolab.castor.xml.MarshalException;
import org.exolab.castor.xml.ValidationException;
import org.picocontainer.Startable;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.MessageListener;
import javax.jms.TextMessage;
import javax.swing.table.TableModel;
import javax.swing.tree.TreeModel;

/** Implementation a message recorder - main consumer of  JMS messages from the 
 * event notification queue.
 * Collates and records them to a persistent store.
 * datastructures used are in the 'recorder' sub-package. this class defines the message listeners
 * that receive the messages, and the public api.
 * @author Noel Winstanley nw@jb.man.ac.uk 25-Oct-2005
 * @todo later match up event recorder with events being generated by the bridge.
 */
public class MessageRecorderImpl implements Startable, MessageRecorderInternal{

    static final Log logger = LogFactory.getLog(MessageRecorderImpl.class);

    public MessageRecorderImpl(MessagingInternal m, StoreInternal store, Registry reg) throws IOException {
        super();
        this.m = m;
        this.reg= reg;

        this.folders = Folders.findOrCreate(store.getManager());
        this.messages = new Messages(store.getManager());
    }
    protected final Registry reg;
    protected final MessagingInternal m;
    protected final Folders folders;
    protected final Messages messages;

    public TreeModel getFolderList() {
        return folders;
    }
    
    public URI[] listLeaves() throws IOException {
        return folders.listLeaves();
    }
    
    public Folder getFolder(URI id) throws IOException {
        return folders.getFolder(id);
    }
    
    public TableModel getMessageList() {
        return messages;
    }
    
    public void deleteFolder(Folder f) throws IOException {
        folders.deleteFolder(f);
        messages.deleteFolder(((FolderImpl)f).getKey());
    }
    
    public void displayMessages(Folder f) throws IOException {
        messages.displayFolder(((FolderImpl)f).getKey());
    }
    
    public void deleteMessage(int row) throws IOException {
        messages.deleteMessage(row);
    }
    
    public MessageContainer getMessage(int row) {
        return messages.getMessage(row);
    }
    
    public void updateMessage(MessageContainer m) throws IOException {
        messages.updateMessage(m);
    }
    
    public void updateFolder(Folder f) throws IOException {
        folders.updateFolder(f);
    }
    
    public MessageContainer[] listFolder(Folder f) throws IOException{
        return messages.listFolder(((FolderImpl)f).getKey());
    }
       
    // id keys for well-known folders.
    public static URI ROOT ;
        public static URI ALERTS ;
        public static URI TASKS;
        public static URI QUERIES;
        public static URI JOBS;
static {
    try {
 ROOT = new URI("folder:root");
 ALERTS = new URI("folder:alerts");
 TASKS =  new URI("folder:tasks");
 QUERIES = new URI("folder:queries");
 JOBS = new URI("folder:jobs");
    } catch (URISyntaxException e) {
        logger.fatal("Programming error - failed to initialize folder constants",e);
    }
}
    /** simple recorder - listens to all alert messages
     * expects them to be text messages
     * @author Noel Winstanley nw@jb.man.ac.uk 26-Oct-2005
     *
     */
    private class AlertRecorder implements MessageListener {

        public void onMessage(javax.jms.Message arg0) {
            try {
            if (arg0 instanceof TextMessage) {
                TextMessage t = (TextMessage)arg0;
                ExecutionMessage msg = parseMessage(t.getText());
                MessageContainerImpl m = new MessageContainerImpl(
                        t.getStringProperty(MessageUtils.SUMMARY_PROPERTY)
                        ,msg);
                FolderImpl f = (FolderImpl) folders.getFolder(ALERTS);
                // must always be here.
                f.setUnreadCount(f.getUnreadCount()+1);
                folders.updateFolder(f);                
                messages.addMessage(ALERTS,m);
                notifyMessageReceived(f,m);
            } else {
                logger.warn("Unrecognized message type " + arg0.toString());
            }
            } catch (JMSException e) {
                logger.error("Failed to process message",e);
            } catch (CastorException e) {
                logger.error("Failed to parse message",e);
            } catch (IOException e) {
                logger.error("Failed to persist message",e);
            }
        }
    }
    
    //deserialize xmlstring to Message, then copy across to an execution message
    private ExecutionMessage parseMessage(String s) throws CastorException {
        Reader r = new StringReader(s);
        MessageType mt= MessageType.unmarshalMessageType(r);
        return new ExecutionMessage(
                mt.getSource()
                ,mt.getLevel().toString()
                ,mt.getPhase().toString()
                ,mt.getTimestamp()
                ,mt.getContent()
                );
    }
    
    private Map parseResultMap(String s) throws CastorException {
        Reader r = new StringReader(s);
        ResultListType rs = ResultListType.unmarshalResultListType(r);
        Map result = new HashMap();        
        for (int i =0 ; i < rs.getResultCount(); i++) {
            ParameterValue val = rs.getResult(i);
            result.put(val.getName(),val.getValue());
        }
        return result;
    }
    
    /** records all events on the user's queue */
    private class NotificationRecorder implements MessageListener {

        public NotificationRecorder() throws IOException {          
             DateFormat df = SimpleDateFormat.getDateInstance(SimpleDateFormat.SHORT);
                  
        }
        
        private boolean isAdqlApplication(ResourceInformation ri) {
            if (! (ri instanceof ApplicationInformation) ) {
                return false;
            }
            ApplicationInformation app = (ApplicationInformation)ri;
            for (Iterator i = app.getParameters().values().iterator(); i.hasNext(); ) {
                ParameterBean pb = (ParameterBean)i.next();
                if ("adql".equalsIgnoreCase(pb.getType())) {
                    return true;
                }
            }
            return false;
        }
        
        private Folder createFolderFor(URI id, javax.jms.Message msg) throws JMSException, IOException {
            // a little hacky - relies on parsing the uri to know what kind of thing we're dealing with.
            // so only works for known uri types.
            URI parent = TASKS;
            if ("jes".equals(id.getScheme())) {
                parent = JOBS;
            } else {
                // assume it's a cea id...
                //@todo come back to this - may need to parse the id a little.
                try {
                ResourceInformation ri = reg.getResourceInformation(id);
                if (ri instanceof SiapInformation 
                        || ri instanceof ConeInformation
                        || isAdqlApplication(ri)) {
                    parent = QUERIES;
                }
                } catch (Exception e) {
                    //oh well, never mind;
                }
            }
            
            String name= msg.getStringProperty(MessageUtils.PROCESS_NAME_PROPERTY);           
            Date startDate = msg.getStringProperty(MessageUtils.START_TIME_PROPERTY) != null
                ? new Date(msg.getStringProperty(MessageUtils.START_TIME_PROPERTY))
                : new Date(msg.getJMSTimestamp());
            Date endDate =msg.getStringProperty(MessageUtils.END_TIME_PROPERTY) != null // unlikely, but still..
                ? new Date(msg.getStringProperty(MessageUtils.END_TIME_PROPERTY))
                : null;
                        
            ExecutionInformation nfo = new ExecutionInformation(
                    id
                    ,name
                    ,"" //@todo get descirption from somewhere.
                    , ExecutionInformation.UNKNOWN
                    ,startDate
                    ,endDate);
            return folders.createFolder(parent,nfo);
        }
        
        public void onMessage(javax.jms.Message arg0) {
            try {
                URI id = new URI(arg0.getStringProperty(MessageUtils.PROCESS_ID_PROPERTY));
                String type = arg0.getStringProperty(MessageUtils.MESSAGE_TYPE_PROPERTY);
                Folder f = folders.getFolder(id);
                if (f == null) {
                    f = createFolderFor(id,arg0);
                }
                if (arg0 instanceof TextMessage) { 
                    TextMessage t = (TextMessage)arg0;         
                    ExecutionMessage msg= null;
                    if (type.equals(MessageUtils.RESULTS_MESSAGE)) {
                        msg = new ResultsExecutionMessage(
                        id.toString()
                        ,new Date(t.getJMSTimestamp())
                        ,parseResultMap(t.getText())
                        );

                    } else if (type.equals(MessageUtils.STATUS_CHANGE_MESSAGE)) {
                        msg = new StatusChangeExecutionMessage(
                                id.toString()
                                ,t.getText()
                                ,new Date(t.getJMSTimestamp())
                                );                        
                        ExecutionInformation orig = f.getInformation();
                        f.setInformation(new ExecutionInformation(
                                orig.getId()
                                ,orig.getName()
                                ,orig.getDescription()
                                ,t.getText()
                                , t.getStringProperty(MessageUtils.START_TIME_PROPERTY) != null
                                   ? new Date(t.getStringProperty(MessageUtils.START_TIME_PROPERTY))
                                   : orig.getStartTime()
                                , t.getStringProperty(MessageUtils.END_TIME_PROPERTY) != null
                                   ? new Date(t.getStringProperty(MessageUtils.END_TIME_PROPERTY))
                                   : orig.getFinishTime()        
                                ));
                    } else { // hope for the best
                        msg = parseMessage(t.getText());
                    }
                    MessageContainer m = new MessageContainerImpl(type,msg); 
                    f.setUnreadCount(f.getUnreadCount()+1);
                    folders.updateFolder(f);                                
                    messages.addMessage(id,m);
                    notifyMessageReceived(f,m);
                } else {
                    logger.warn("Unrecognized message type " + arg0.toString());
                    return;
                }
            } catch (JMSException e) {
                logger.error("Failed to process message",e);
            } catch (IOException e) {
                logger.error("Failed to persist message",e);
            } catch (URISyntaxException e) {
                logger.error("Failed to process message",e);
            } catch (CastorException e) {
                logger.error("Failed to parse message",e);
            }
        }
    }

   

    public void start() {
        try {         
        m.addAlertSubscriber(new AlertRecorder());
        // this condition should catch all messages - but leaves options open in the future.
        m.addEventProcessor(MessageUtils.PROCESS_ID_PROPERTY +" is not null",new NotificationRecorder());
        } catch (Exception e) {
            logger.error("COuld not start recorder",e);
        }
    }

    public void stop() {

    }

    private Set listeners =  new HashSet();
    public void addRecorderListener(RecorderListener listener) {
        listeners.add(listener);
    }

    public void removeRecorderListener(RecorderListener listener) {
        listeners.remove(listener);
    }
    
    private void notifyMessageReceived(Folder f, MessageContainer c) {
        for (Iterator i = listeners.iterator(); i.hasNext(); ) {
            RecorderListener rl = (RecorderListener)i.next();
            rl.messageReceived(f,c);
        }
    }

}


/* 
$Log: MessageRecorderImpl.java,v $
Revision 1.1  2005/11/10 12:05:43  nw
big change around for vo lookout

Revision 1.2  2005/11/02 09:29:51  nw
minor bug fix

Revision 1.1  2005/11/01 09:19:46  nw
messsaging for applicaitons.
 
*/