//-------------------------------------------------------------------------
// FILE: XmlToNativeDomImpl.java
// PACKAGE: org.astrogrid.ace.utils
//
// DATE       AUTHOR    NOTES
// ----       ------    -----
// 14/10/02   KEA       Initial prototype
// 04/12/02   KEA       Revised to deal with new Ace Schema (v.1_0).
//                      NB this is an interim release.
// 13/12/02   KEA       Added support for new "Wavelength" XML tag
//-------------------------------------------------------------------------


package org.astrogrid.ace.utils;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;

import org.apache.xerces.parsers.DOMParser;
import org.xml.sax.InputSource;

import java.util.Map;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.Vector;

import java.io.Reader;
import java.io.Writer;


/**
 * <p>DOM-parser based implementation of file format converter for 
 * conversions from Ace XML format to SExtractor native parameter 
 * files.
 *
 * <p>This version uses the Xerces DOM parser;  an alternative 
 * would be to try IBM's xml4j (a progenitor of Xerces but
 * undergoing separate development).
 *
 * <p> In this interim version, the following output catalog vector
 * parameters <strong>are</strong> supported:
 * <ul>
 * <li> MAG_APER(n) </li>
 * <li> MAGERR_APER(n) </li>
 * <li> FLUX_APER(n) </li>
 * <li> FLUXERR_APER(n) </li>
 * </ul>
 *
 * but the following output catalog vector parameters are
 * <strong>not</strong> supported:
 *
 * <ul>
 * <li> VECTOR_SOMFIT(n) </li>
 * <li> VECTOR_ASSOC(n) </li>
 * <li> FLUX_GROWTH(n) </li>
 * <li> VIGNET(m,n) </li>
 * <li> VIGNET_SHIFT(m,n) </li>
 * </ul>
 *
 *
 * <p>See Translator.java for a usage example, and Tester.java 
 * for a run-time test harness.
 * 
 * <p>TO DO:  <ul>
 * <li>Handle <strong>all</strong>SExtractor vector catalog parameters, 
 *  not just a subset.</li>
 * <li>Nicer exception-throwing and handling?</li>
 * </ul>
 *
 *
 * @see org.astrogrid.ace.utils.XmlToNativeIfc
 * @see org.astrogrid.ace.utils.Translator 
 * @see org.astrogrid.ace.utils.Tester 
 * 
 * @author Kona Andrews,
 * <a href="mailto:kea@ast.cam.ac.uk">kea@ast.cam.ac.uk</a>
 * @version 1.0
*/
public class XmlToNativeDomImpl implements XmlToNativeIfc
{
	// Utility variable for calculating vector values for certain
	// output parameters.
	//
	private int numPhotApertures = -1;

	/**
	 * Dummy constructor - does nothing.
	 */
	 public XmlToNativeDomImpl()
	 {
	 }

	/**
	 * Parses ACE XML input into a DOM tree.
	 * 
	 * @param xmlIn  A (pre-initialised) reader for the input XML
	 *
	 * @return  A Document containing the DOM tree for the input XML.
	 */
	 protected Document getDOMTree(Reader inputXML) throws Exception
	 {
		DOMParser parser = new DOMParser();
		try 
		{
			parser.setFeature("http://xml.org/sax/features/namespaces", false);
			parser.setFeature(
				"http://apache.org/xml/features/dom/include-ignorable-whitespace",
				false);
		}
		catch (Exception e) 
		{
			throw new Exception(
			"\nThis parser cannot process a requested feature: \n"
			+ e.getMessage());
		}
		parser.parse(new InputSource(inputXML));
		return parser.getDocument();
	 }
	
	/**
	 * Converts Ace XML input to SExtractor output (configuration
	 * file *.sex and catalog parameter file *.param).
	 * 
	 * Parses the Ace XML input into a DOM Tree, then traverses this
	 * tree to produce the configuration and catalog parameter files.
	 * 
	 * @param xmlIn  A (pre-initialised) reader for the input XML
	 *
	 * @param configOutWriter  A (pre-initialised) writer for the output 
	 *     SExtractor *.sex * file.
	 *
	 * @param catalogOutWriter  A (pre-initialised) writer for the output 
	 *     SExtractor *.param file.
	 */
	public void makeNative(Reader xmlIn, Writer configOutWriter, 
										Writer catalogOutWriter) throws Exception
	{
		Document document = getDOMTree(xmlIn);
		Map configMap = new TreeMap();
		numPhotApertures = -1;

		configOutWriter.write(
			"# Generated by org.astrogrid.ace.utils - DOM implementation\n");
		catalogOutWriter.write(
			"# Generated by org.astrogrid.ace.utils - DOM implementation\n"
			+ "#!WARNING! - "
			+ "This interim release does not support any vector parameters\n"	
			+ "#   except MAG_APER, MAG_APERERR, FLUX_APER AND FLUX_APERERR."
			);

		// Get all children of the root element (AceInputDoc) for processing
		//
		NodeList nodeList = (document.getDocumentElement()).getChildNodes();
		for (int i = 0; i < nodeList.getLength(); i++) 
		{
			if (nodeList.item(i).getNodeType() == Node.ELEMENT_NODE) 
			{
				Element paramNode = (Element)(nodeList.item(i));
				
            String tagName = paramNode.getTagName();

            // Check if we have a catalog parameter
				//
            if ( tagName.equals("OUTPUT_COLUMNS") )
				{
					doCatalogParameter(paramNode, document.getDocumentElement(),
							catalogOutWriter);
				}
				// Check if we have an ignorable command-line parameter 
				//
            else if ( !(tagName.equals("ImageToCatalog")) && 
	                   !(tagName.equals("ImageToMeasure")) &&
							 !(tagName.equals("Wavelength")) )
				{
					// Not command-line param, so have a config parameter
					// See if this is a multi-argument parameter
					//
					NodeList args = 
						paramNode.getElementsByTagName("arg");

					if (args.getLength() == 0) 
					{
						throw new Exception("Error - missing <arg> for parameter "
								+ paramNode.getTagName());
					}
					
					String tagString = 
						args.item(0).getFirstChild().getNodeValue();

					for (int j = 1; j < args.getLength(); j++) 
					{
						tagString = 
							tagString + ", " + 
							args.item(j).getFirstChild().getNodeValue();
					}
					configMap.put(paramNode.getTagName(),tagString);
				}
			}
		}
		// Now convert config parameters to native format 
		//   (catalog parameters all dealt with already).

		// First of all, get length of longest keyword (for pretty-printing)
		//
		int maxLen = 0;
		Iterator iterator;
		for (iterator = configMap.entrySet().iterator(); iterator.hasNext(); ) 
		{
			Map.Entry me = (Map.Entry)iterator.next();
			int len = ((String)me.getKey()).length();
			if (maxLen < len) 
			{
				maxLen = len;
			}
      }

		// Now write all keywords/values to output in native format
		//
		for (iterator = configMap.entrySet().iterator(); iterator.hasNext(); ) 
		{
			Map.Entry me = (Map.Entry)iterator.next();
			String tagname = (String)me.getKey();
			String value = (String)me.getValue();

			int numSpaces = maxLen - tagname.length();

			// Write tag name and pretty-printing spaces
			configOutWriter.write(tagname + "   ");
			//System.out.print(tagname + "   ");
			
			for (int j = 0; j < numSpaces; j++) 
			{
				configOutWriter.write(" ");
				//System.out.print(" ");
			}

			// Booleans are a special case (native format uses Y/N)
			String paramVal = value.trim();
			if (paramVal.equalsIgnoreCase("true")) 
			{
				configOutWriter.write("Y" + "\n");
				//System.out.print("Y" + "\n");
			}
			else if (paramVal.equalsIgnoreCase("false")) 
			{
				configOutWriter.write("N" + "\n");
				//System.out.print("N" + "\n");
			}
			else 
			{
				// All else than boolean parameters
				configOutWriter.write(value + "\n");
				//System.out.print(value + "\n");
			}
		}
	}


	protected void doCatalogParameter(Element paramNode, Element rootNode,
											 Writer catalogOutWriter) throws Exception

	/**
	 * Traverses a DOM ELement node containing an Ace XML catalog 
	 * parameter and writes the equivalent native catalog parameter 
	 * to the * SExtractor catalog parameter file (*.param).
	 *
	 * @param element  The DOM element containing the Ace catalog parameter.
	 *
	 * @param element  The DOM element that is the root of the input
	 * document.
	 *
	 * @param catalogOutWriter  A (pre-initialised) writer for the output 
	 *     SExtractor *.param file.
	 *
	 * @throws Exception if inconsistencies between configuration and
	 * catalog parameters are encountered.
	 */
	{	
		String tagName = paramNode.getTagName();
		NodeList args = paramNode.getElementsByTagName("arg");
		for (int i = 0; i < args.getLength(); i++) 
		{
			String tagname = args.item(i).getFirstChild().getNodeValue();

			// Check for currently unsupported keyword names (vector keywords)
			// 
			if ( (tagname.equals("FLUX_APER")) ||
				  (tagname.equals("FLUXERR_APER")) ||
				  (tagname.equals("MAG_APER")) ||
				  (tagname.equals("MAGERR_APER")) )
			{
				// Currently-supported vector parameters
				// Vector value of these is no. of elements in PHOT_APERTURES
				//
				if (numPhotApertures == -1) // Not set yet
				{
					NodeList photAps =
						rootNode.getElementsByTagName("PHOT_APERTURES");
					if (photAps.getLength() != 1)
					{
						throw new Exception("Error - unexpected number (" 
							+ Integer.toString(photAps.getLength()) 
							+ ") of PHOT_APERTURE tags (expected exactly 1, "
							+ "since output tag " + tagname + " is present.");
					}
					else 
					{
						NodeList photArgs = 
							((Element)photAps.item(0)).getElementsByTagName("arg");
						numPhotApertures = photArgs.getLength();
					}
				}
				catalogOutWriter.write(tagname + "(" + 
						Integer.toString(numPhotApertures) + ")\n");

			}

			else if ( (tagname.equals("VECTOR_SOMFIT")) ||
				  (tagname.equals("VECTOR_ASSOC")) ||
				  (tagname.equals("FLUX_GROWTH")) ||
				  (tagname.equals("VIGNET")) ||
				  (tagname.equals("VIGNET_SHIFT")) ) 

			{
				// Not currently supported vector parameters
				//
				catalogOutWriter.write("#!WARNING! Vector parameter \"" + tagname 
					+ "\" is not supported in this release!\n");
			}
			else 
			{
				catalogOutWriter.write(tagname + "\n");
			}
		}
	}
}
//-------------------------------------------------------------------------
