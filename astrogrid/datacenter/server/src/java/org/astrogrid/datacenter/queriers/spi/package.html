<html>
<body>

<h1>Back-end plugin interface</h1>
This package makes up the interface to the pluggable back end.

<h2>Overview</h2>


Dataservers have to handle more than one possible input query language. Back end Plugins provide
<i>translators</i> for the set of languages they want to accept. The server engine applies
the appropriate translator for each query. This translation generates an <i>intermediate representation</i>
of the query to be performed. The intermediate representation is then passed into the plugin, which performs the
query operation.
<p>
This architecture splits the translation and querying phases of the plugin, hopefully making
it easier to reuse parts when writing new plugins. The details of selecting which language to use are
left to the server engine, simplifying the plugin implementation.
<p>

<h2>Interfaces</h2>
<h3>QuerierSPI</h3>

Back end Plugin implementations should implement the {@link
org.astrogrid.datacenter.queriers.spi.QuerierSPI} interface. This interface defines a set of methods that will be called by
the engine in a fixed order. The plugin lifecycle is as follows:-
<ol>
<li>Instantiate the Plugin object instantiated
<li>Configure the Plugin object<p>
  The {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#receiveWorkspace}
  and {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#receiveConfig} methods are called. This gives the plugin access
  to a configuration object (to look up system parameters), and a workspace (for storing temporary files)
<li>Choose a Translator<p>
  The {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#getTranslatorMap} method is called. This returns a map of the
  query language translators this plugin provides. A translator from the map is chosen, and used to convert the
  input query language into an intermediate object. The class of the intermediate object is down to the plugin implementor
  to decide.
<li>Do the query<p>
  The translated query is passed to the {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#doQuery} method of the plugin.
  The plugin performs the query, and returns results.
<li>Close the plugin<p>
  The engine calls the {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#close} method of the plugin when it has
  finished with the results object returned from the previous step. This is the signal for the plugin to
  close database connections and free any other resources. THe plugin object is now dead and won't be used again.
</ol>
There's also a {@link org.astrogrid.datacenter.queriers.spi.QuerierSPI#getPluginInfo} method, which should return a string
describing the plugin.

<h3>Translator</h3>

A {@link org.astrogrid.datacenter.queriers.spi.Translator} converts between an xml query language and another representation.
The type of this representation is the choice of the plugin developer. A plugin wrapping a database could translate
to a simple SQL string. Other plugin implementations may translate to an data structure that is used to
configure the query engine - like the <i>Command Pattern</i>.
<p>
The plugin's <tt>doQuery()</tt> method accepts an {@link java.lang.Object} parameter. However as the set of
possible translators is defined by the plugin, it has knowledge of what class the intermediate representation
will be. So the first thing the <tt>doQuery()</tt> method will do is cast its parameter from an object to its
expected type.
<p>
Its probably a good idea to have all translators used by a plugin return the same
intermediate type, but this isn't necessary.
<p>
The {@link org.astrogrid.datacenter.queriers.spi.Translator} defines two methods - <tt>translate()</tt>, which
is described above, and <tt>getResultType</tt>. This method is used to sanity-check the plugin - it should
return the Class of the intermediate representation objects it produces. i.e. the following must be true
<code><pre><tt>
  Translator trans;
  Element e;
  trans.getResultType().equals(trans.translate(e);
</tt></pre></code>

<h3>TranslatorMap</h3>
The translator map holds a set of translators, keyed by input language type. The key for a language is
the namespace URNs defined by its schema. Many query languages (XPAth,XQuery,XSLT) already  define a namspace.

<p>
For query languages that lack a namespace we can invent
an id and stick to it. Different language versions should have
different schema, different namespaces too, and so different entries in the translator map.
<p>
We currenly use the following (made up) namespaces
<ul>
<li> http://tempuri.org/adql - our current version of ADQL.
<li> urn:sql - vanilla SQL wrapped in &lt;..&gt; tags.
</ul>


<h3>QueryResults</h3>
Interface around the results produced. Methods of this interface will be called to access the results before the
plugin's <tt>close()</tt> method is called. Once the plugin is closed, the QueryResults object is dead.

<h2>Classes</h2>

<h3>BaseQuerierSPI</h3>
Starter implementation of QuerierSPI. Implements the configuration methods, storing the results in protected
member variables. Plugin writer just needs to implement <tt>doQuery()</tt>, <tt>close()</tt> if needed,
 and populate the translator map.

<h3>IdTranslator</h3>
Dummy translator that returns its {@link org.w3c.dom.Element} parameter unchanged. Useful when no separate translation
stage is needed.

<h3>SimpleTranslatorMap</h3>
Simple implementation of a translator map. should be sufficient for most requirements.
Provides two methods to add bindings to the map.


<h2>Configuration</h2>
To set which back-end to use, set the
<tt>QuerierSPI</tt> property in the <tt>AstroGridConfig</tt> file to the
classname of the plugin class - which must implement the {@link
org.astrogrid.datacenter.queriers.spi.QuerierSPI} interface.

<h2>Examples</h2>
The {@link org.astrogrid.datacenter.queriers.sql} package contains a back-end
plugin that performs queries over a JDBC database.
<p>
The separate <a
href="http://www.astrogrid.org/maven/build/datacenter/multiproject/cdsdelegate/i
ndex.html">CDS Delegate project</a> is a plugin that performs queries by calling
the CDS vizier web services.

<h2>Ideas</h2>

 There needs to be a method to access the translator map, rather than a static member
variable, to give the possibility that map can be constructed dynamically if 
needed. FOr example the set of supported languages could change depending on the 
circumstances of installation.<p>



</body></html>