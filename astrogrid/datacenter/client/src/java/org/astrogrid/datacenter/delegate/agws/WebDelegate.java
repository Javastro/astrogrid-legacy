/*
 * $Id: WebDelegate.java,v 1.25 2004/03/06 19:34:21 mch Exp $
 *
 * (C) Copyright AstroGrid...
 */

package org.astrogrid.datacenter.delegate.agws;

import org.astrogrid.datacenter.delegate.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringBufferInputStream;
import java.net.URL;
import java.rmi.RemoteException;
import java.util.Hashtable;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.rpc.ServiceException;
import org.apache.axis.AxisFault;
import org.apache.axis.utils.XMLUtils;
import org.astrogrid.applications.delegate.ApplicationController;
import org.astrogrid.applications.delegate.beans.ParameterValues;
import org.astrogrid.applications.delegate.beans.SimpleApplicationDescription;
import org.astrogrid.community.Account;
import org.astrogrid.datacenter.adql.ADQLException;
import org.astrogrid.datacenter.adql.ADQLUtils;
import org.astrogrid.datacenter.adql.generated.Circle;
import org.astrogrid.datacenter.adql.generated.Select;
import org.astrogrid.datacenter.adql.generated.TableExpression;
import org.astrogrid.datacenter.adql.generated.Where;
import org.astrogrid.datacenter.axisdataserver.AxisDataServerServiceLocator;
import org.astrogrid.datacenter.axisdataserver.AxisDataServerSoapBindingStub;
import org.astrogrid.datacenter.axisdataserver.types.Query;
import org.astrogrid.datacenter.query.QueryException;
import org.astrogrid.store.Agsl;
import org.astrogrid.store.Msrl;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * A standard AstroGrid datacenter delegate implementation, based on
 * http messaging with an Apache/Tomcat/Axis server.
 * <p>
 * Provides access to 'ADQL-compliant' web services, such as AstroGrid PAL ones
 * and (hopefully?) skynodes when they are implemented.
 *
 * @author M Hill
 * @author Jeff Lusted (from DatasetAgentDelegate)
 */
  
   
public class WebDelegate implements FullSearcher, ConeSearcher, ApplicationController
{
   /** Generated binding code that mirrors the service's methods */
   private AxisDataServerSoapBindingStub binding;
   
   /** User certification */
   private Account user = null;
   
   
   
   /* Returns the metadata
    */
   public Metadata getMetadata() throws RemoteException {
      String metaD = binding.getMetadata(null);
      ByteArrayInputStream is = new ByteArrayInputStream(metaD.getBytes());
      try {
         Document doc = XMLUtils.newDocument(is);
         return new Metadata(doc.getDocumentElement());
      } catch (Exception e) {
         throw new RemoteException("Could not parse document",e);
      }
      
   } //end WebQueryDelegate
   
   
   /** Don't use this directly - use the factory method
    * DatacenterDelegate.makeDelegate() in case we need to create new sorts
    * of datacenter delegates in the future...
    */
   public WebDelegate(Account user, URL givenEndPoint) throws ServiceException
   {
      binding =(AxisDataServerSoapBindingStub) new AxisDataServerServiceLocator().getAxisDataServer( givenEndPoint );
      this.user = user;
   }
   
   /**
    * Sets the timeout for calling the service - ie how long after the initial call
    * is made before a timeout exception is thrown
    */
   public void setTimeout(int givenTimeout) {
      binding.setTimeout(givenTimeout);
   }
   
   
   
   /**
    * Returns the number of items that match the given query.  This is useful for
    * doing checks on how big the result set is likely to be before it has to be
    * transferred about the net.
    * @todo implement this.
    */
   public int countQuery(Element doc) throws DatacenterException
   {
      throw new UnsupportedOperationException();
   }
   
   /**
    * Constructs the query at the
    * server end, but does not start it yet as other Things May Need To Be Done
    * such as registering listeners or setting the destination for the results.
    *
    * @param adql object model
    * @param givenId an id for the query is assigned here rather than
    * generated by the server
    */

   public DatacenterQuery makeQuery(Element queryBody, String givenId) throws IOException
   {
      try
      {
          Query q = new Query();
          q.setQueryBody(queryBody);
          return new WebQueryDelegate(binding,binding.makeQueryWithId(q, givenId));
      }
      catch (QueryException e) { throw new DatacenterException("Illegal Query", e); }
      catch (SAXException e) { throw new DatacenterException("Illegal Query", e); }
   }
   
   /**
    * Constructs the query at the
    * server end, but does not start it yet as other Things May Need To Be Done
    * such as registering listeners or setting the destination for the results.
    *
    * @param adql object model
    */
   
   public DatacenterQuery makeQuery(Element queryBody) throws IOException
   {
      try
      {
         Query q = new Query();
         q.setQueryBody(queryBody);
         return new WebQueryDelegate(binding,binding.makeQuery(q));
      }
      catch (QueryException e) { throw new DatacenterException("Illegal Query", e); }
      catch (SAXException e) { throw new DatacenterException("Illegal Query", e); }
   }
   
   /**
    * Simple blocking query.
    * @param user user information for authentication/authorisation
    * @param resultsformat string specifying how the results will be returned (eg
    * votable, fits, etc) strings as given in the datacenter's metadata
    * @param ADQL
    */
   public DatacenterResults doQuery(String resultsFormat, Element queryBody) throws DatacenterException
   {
      try {
         //run query on server
         Query q = new Query();
         q.setQueryBody(queryBody);
         String result = binding.doQuery(resultsFormat, q);
         InputStream is = new ByteArrayInputStream(result.getBytes());
         Document rDoc = XMLUtils.newDocument(is);
         
         //extract results to DatacenterResults
         //only one type for It03 servers - votable
         return new DatacenterResults(rDoc.getDocumentElement());
         
      }
      catch (DatacenterException e) {
         throw e;
      }
      catch (AxisFault e) {
         throw new DatacenterException(e.getMessage(), e);
      }
      catch (Exception e) {
         throw new DatacenterException(e.getMessage(), e);
      }
   }
   
   /**
    * ConeSearcher implementation.  Creates ADQL from the parameters that can
    * be submitted to the service.
    *
    * @param ra Right Ascension in decimal degrees, J2000
    * @param dec Decliniation in decimal degress, J2000
    * @param sr search radius in decimal degrees.
    * @return InputStream to results document, including votable
    * @todo fix botch around returning votable as stream.
    */
   
   public InputStream coneSearch(double ra, double dec, double sr) throws IOException {
      
      try
      {
         Select s = ADQLUtils.buildMinimalQuery();
         TableExpression tc = new TableExpression();
         s.setTableClause(tc);
         
         Where w = new Where();
         tc.setWhereClause(w);
         
         Circle c = new Circle();
         c.setDec(ADQLUtils.mkApproxNum(dec));
         c.setRa(ADQLUtils.mkApproxNum(ra));
         c.setRadius(ADQLUtils.mkApproxNum(sr));
         w.setCircle(c);

         
         DatacenterResults results = doQuery(VOTABLE, ADQLUtils.toQueryBody(s));
         
         //bit of a botch at the moment - converts VOTable back into string/input stream for returning...
         //best way to fix is properly to pipe it - still not quite right but less
         //memory
         String xmlDoc = XMLUtils.DocumentToString(results.getVotable().getOwnerDocument());
         
         return new ByteArrayInputStream(xmlDoc.getBytes());
      }
       catch (ADQLException e) {
         throw new DatacenterException("Invalid ADQL created from cone search parameters",e);
      }
   }
   

 
   
   /**
    * ApplicationController implemenation: returns a list of the services that this application delegate can handle
    */
   public String[] listApplications() {
      
      return new String[] { "Astrogrid Datacenter", "NVO Cone Search" };
   }
   
   /**
    * ApplicationController implemenation: Returns a reference to the application description
    */
   public SimpleApplicationDescription getApplicationDescription(String applicationID)  {

      SimpleApplicationDescription description = new SimpleApplicationDescription();
      
      description.setName("Datacenter");
//    description.setXmlDescriptor(getMetadata().toString());
      
      return description;
   }

   /** Index of queries for use by ApplicationControllers.  This is not thought
    * through properly, as it counts on the calling code using the same delegate
    * to access the query... */
   private static Hashtable queries = new Hashtable();
   
   /**
    * ApplicationController implemenation: Initialises a query, returning the query id.
    * Parameter Values should include the location of the query, and where the
    * results are to be placed.
    *
    */
   public String initializeApplication(String applicationID, String jobstepID, String jobMonitorURL,
                                       org.astrogrid.applications.delegate.beans.User user, ParameterValues parameters) {
      
      try {
         Document doc = null;
         
         //extract query, results etc
         try {
            doc = XMLUtils.newDocument(new StringBufferInputStream(parameters.getParameterSpec()));
         }
         catch (SAXException e) { throw new IllegalArgumentException("Parameters not valid xml: "+e); }
         catch (ParserConfigurationException e) { throw new RuntimeException(e); }
         
         
         NodeList elements = doc.getElementsByTagName("parameter");
         
         String queryUri = null;
         String resultsDestinationUri = null;
         
         
         //look through parameters, find query and results destination
         for (int i=0;i<elements.getLength();i++) {
            Node n = elements.item(i);
            String name = n.getAttributes().getNamedItem("name").getNodeValue();
            
            if (name.toLowerCase().equals("querymyspacereference")) { //deprecate this
               queryUri = n.getFirstChild().getNodeValue();
            }
            else if (name.toLowerCase().equals("queryvospacerl")) {
               queryUri = n.getFirstChild().getNodeValue();
            }
            else if (name.toLowerCase().equals("resultsmyspacereference")) {//deprecate this
               resultsDestinationUri = n.getFirstChild().getNodeValue();
            }
            else if (name.toLowerCase().equals("resultsvospacerl")) {
               resultsDestinationUri = n.getFirstChild().getNodeValue();
            }
            else {
               throw new IllegalArgumentException("Unknown parameter '"+name+"'");
            }
         }

         assert queryUri != null : "Query URI not givem in parameters";
         assert resultsDestinationUri != null : "Results Destination URI not given in parameters";

         //check that query reference resolves OK
         if (Agsl.isAgsl(queryUri))
         {
            queryUri = new Agsl(queryUri).resolveURL().toString();
         }
         else if (Msrl.isMsrl(queryUri))
         {
            queryUri = new Msrl(queryUri).resolveURL().toString();
         }
         else
         {
            queryUri = new URL(queryUri).toString();
         }
         
         //Transform to the right types
         Select adql = null;
         try {
            //load query
            Document adqlDoc = XMLUtils.newDocument(queryUri);
            //validate it really is adql
            adql = ADQLUtils.unmarshalSelect(adqlDoc);
         }
         catch (SAXException e) { throw new IllegalArgumentException("Query at '"+queryUri+"' not valid xml: "+e); }
         catch (ADQLException e) { throw new IllegalArgumentException("Query at '"+queryUri+"' not valid adql: "+e); }
         catch (ParserConfigurationException e) { throw new RuntimeException(e); }
         
         WebQueryDelegate query = (WebQueryDelegate) makeQuery(ADQLUtils.toQueryBody(adql), jobstepID);
         
         queries.put(query.getId(), query);
         
         if (jobMonitorURL != null) {
            query.registerJobMonitor(new URL(jobMonitorURL));
         }
         query.setResultsDestination(resultsDestinationUri);
         
         return query.getId();
      }
      catch (IOException e) {
         throw new RuntimeException(""+e,e);
      }
      catch (ADQLException e) {
         throw new RuntimeException(""+e,e);
      }
      
   }

   /**
    * ApplicationController implemenation: Returns the status of a running query
    *
    */
   public String queryApplicationExecutionStatus(String executionId) {
      WebQueryDelegate query = (WebQueryDelegate) queries.get(executionId);

      if (query == null) {
         throw new IllegalArgumentException("No Query found for id "+executionId);
      }
      
      try
      {
         return query.getStatus().toString();
      }
      catch (RemoteException re)
      {
         throw new RuntimeException("Could not getStatus on Query '"+executionId+"'", re);
      }
   }
   
   /**
    * ApplicationController implemenation: Runs the given query
    *
    */
   public boolean executeApplication(String executionId) {
      WebQueryDelegate query = (WebQueryDelegate) queries.get(executionId);

      if (query == null) {
         throw new IllegalArgumentException("No Query found for id "+executionId);
      }
      
      try
      {
         query.start();
         return true; //for now
      }
      catch (RemoteException re)
      {
         throw new RuntimeException("Could not start Query '"+executionId+"'", re);
      }
   }
   
   
   
   /**
    * Method returnRegistryEntry
    *
    * @return   a String
    *
    */
   public String returnRegistryEntry() {
      
      try {
         Element voDescription = getMetadata().getVoRegistryMetadata();
         
         return XMLUtils.ElementToString(voDescription);
      }
      catch (RemoteException re) {
         throw new RuntimeException("Could not getMetadata", re);
      }
      
   }
   
   
}

/*
 $Log: WebDelegate.java,v $
 Revision 1.25  2004/03/06 19:34:21  mch
 Merged in mostly support code (eg web query form) changes

 Revision 1.23  2004/03/02 01:37:50  mch
 Updates from changes to StoreClient and AGSLs

 Revision 1.22  2004/02/24 16:04:29  mch
 Config refactoring and moved datacenter It04.1 VoSpaceStuff to myspace StoreStuff

 Revision 1.21  2004/02/17 03:37:27  mch
 Various fixes for demo

 Revision 1.20  2004/02/16 23:33:42  mch
 Changed to use Account and AttomConfig

 Revision 1.19  2004/02/15 23:16:06  mch
 New-style VoSpace delegates.  Not agreed so private to datacenter for the moment

 Revision 1.18  2004/02/15 23:09:04  mch
 Naughty Big Lump of changes: Updated myspace access, applicationcontroller interface, some tidy ups.

 Revision 1.17  2004/01/13 00:32:47  nw
 Merged in branch providing
 * sql pass-through
 * replace Certification by User
 * Rename _query as Query

 Revision 1.16  2004/01/08 15:48:17  mch
 Allow myspace references to be given
$Log: WebDelegate.java,v $
Revision 1.25  2004/03/06 19:34:21  mch
Merged in mostly support code (eg web query form) changes

Revision 1.23  2004/03/02 01:37:50  mch
Updates from changes to StoreClient and AGSLs

Revision 1.22  2004/02/24 16:04:29  mch
Config refactoring and moved datacenter It04.1 VoSpaceStuff to myspace StoreStuff

Revision 1.21  2004/02/17 03:37:27  mch
Various fixes for demo

Revision 1.20  2004/02/16 23:33:42  mch
Changed to use Account and AttomConfig

Revision 1.19  2004/02/15 23:16:06  mch
New-style VoSpace delegates.  Not agreed so private to datacenter for the moment

Revision 1.18  2004/02/15 23:09:04  mch
Naughty Big Lump of changes: Updated myspace access, applicationcontroller interface, some tidy ups.

Revision 1.17  2004/01/13 00:32:47  nw
Merged in branch providing
* sql pass-through
* replace Certification by User
* Rename _query as Query

Revision 1.13.2.4  2004/01/08 09:42:26  nw
tidied imports

Revision 1.13.2.3  2004/01/08 09:10:20  nw
replaced adql front end with a generalized front end that accepts
a range of query languages (pass-thru sql at the moment)

Revision 1.13.2.2  2004/01/07 13:01:44  nw
removed Community object, now using User object from common

Revision 1.13.2.1  2004/01/07 11:49:55  nw
found out how to get wsdl to generate nice java class names.
Replaced _query with Query throughout sources.

Revision 1.13  2003/12/16 16:19:27  mch
minor exception check

 Revision 1.15  2004/01/08 12:55:15  mch
 Finished implementing ApplicationController interface

 Revision 1.14  2004/01/05 19:06:26  mch
 Introduced ApplicationController interface

 Revision 1.13  2003/12/16 16:19:27  mch
 minor exception check

 Revision 1.12  2003/12/15 14:30:50  mch
 Fixes to load doc from string not file, and use correct version of adql

 Revision 1.11  2003/12/03 19:37:03  mch
 Introduced DirectDelegate, fixed DummyQuerier

 Revision 1.10  2003/12/01 16:53:16  nw
 dropped _QueryId, back to string

 Revision 1.9  2003/11/26 16:31:46  nw
 altered transport to accept any query format.
 moved back to axis from castor

 Revision 1.8  2003/11/25 15:47:17  mch
 Added certification

 Revision 1.7  2003/11/25 11:54:41  mch
 Added framework for SQL-passthrough queries

 Revision 1.6  2003/11/21 17:30:19  nw
 improved WSDL binding - passes more strongly-typed data

 Revision 1.5  2003/11/18 14:25:23  nw
 altered types to fit with new wsdl

 Revision 1.4  2003/11/17 20:47:57  mch
 Adding Adql-like access to Nvo cone searches

 Revision 1.3  2003/11/17 12:32:27  mch
 Moved QueryStatus to query pacakge

 Revision 1.2  2003/11/17 12:12:28  nw
 first stab at mavenizing the subprojects.

 Revision 1.1  2003/11/14 00:36:40  mch
 Code restructure

 Revision 1.4  2003/11/06 22:04:48  mch
 Temporary fixes to work with old version of AxisDataServer

 Revision 1.3  2003/11/05 18:52:53  mch
 Build fixes for change to SOAPy Beans and new delegates

 Revision 1.2  2003/10/13 14:13:47  nw
 massaged one method to fit wih new delegate. still lots more to do here
 - don't understand intentions here myself

 Revision 1.1  2003/10/06 18:55:21  mch
 Naughtily large set of changes converting to SOAPy bean/interface-based delegates



 */


