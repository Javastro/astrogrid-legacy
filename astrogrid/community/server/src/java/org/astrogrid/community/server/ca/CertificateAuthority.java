package org.astrogrid.community.server.ca;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import javax.security.auth.x500.X500Principal;
import org.apache.log4j.Logger;

/**
 * A certificate authority (CA) for AstroGrid communities.
 * This CA is dedicated to the special use-case of generating X.509 credentials
 * for use inside a community. The private key and certificate request for 
 * each user are not passed in to the CA, but are generated internally. The
 * keys and user-identity certificates are stored in MyProxy and the users
 * obtain proxy credentials from these using the MyProxy network-interface.
 *
 * The CA is built from calls to the openssl command which run in sub-processes.
 *
 * Credentials are generated in PEM files. A client specifies a working
 * directory; this class creates in that directory a sub-directory named for
 * the user's log-in name; in the sub-directory are created files with 
 * externsions .key (private key), .crt (user certificate) and .req
 * (certificate request to CA). E.g., if the working directory is /var/tmp/ca
 * and the user is fred, the CA creates /var/tmp/ca/fred/fred.key,
 * var/tmp/ca/fred/fred.crt and /var/tmp/ca/fred/fred.req.
 *
 * 
 * @author Guy Rixon
 */
public class CertificateAuthority {
  
  private static Logger log =
      Logger.getLogger("org.astrogrid.community.webapp.CertificateAuthority");
  
  /**
   * The CA's passphrase for its private key.
   */
  protected String caKeyPassphrase;
  
  /**
   * The file holding the CA's private key.
   */
  protected File caKeyFile;
  
  /**
   * The file holding the CA's root certificate.
   */
  protected File caCertificateFile;
  
  /**
   * The file holding the CA's serial-number record.
   */
  protected File caSerialFile;
  
  /**
   * The common part of the distinguished names in this PKI.
   * All names generated by the CA start with this and have
   * a /CN= part added. For the CA itself, the added part is
   * /CN=CA.
   */
  protected String rootDn;
  
  /**
   * The directory where MyProxy stores credentials.
   */
  protected File myProxyDirectory;
 
  /**
   * Constructs a CertificateAuthority with no CA.
   * This is only useful for unit tests.
   */
  protected CertificateAuthority() {}
  
  /**
   * Constructs a CertificateAuthority. This constructor creates the CA files,
   * including the CA certificate and key-pair, from scratch, based on the
   * given root DN. C.f. the constructor without the dnRoot parameter which
   * reconstructs the CA from existing files.
   */
  public CertificateAuthority(String dnRoot,
                              String password,
                              File   keyFile,
                              File   certificateFile,
                              File   serialFile,
                              File   myProxyDirectory) throws Exception {
    assert dnRoot != null;
    assert password != null;
    assert keyFile != null;
    assert certificateFile != null;
    assert serialFile != null;
    assert myProxyDirectory != null;
    assert myProxyDirectory.exists();
    
    this.rootDn = dnRoot;
    this.caKeyPassphrase = password;
    this.caKeyFile = keyFile;
    this.caCertificateFile = certificateFile;
    this.caSerialFile = serialFile;
    this.myProxyDirectory = myProxyDirectory;
    
    this.generateCa();
    log.info("The CA with root DN " + this.rootDn + " is active.");
  }
  
  /**
   * Constructs a CertificateAuthority. This constructor uses an existing
   * set of CA files and deduces the root DN from the CA certificate. C.f.
   * the constructor with the dnRoot parameter which creates the CA files
   * from scratch.
   */
  public CertificateAuthority(String password,
                              File   keyFile,
                              File   certificateFile,
                              File   serialFile,
                              File   myProxyDirectory) throws Exception {
    assert password != null;
    assert keyFile != null;
    assert keyFile.exists();
    assert certificateFile != null;
    assert certificateFile.exists();
    assert serialFile != null;
    assert serialFile.exists();
    assert myProxyDirectory != null;
    assert myProxyDirectory.exists();
    
    this.caKeyPassphrase = password;
    this.caKeyFile = keyFile;
    this.caCertificateFile = certificateFile;
    this.caSerialFile = serialFile;
    this.myProxyDirectory = myProxyDirectory;
    
    this.deduceRootDnFromCaCertificate();
    this.checkCaPassword();
    log.info("The CA with root DN " + this.rootDn + " is active.");
  }
  
  /**
   * Reveals the root DN for the CA.
   * This is the part of the DNs common to all the certificates
   * issued by the CA.
   */
  public String getRootDn() {
    return this.rootDn;
  }
  
  /**
   * Creates credentials for a new CA.
   * The details of the credentials and their storage were set
   * at construction.
   */
  protected void generateCa() throws Exception {
    String dn = this.rootDn + "/CN=CA";
    String kp = this.caKeyFile.getAbsolutePath();
    String cp = caCertificateFile.getAbsolutePath();
    String[] command = {
        "openssl",    // Invoke openssl
        "req",        // Use the certificate-request command
        "-new",       // Make a certificate, don't read one in
        "-x509",      // Make a self-signed certificate
        "-days",      // Make it valid for...
        "3650",       // ...10 years
        "-subj",      // Set the certificate subject...
        dn,           // ...to this DN
        "-newkey",    // Make a new key pair...
        "rsa:2048",   // ...of this type and length
        "-keyout",    // Write out the new key pair...
        kp,           // ...to this file
        "-passout",   // Read the passphase for the new key-pair...
        "stdin",      // ...from standard input
        "-out",       // Write out the new certificate...
        cp            // ...to this file
    };
    
    this.runCommandWithStdinPassword(command, this.caKeyPassphrase);
    
    // Create and write the serial-number record for the CA.
    // The file contains a serial number written out as an even number
    // of hexidecimal digits. Between signing operations, the serial number
    // in the file is that of the last certificate to be signed. Therefore,
    // for a new CA, it is set to 00 since the CA's own certificate is
    // number 0 by convention.
    this.caSerialFile.createNewFile();
    PrintWriter pw = new PrintWriter(new FileOutputStream(this.caSerialFile));
    pw.print("00\n");
    pw.flush();
    pw.close();
  }
  
  /**
   * Sets credentials for a user in MyProxy.
   * This combines {@link generateUserCredentials} and
   * {@link copyUserCredentialsToMyProxy} and then deletes
   * the working files used by those methods.
   */
  public void setUserCredentialsInMyProxy(String    loginName,
                                          String    commonName,
                                          String    password,
                                          UserFiles userFiles) throws Exception {
    log.debug("Making the credentials...");
    this.generateUserCredentials(loginName,
                                 commonName,
                                 password,
                                 userFiles);
    log.debug("Copying the credentials into MyProxy...");
    this.copyUserCredentialsToMyProxy(loginName,
                                      commonName,
                                      password,
                                      userFiles);
    //userFiles.deleteUserDirectory();
  }
  
  /**
   * Generates credentials for a user, levaing them in files.
   * See the class comments for details of the storage.
   */
  public void generateUserCredentials(String    loginName,
                                      String    commonName,
                                      String    password,
                                      UserFiles userFiles) throws Exception {
    assert this.caKeyFile != null;
    assert this.caKeyFile.exists();
    assert this.caCertificateFile != null;
    assert this.caCertificateFile.exists();
    assert this.caSerialFile != null;
    assert this.caSerialFile.exists();
    assert this.caKeyPassphrase != null;
    
    String dn = this.rootDn + "/CN=" + commonName;
    String kp = userFiles.getKeyFile().getAbsolutePath();
    String rp = userFiles.getCertificateRequestFile().getAbsolutePath();
    String[] reqCommand = {
        "openssl",    // Invoke openssl
        "req",        // Use the certificate-request command
        "-new",       // Make a request, don't read one in
        "-subj",      // Set the certificate subject...
        dn,           // ...to this DN
        "-newkey",    // Make a new key pair...
        "rsa:2048",   // ...of this type and length
        "-keyout",    // Write the new key pair...
        kp,           // ...to this file
        "-passout",   // Read the passphase for the new key-pair...
        "stdin",      // ...from standard input
        "-out",       // Write out the request...
        rp            // ...to this file
    };
    this.runCommandWithStdinPassword(reqCommand, password);
    
    // Sign the certificate request.
    String ckp = this.caKeyFile.getAbsolutePath();
    String ccp = this.caCertificateFile.getAbsolutePath();
    String csp = this.caSerialFile.getAbsolutePath();
    String cp = userFiles.getCertificateFile().getAbsolutePath();
    String[] signCommand = {
        "openssl",    // Invoke openssl
        "x509",       // Use the generic X.509 command
        "-CA",        // Use it as a CA...
        ccp,          // ...with this CA certificate...
        "-CAkey",     // ...and the CA private key...
        ckp,          // ...in this file
        "-CAserial",  // Use the serial-=number sequence...
        csp,          // ...in this file
        "-passin",    // Read the passphrase for the CA key...
        "stdin",      // ...from standard input
        "-in",        // Read the input from...
        rp,           // ...this file
        "-req",       // Input is a certificate request
        "-days",      // Make the new certificate valid for...
        "365",        // ...one year
        "-out",       // Write out the new certificate...
        cp            // ...to this file
    };
    this.runCommandWithStdinPassword(signCommand, this.caKeyPassphrase); 
  }
  
  /**
   * Copies credentials into a MyProxy installation.
   *
   * The copied credentials consist of an end-entity certificate
   * (the long-term user-certificate; the one that MyProxy uses to
   * generate proxy certificates) and a private key. The key is assumed 
   * to be encrypted, and MyProxy will use the encryption-password from the
   * key as the log-in password for users retrieving credentials.
   * The credentials are read from the files generated by
   * {@link generateUserCredential} in this class (see the class comments
   * for details).
   */
  public void copyUserCredentialsToMyProxy(String    loginName,
                                           String    commonName,
                                           String    password,
                                           UserFiles userFiles) throws Exception {
    
    // Generate the certificate request.
    String dn = this.rootDn + "/CN=" + commonName;
    String kp = userFiles.getKeyFile().getAbsolutePath();
    String cp = userFiles.getCertificateFile().getAbsolutePath();
    String mp = this.myProxyDirectory.getAbsolutePath();
    String[] command = {
        "myproxy-admin-load-credential", // Invoke MyProxy tools
        "-s",                            // Use the MyProxy storage...
        mp,                              // ...here
        "-c",                            // Load a certificate...
        cp,                              // from this file
        "-y",                            // Load a private key...
        kp,                              // from this file
        "-l",                            // Make the user-name for MyProxy...
        loginName                        // ...this
    };
    this.runCommandWithoutPassword(command);
  }
  
  /**
   * Generates a key pair in a file protected by a password.
   *
   * @param password - The password to protect the key pair.
   * @param keyFile - The file in which to store the key pair.
   * @throws Exception - If OpenSSL goes wrong.
   */
  protected void generateKeyPair(String password, 
                                 File   keyFile) throws Exception {
    String kp = keyFile.getAbsolutePath();
    String[] command = {
        "openssl",                  // Invoke openssl
        "genrsa",                   // Generate an RSA key-pair
        "-des3",                    // Encrypt the key
        "-passout",                 // Get the encryption password...
        "stdin",                    // ...from standard input
        "-out",                     // Write the key...
        kp,                         // ...to this file
        "2048"                      // Make the key this many bits long
    };
    this.runCommandWithStdinPassword(command, password);
  }
  
  /**
   * Changes the password protecting the user's credentials.
   */
  public void changePasswordInMyProxy(String loginName,
                                      String oldPassword,
                                      String newPassword) throws Exception {
    String mp = this.myProxyDirectory.getAbsolutePath();
    String[] command = {
        "myproxy-admin-change-pass", // Invoke MyProxy tools
        "-s",                        // Use the MyProxy storage...
        mp,                          // ...here
        "-l",                        // Alter the credential for...
        loginName,                   // ...this user
        "-S"                         // Read the password from standard input
    };
    
    // The command takes the current password (to unlock the private key)
    // plus the new password, on two sucessive lines of input.
    String passwords = oldPassword + "\n" + newPassword;
    this.runCommandWithStdinPassword(command, passwords);
  }
  
  /**
   * Runs a command in a sub-process and writes the password to
   * that process' standard input.
   *
   * The command is given as an array of words. This approach is required 
   * because some of the arguments may contain white space; forming the
   * command as a single string doesn't work. Adding quotes around the
   * arguments with white space doesn't work either, as there is no shell
   * to process the quotes; Java tokenization can't cope.
   * 
   * @param command - The command with argument list; zeroth element is command name.
   * @param password - The passphrase.
   * @throws Exception - If OpenSSL goes wrong.
   */
  protected void runCommandWithStdinPassword(String[] command, 
                                             String password) throws Exception {
    // Start the command in a sub-process.
    Process p = Runtime.getRuntime().exec(command);
    
    // Send the password to the standard input of the sub-process.
    OutputStream os = p.getOutputStream();
    os.write(password.getBytes());
    os.flush();
    os.close();
    
    // Wait for the OpenSSL command to finish.
    p.waitFor();
    
    // Check for failure.
    if (p.exitValue() != 0) {
      InputStream is = p.getErrorStream();
      BufferedReader br = new BufferedReader(new InputStreamReader(is));
      StringBuffer whinge = new StringBuffer();
      whinge.append(command[0]);
      whinge.append(" failed:");
      while(true) {
        String line = br.readLine();
        if (line == null) {
          break;
        }
        whinge.append("\n");
        whinge.append(line);
      }
      throw new Exception(whinge.toString());
    }
  }
  
   /**
   * Runs a command in a sub-process.
   *
   * The command is given as an array of words. This approach is required 
   * because some of the arguments may contain white space; forming the
   * command as a single string doesn't work. Adding quotes around the
   * arguments with white space doesn't work either, as there is no shell
   * to process the quotes; Java tokenization can't cope.
   * 
   * @param command - The command with argument list; zeroth element is command name.
   * @throws Exception - If the command goes wrong.
   */
  protected void runCommandWithoutPassword(String[] command) throws Exception {
    // Start the command in a sub-process.
    Process p = Runtime.getRuntime().exec(command);
    
    // Wait for the OpenSSL command to finish.
    p.waitFor();
    
    // Check for failure.
    if (p.exitValue() != 0) {
      InputStream is = p.getErrorStream();
      BufferedReader br = new BufferedReader(new InputStreamReader(is));
      StringBuffer whinge = new StringBuffer();
      whinge.append(command[0]);
      whinge.append(" failed:");
      while(true) {
        String line = br.readLine();
        if (line == null) {
          break;
        }
        whinge.append("\n");
        whinge.append(line);
      }
      throw new Exception(whinge.toString());
    }
  }
  
  /**
   * Determines the root of the distinguished names for the users.
   * The root DN is the CA's DN with the /CN field removed.
   */
  protected void deduceRootDnFromCaCertificate() throws Exception {
    assert this.caCertificateFile != null;
    assert this.caCertificateFile.exists();
    
    // Read the CA's certificate.
    // Extract the subject.
    CertificateFactory factory = CertificateFactory.getInstance("X509");
    InputStream is = new FileInputStream(this.caCertificateFile);
    X509Certificate certificate = (X509Certificate)factory.generateCertificate(is);
    is.close();      
    X500Principal principal = certificate.getSubjectX500Principal();
      
    // Parse the CA's subject. The root DN is the CA's subject with the
    // CN field(s) stripped out.
    String dnWithCommas = principal.getName(X500Principal.RFC2253);
    String[] elements = dnWithCommas.split(",");
    StringBuffer dnWithSlashes = new StringBuffer();
    for (int i = 0; i < elements.length; i++) {
      if (!elements[i].startsWith("CN")) {
        dnWithSlashes.append("/");
        dnWithSlashes.append(elements[i]);
      }
    }
    this.rootDn = dnWithSlashes.toString();
  }
  
  /**
   * Checks the CA password against the CA's private key.
   * If the password is correct, this method completes silently;
   * if not, it throws.
   *
   * @throws Exception - if the password is incorrect.
   */
  protected void checkCaPassword() throws Exception {
    
    // These are invariants for this class.
    assert this.caKeyPassphrase != null;
    assert this.caKeyFile != null;
    assert this.caKeyFile.exists();
    
    // Try to make a PKCS#12 key-store from the CA's key and certificate, but
    // don't bother to store the result to disc. The key-store can only be
    // created if the key file can be read with the passphrase, so the call
    // to Openssl will return errors if the passphrase is no good. This operation
    // also checks that the keyt matches the certificate.
    String ckp = this.caKeyFile.getAbsolutePath();
    String ccp = this.caCertificateFile.getAbsolutePath();
    String[] signCommand = {
        "openssl",    // Invoke openssl
        "pkcs12",     // Use the PKCS#12 command...
        "-export",    // ...to make a key-store...
        "-noout",     // ...but not to save it to disc.
        "-in",        // Get the certificate...
        ccp,          // ...from this PEM file.
        "-inkey",     // ...and the CA private key...
        ckp,          // ...from this file.
        "-passin",    // Read the passphrase for the CA key...
        "stdin"       // ...from standard input.
    };
    this.runCommandWithStdinPassword(signCommand, this.caKeyPassphrase); 
    
    
  }
  
}