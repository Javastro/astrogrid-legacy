/* Generated By: AdqlStoX.jjt,v 1.33.2.4 2006-12-19 14&JJTree: Do not edit this line. AST_MathFunction.java */

package org.astrogrid.adql;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.xmlbeans.XmlObject;
import org.astrogrid.adql.v1_0.beans.AtomType;
import org.astrogrid.adql.v1_0.beans.IntegerType;
import org.astrogrid.adql.v1_0.beans.MathFunctionNameType;
import org.astrogrid.adql.v1_0.beans.MathFunctionType;


public class AST_MathFunction extends SimpleNode {
    
    private static Log log = LogFactory.getLog( AST_MathFunction.class ) ;
    
    private Object arg2 = null ;

    public AST_MathFunction(AdqlStoX p, int id) {
        super(p, id);
    }

    public void setArg2( Object arg2 ) {
        this.arg2 = arg2 ;
    }


    public void buildXmlTree( XmlObject xo ) {
        if( log.isTraceEnabled() ) enterTrace( log, "AST_MathFunction.buildXmlTree()" ) ; 
        MathFunctionType mfType = (MathFunctionType)xo.changeType( MathFunctionType.type ) ;
        mfType.setName( MathFunctionNameType.Enum.forString( firstToken.image.toUpperCase() ) ) ;
      
        //
        // JL: The following would be better reorganized into a loop to process child nodes.
        // The problem revolves arounding typing the children, so a more virtualized
        // buildXmlTree() should accomplish this. I believe the best way of achieving it
        // is for all constructs within AdqlStoX.jjt to be held within their own generated
        // structures. Thus 
        // arg2=<UNSIGNED_INTEGER> {jjtThis.setArg2(new Long(arg2.image));} 
        // should really be something like
        // unsignedInteger()
        // This is an important lesson.

        //
        // PI is the only function with no arguments...
        // (JL: but is this also true of RANDOM?)
        if( firstToken.kind == AdqlStoXConstants.PI ) {
            // do nothing
        }
        //
        // POWER is the only function with two arguments...
        else if( firstToken.kind == AdqlStoXConstants.POWER ) {
            children[0].buildXmlTree( mfType.addNewArg() ) ;
            AtomType atomType = (AtomType)mfType.addNewArg().changeType( AtomType.type ) ;
            IntegerType intType = IntegerType.Factory.newInstance() ;
            intType.setValue( ((Long)arg2).longValue() ) ;
            atomType.setLiteral( intType ) ;
        }
        //
        // ROUND and TRUNCATE are functions with one or two arguments.
        // We impose two arguments, defaulting to 0 for the second
        // if this happens to be missing.
        // This means we are backward compatible. Previously,
        // in error, we were only supporting one argument. 
        else if( firstToken.kind == AdqlStoXConstants.ROUND
                 ||
                 firstToken.kind == AdqlStoXConstants.TRUNCATE ) {
            children[0].buildXmlTree( mfType.addNewArg() ) ; 
            AtomType atomType = (AtomType)mfType.addNewArg().changeType( AtomType.type ) ;
            IntegerType intType = IntegerType.Factory.newInstance() ;
            if( arg2 != null ) {                
                intType.setValue( ((Long)arg2).longValue() ) ;             
            }
            else {
                intType.setValue( 0 ) ;    
            }
            atomType.setLiteral( intType ) ;       
        }
        // RAND has an optional argument...
        else if( firstToken.kind == AdqlStoXConstants.RAND ) {
            if( jjtGetNumChildren() == 1 ) {
                children[0].buildXmlTree( mfType.addNewArg() ) ;
            }
        }
        //
        // And all the rest have only one argument...
        else {
           children[0].buildXmlTree( mfType.addNewArg() ) ;
        }
       
        setGeneratedObject( mfType ) ;
        super.buildXmlTree( mfType ) ;
        if( log.isTraceEnabled() ) exitTrace( log, "AST_MathFunction.buildXmlTree()" ) ; 
    }
}
  
