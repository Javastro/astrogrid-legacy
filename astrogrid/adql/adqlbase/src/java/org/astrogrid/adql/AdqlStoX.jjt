/*$Id: AdqlStoX.jjt,v 1.3 2009/06/29 09:40:04 jl99 Exp $*/

//  
// High-level JavaDoc comments are present in this file.
// There is little point in placing any here. 
// At this point they are ignored by the JavaCC processors. 
//
// Jeff Lusted   
//
   
options {
  JDK_VERSION="1.4";   
  STATIC=false;
  MULTI=true;
  VISITOR=false;
  NODE_USES_PARSER=true;
  NODE_DEFAULT_VOID=true;
  NODE_PREFIX="AST_";
  IGNORE_CASE=true;
  NODE_SCOPE_HOOK=true ;
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;
import java.util.HashSet ;
import java.util.ArrayList ;
import java.util.List ;
import org.astrogrid.adql.v1_0.beans.* ;
import org.astrogrid.stc.region.v1_10.beans.* ;
import org.astrogrid.stc.coords.v1_10.beans.* ;

/**
 * AdqlStoX JavaCC file          
 *
 * This version, with file extension of .jjt, produces a syntax tree.
 *
 * AdqlStoX takes text in the form of Adql/s and compiles it to xml Adql/x format.
 * Adql/s is based upon SQL/92 with astronomical extensions.
 *
 * There is a naming convention for methods, which is aimed at making the structure
 * as clear as possible...
 *
 * (1) All methods which are quoted bnf statements follow the bnf format, 
 *     with any embedded dashes (-) removed from the name.
 *     Thus the the statment &lt;comparison_predicate> from the SQL/92 standard
 *     will have a corresponding method with a name similar to comparison_predicate().
 *     However, such methods are decorated in a particular way, for which see
 *     points (2) and (3) below. All methods which are tantamount to quoted
 *     bnf will have the standard syntax as a comment embedded within them.
 *     Thus: 
 *     //S: 
 *     // &lt;row_value_constructor> &lt;comp_op> &lt;row_value_constructor>
 * (2) Methods which follow exactly the SQL/92 syntax at a shallow level are suffixed _S.
 *     Thus comparison_predicate_S() represents the SQL/92 standard syntax. Shallow implies
 *     that the syntax can still vary from the standard within statements quoted
 *     within the given construct. This is usually pretty obvious from the quoted statements
 *     (eg: quoted statement some_statement_A() means an ADQL variation, see next point), 
 *     but beware that it is possible for variations to be deeply embedded.
 *     NB: A statement that is just a synonym for another statement will take
 *         the quoted statement's decoration. This is the one exception.
 * (3) Methods which are varied for some reason within ADQL, or are simply
 *     specific to ADQL, are suffixed _A.
 *     Thus comparison_predicate_A() represents an ADQL deviation.
 * (4) Some methods are introduced as implementations of part of a syntax.
 *     This is just to make for a neater structure. These methods follow
 *     the standard Java OO naming convention and are not decorated, 
 *     eg: numericValueExpressionList().
 *
 * There is built-in documentation to help in supporting BNF syntax diagrams. This built-in
 * documentation consists of special comments throughout the code. It is separate from the
 * above four conventions and must be maintained by the developer to correspond to the working
 * of the compiler. Thus the resulting BNF documentation represents what the compiler does. 
 * This seems a little back-to-front but is reasonably thorough in its results. There are two 
 * sorts of comments: singletons and multiples, depending on whether the BNF definition is on 
 * one or more lines. Two examples are given below:
 *
 *     bnf-single &lt;boolean_factor> ::= [ NOT ] &lt;boolean_test>
 *     bnf-start
 *        &lt;between_predicate> ::=
 *          &lt;value_expression> [ NOT ] BETWEEN
 *          &lt;value_expression> AND &lt;value_expression>
 *     bnf-end
 *
 * (Real ones have to be positioned at the beginning of a line with each line prefixed by
 * the string " * " exactly. )
 * 
 * A utility programme BnfExtractor extracts these from the source and places them in 
 * suitable files (or to standard out). BnfExtractor produces output in two formats:
 * plain text and html. 
 *
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Sep 2006
 */

public class AdqlStoX {
	
	private static Log log = LogFactory.getLog( AdqlStoX.class ) ;
	
	private static final int DONT_CHANGE_SIGN = 1 ;
    
	protected Tracker tracker ;
	protected HashSet comments ; 
	protected AdqlCompiler compiler ; 
	protected Token lastCommentWritten ; 
	void jjtreeOpenNodeScope( org.astrogrid.adql.Node n ) {		((SimpleNode)n).firstToken = getToken(1);	}		    void jjtreeCloseNodeScope( org.astrogrid.adql.Node n ) {        ((SimpleNode)n).lastToken = getToken(0);    }    	private void enterTrace( String entry ) {
		log.trace( compiler.getIndent().toString() + "enter: " + entry ) ;
		compiler.indentPlus() ;	}    private void exitTrace( String entry ) {    	compiler.indentMinus() ;
		log.trace( compiler.getIndent().toString() + "exit : " + entry ) ;	}
	
}
PARSER_END(AdqlStoX)

SPECIAL_TOKEN : /* COMMENTS */
{ 
// There are shortcomings in this definition to do with
// comments (-- or // style) stretching over more than one line that do not start at the
// beginning of a line; ie: a comment where there is white space at the start of lines.
   < COMMENT : ( <SINGLE_LINE_COMMENT> )+ | ( <MULTI_LINE_COMMENT> )+ >
   
//
// Single line comment delineated by -- or //
|  < #SINGLE_LINE_COMMENT: ("\n"|"\r"|"\r\n"|" "|"\t")* ("--"|"//") (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
//
// Standard C comment; ie: /* this is a comment */
|  < #MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" ("\n"|"\r"|"\r\n")? >
}

SKIP :
{
 	" "
|	"\n"
|	"\r"
|	"\t"
}

/**
 * TOKEN <SQL_special_character> 
 *
 * bnf-start
 *  <SQL_special_character> ::=
 *     <space>
 *   | <double_quote>
 *   | <percent>
 *   | <ampersand>
 *   | <quote>
 *   | <left_paren>
 *   | <right_paren>
 *   | <asterisk>
 *   | <plus_sign>
 *   | <comma>
 *   | <minus_sign>
 *   | <period>
 *   | <solidus>
 *   | <colon>
 *   | <semicolon>
 *   | <less_than_operator>
 *   | <equals_operator>
 *   | <greater_than_operator>
 *   | <question_mark>
 *   | <underscore>
 *   | <vertical_bar>
 * bnf-end
 * bnf-start
 *  <space> ::=
 *  !! Imagine there is a space character here
 * bnf-end
 * bnf-single <double_quote> ::= "
 * bnf-single <percent> ::= %
 * bnf-single <ampersand> ::= &
 * bnf-single <quote> ::= '
 * bnf-single <left_paren> ::= (
 * bnf-single <right_paren> ::= )
 * bnf-single <asterisk> ::= *
 * bnf-single <plus_sign> ::= +
 * bnf-single <comma> ::= ,
 * bnf-single <minus_sign> ::= -
 * bnf-single <period> ::= .
 * bnf-single <solidus> ::= /
 * bnf-single <colon> ::= :
 * bnf-single <semicolon> ::= ;
 * bnf-single <less_than_operator> ::= <
 * bnf-single <equals_operator> ::= =
 * bnf-single <greater_than_operator> ::= >
 * bnf-single <question_mark> ::= ?
 * bnf-single <underscore> ::= _
 * bnf-single <vertical_bar> ::= |
 */
TOKEN : // <SQL_special_character> 
{
  < DOUBLE_QUOTE: "\"\"" >
| < PERCENT: "%" >
| < AMPERSAND: "&" >
| < QUOTE: "'" >
| < LEFT_PAREN: "(" >
| < RIGHT_PAREN: ")" >
| < ASTERISK: "*" >
| < PLUS_SIGN: "+" >
| < COMMA: "," >
| < MINUS_SIGN: "-" >
| < PERIOD: "." >
| < SOLIDUS: "/" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < LESS_THAN_OPERATOR : "<" >
| < EQUALS_OPERATOR : "=" >
| < GREATER_THEN_OPERATOR : ">" >
| < QUESTION_MARK: "?" >
| < UNDERSCORE: "_" >
| < VERTICAL_BAR: "|" >
}

/**
 * TOKEN <SQL_embedded_language_character>
 *
 * bnf-start
 *  <SQL_embedded_language_character> ::=
 *      <left_bracket>
 *    | <right_bracket>
 * bnf-end
 * bnf-single <left_bracket> ::= [
 * bnf-single <right_bracket> ::= ]
 *
 */
TOKEN : // <SQL_embedded_language_character>
{
  < LEFT_BRACKET: "[" >
| < RIGHT_BRACKET: "]" >	
}

/**
 * TOKEN <reserved_word>
 *
 * bnf-start
 *  <reserved_word> ::=
 *     ABSOLUTE | ACTION | ADD | ALL
 *   | ALLOCATE | ALTER | AND
 *   | ANY | ARE
 *   | AS | ASC
 *   | ASSERTION | AT
 *   | AUTHORIZATION | AVG
 *   | BEGIN | BETWEEN | BIT | BIT_LENGTH
 *   | BOTH | BY
 *   | CASCADE | CASCADED | CASE | CAST
 *   | CATALOG
 *   | CHAR | CHARACTER | CHAR_LENGTH
 *   | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE
 *   | COLLATE | COLLATION
 *   | COLUMN | COMMIT
 *   | CONNECT
 *   | CONNECTION | CONSTRAINT
 *   | CONSTRAINTS | CONTINUE
 *   | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS
 *   | CURRENT
 *   | CURRENT_DATE | CURRENT_TIME
 *   | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
 *   | DATE | DAY | DEALLOCATE 
 *   | DECIMAL | DECLARE | DEFAULT | DEFERRABLE
 *   | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR
 *   | DIAGNOSTICS
 *   | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
 *   | ELSE | END | END-EXEC | ESCAPE
 *   | EXCEPT | EXCEPTION
 *   | EXEC | EXECUTE | EXISTS
 *   | EXTERNAL | EXTRACT
 *   | FALSE | FETCH | FIRST | FLOAT | FOR
 *   | FOREIGN | FOUND | FROM | FULL
 *   | GET | GLOBAL | GO | GOTO
 *   | GRANT | GROUP
 *   | HAVING | HOUR
 *   | IDENTITY | IMMEDIATE | IN | INDICATOR
 *   | INITIALLY | INNER | INPUT
 *   | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT
 *   | INTERVAL | INTO | IS
 *   | ISOLATION
 *   | JOIN
 *   | KEY
 *   | LANGUAGE | LAST | LEADING | LEFT
 *   | LEVEL | LIKE | LOCAL | LOWER
 *   | MATCH | MAX | MIN | MINUTE | MODULE
 *   | MONTH
 *   | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO
 *   | NOT | NULL
 *   | NULLIF | NUMERIC
 *   | OCTET_LENGTH | OF
 *   | ON | ONLY | OPEN | OPTION | OR
 *   | ORDER | OUTER
 *   | OUTPUT | OVERLAPS
 *   | PAD | PARTIAL | POSITION | PRECISION | PREPARE
 *   | PRESERVE | PRIMARY
 *   | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
 *   | READ | REAL | REFERENCES | RELATIVE | RESTRICT
 *   | REVOKE | RIGHT
 *   | ROLLBACK | ROWS
 *   | SCHEMA | SCROLL | SECOND | SECTION
 *   | SELECT
 *   | SESSION | SESSION_USER | SET
 *   | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE
 *   | SQLERROR | SQLSTATE
 *   | SUBSTRING | SUM | SYSTEM_USER
 *   | TABLE | TEMPORARY
 *   | THEN | TIME | TIMESTAMP
 *   | TIMEZONE_HOUR | TIMEZONE_MINUTE
 *   | TO | TRAILING | TRANSACTION
 *   | TRANSLATE | TRANSLATION | TRIM | TRUE
 *   | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE
 *   | USER | USING
 *   | VALUE | VALUES | VARCHAR | VARYING | VIEW
 *   | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
 *   | YEAR
 *   | ZONE
 * bnf-end
 */
TOKEN : // <reserved_word>
{
  < ABSOLUTE : "absolute" >
| < ACTION : "action" >
| < ADD : "add" >
| < ALL : "all" >
| < ALLOCATE : "allocate" >
| < ALTER : "alter" >
| < AND : "and" >
| < ANY : "any" >
| < ARE : "are" >
| < AS : "as" >
| < ASC : "asc" >
| < ASSERTION : "assertion" >
| < AT : "at" >
| < AUTHORIZATION : "authorization" >
| < AVG : "avg" >
| < BEGIN : "begin" >
| < BETWEEN : "between" >
| < BIT : "bit" >
| < BIT_LENGTH : "bit_length" >
| < BOTH : "both" >
| < BY : "by" >
| < CASCADE : "cascade" >
| < CASCADED : "cascaded" >
| < CASE : "case" >
| < CAST : "cast" >
| < CATALOG : "catalog" >
| < CHAR : "char" >
| < CHARACTER : "character" >
| < CHAR_LENGTH : "char_length" >
| < CHARACTER_LENGTH : "character_length" >
| < CHECK : "check" >
| < CLOSE : "close" >
| < COALESCE : "coalesce" >
| < COLLATE : "collate" >
| < COLLATION : "collation" >
| < COLUMN : "column" >
| < COMMIT : "commit" >
| < CONNECT : "connect" >
| < CONNECTION : "connection" >
| < CONSTRAINT : "constraint" >
| < CONSTRAINTS : "constraints" >
| < CONTINUE : "continue" >
| < CONVERT : "convert" >
| < CORRESPONDING : "corresponding" >
| < COUNT : "count" >
| < CREATE : "create" >
| < CROSS : "cross" >
| < CURRENT : "current" >
| < CURRENT_DATE : "current_date" >
| < CURRENT_TIME : "current_time" >
| < CURRENT_TIMESTAMP : "current_timestamp" >
| < CURRENT_USER : "current_user" >
| < CURSOR : "cursor" >
| < DATE : "date" >
| < DAY : "day" >
| < DEALLOCATE : "deallocate" >
//#2504 DEC removed as an SQL reserved word
// | < DEC : "dec" >
| < DECIMAL : "decimal" >
| < DECLARE : "declare" >
| < SQL_DEFAULT : "default" >
| < DEFERRABLE : "deferrable" >
| < DEFERRED : "deferred" >
| < DELETE : "delete" >
| < DESC : "desc" >
| < DESCRIBE : "describe" >
| < DESCRIPTOR : "descriptor" >
| < DIAGNOSTICS : "diagnostics" >
| < DISCONNECT : "disconnect" >
| < DISTINCT : "distinct" >
| < DOMAIN : "domain" >
| < DOUBLE : "double" >
| < DROP : "drop" >
| < ELSE : "else" >
| < END : "end" >
| < ENDEXEC : "end-exec" >
| < ESCAPE : "escape" >
| < EXCEPT : "except" >
| < EXCEPTION : "exception" >
| < EXEC : "exec" >
| < EXECUTE : "execute" >
| < EXISTS : "exists" >
| < EXTERNAL : "external" >
| < EXTRACT : "extract" >
| < FALSE : "false" >
| < FETCH : "fetch" >
| < FIRST : "first" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FOREIGN : "foreign" >
| < FOUND : "found" >
| < FROM : "from" >
| < FULL : "full" >
| < GET : "get" >
| < GLOBAL : "global" >
| < GO : "go" >
| < GOTO : "goto" >
| < GRANT : "grant" >
| < GROUP : "group" >
| < HAVING : "having" >
| < HOUR : "hour" >
| < IDENTITY : "identity" >
| < IMMEDIATE : "immediate" >
| < IN : "in" >
| < INDICATOR : "indicator" >
| < INITIALLY : "initially" >
| < INNER : "inner" >
| < INPUT : "input" >
| < INSENSITIVE : "insensitive" >
| < INSERT : "insert" >
| < INT : "int" >
| < INTEGER : "integer" >
| < INTERSECT : "instersect" >
| < INTERVAL : "interval" >
| < INTO : "into" >
| < IS : "is" >
| < ISOLATION : "isolation" >
| < JOIN : "join" >
| < KEY : "key" >
| < LANGUAGE : "language" >
| < LAST : "last" >
| < LEADING : "leading" >
| < LEFT : "left" >
| < LEVEL : "level" >
| < LIKE : "like" >
| < LOCAL : "local" >
| < LOWER : "lower" >
| < MATCH : "match" >
| < MAX : "max" >
| < MIN : "min" >
| < MINUTE : "minute" >
| < MODULE : "module" >
| < MONTH : "month" >
| < NAMES : "names" >
| < NATIONAL : "national" >
| < NATURAL : "natural" >
| < NCHAR : "nchar" >
| < NEXT : "next" >
| < NO : "no" >
| < NOT : "not" >
| < NULL : "null" >
| < NULLIF : "nullif" >
| < NUMERIC : "numeric" >
| < OCTET_LENGTH : "octet_length" >
| < OF : "of" >
| < ON : "on" >
| < ONLY : "only" >
| < OPEN : "open" >
| < OPTION : "option" >
| < OR : "or" >
| < ORDER : "order" >
| < OUTER : "outer" >
| < OUTPUT : "output" >
| < OVERLAPS : "overlaps" >
| < PAD : "pad" >
| < PARTIAL : "partial" >
| < POSITION : "position" >
| < PRECISION : "precision" >
| < PREPARE : "prepare" >
| < PRESERVE : "preserve" >
| < PRIMARY : "primary" >
| < PRIOR : "prior" >
| < PRIVILEGES : "privileges" >
| < PROCEDURE : "procedure" >
| < PUBLIC : "public" >
| < READ : "read" >
| < REAL : "real" >
| < REFERENCES : "references" >
| < RELATIVE : "relative" >
| < RESTRICT : "restrict" >
| < REVOKE : "revoke" >
| < RIGHT : "right" >
| < ROLLBACK : "rollback" >
| < ROWS : "rows" >
| < SCHEMA : "schema" >
| < SCROLL : "scroll" >
| < SECOND : "second" >
| < SECTION : "section" >
| < SELECT : "select" >
| < SESSION : "session" >
| < SESSION_USER : "session_user" >
| < SET : "set" >
| < SIZE : "size" >
| < SMALLINT : "smallint" >
| < SOME : "some" >
| < SPACE : "space" >
| < SQL : "sql" >
| < SQLCODE : "sqlcode" >
| < SQLERROR : "sqlerror" >
| < SQLSTATE : "sqlstate" >
| < SUBSTRING : "substring" >
| < SUM : "sum" >
| < SYSTEM_USER : "system_user" >
| < TABLE : "table" >
| < TEMPORARY : "temporary" >
| < THEN : "then" >
| < TIME : "time" >
| < TIMESTAMP : "timestamp" >
| < TIMEZONE_HOUR : "timezone_hour" >
| < TIMEZONE_MINUTE : "timezone_minute" >
| < TO : "to" >
| < TRAILING : "trailing" >
| < TRANSACTION : "transaction" >
| < TRANSLATE : "translate" >
| < TRANSLATION : "translation" >
| < TRIM : "trim" >
| < TRUE : "true" >
| < UNION : "union" >
| < UNIQUE : "unique" >
| < UNKNOWN : "unknown" >
| < UPDATE : "update" >
| < UPPER : "upper" >
| < USAGE : "usage" >
| < USER : "user" >
| < USING : "using" >
| < VALUE : "value" >
| < VALUES : "values" >
| < VARCHAR : "varchar" >
| < VARYING : "varying" >
| < VIEW : "view" >
| < WHEN : "when" >
| < WHENEVER : "whenever" >
| < WHERE : "where" >
| < WITH : "with" >
| < WORK : "work" >
| < WRITE : "write" >
| < YEAR : "year" >
| < ZONE : "zone" >
}

// <non-reserved_word> 
//
// Cannot be certain what to make of these yet
//{ //  < ADA : "ada" >//| < C: "c" >//| < CATALOG_NAME: "catalog_name" >//| < CHARACTER_SET_CATALOG: "character_set_catalog" >//| < CHARACTER_SET_NAME: "character_set_name" >//| < CHARACTER_SET_SCHEMA: "character_set_schema" >//| < CLASS_ORIGIN: "class_origin" >//| < COBOL: "cobol" >//| < COLLATION_CATALOG: "collation_catalog" >//| < COLLATION_NAME: "collation_name" >//| < COLLATION_SCHEMA: "collation_schema" >//| < COLUMN_NAME: "column_name" >//| < COMMAND_FUNCTION: "command_function" >//| < COMMITTED: "committed" >//| < CONDITION_NUMBER: "condition_number" >//| < CONNECTION_NAME: "connection_name" >//| < CONSTRAINT_CATALOG: "constraint_catalog" >//| < CONSTRAINT_NAME: "constraint_name" >//| < CONSTRAINT_SCHEMA: "constraint_schema" >//| < CURSOR_NAME: "cursor_name" >//| < DATA: "data" >//| < DATETIME_INTERVAL_CODE: "datetime_interval_code" >//| < DATETIME_INTERVAL_PRECISION: "datetime_interval_precision" >//| < DYNAMIC_FUNCTION: "dynamic_function" >//| < FORTRAN: "fortran" >//| < LENGTH: "length" >//| < MESSAGE_LENGTH: "message_length" >//| < MESSAGE_OCTET_LENGTH: "message_octet_length" >//| < MESSAGE_TEXT: "message_text" >//| < SQL_MORE: "more" >//| < MUMPS: "mumps" >//| < NAME: "name" >//| < NULLABLE: "nullable" >//| < NUMBER: "number" >//| < PASCAL: "pascal" >//| < PLI: "pli" >//| < REPEATABLE: "repeatable" >//| < RETURNED_LENGTH: "returned_length" >//| < RETURNED_OCTET_LENGTH: "returned_octet_length" >//| < RETURNED_SQLSTATE: "returned_sqlstate" >//| < ROW_COUNT: "row_count" >//| < SCALE: "scale" >//| < SCHEMA_NAME: "schema_name" >//| < SERIALIZABLE: "serializable" >//| < SERVER_NAME: "server_name" >//| < SUBCLASS_ORIGIN: "subclass_origin" >//| < TABLE_NAME: "table_name" >//| < TYPE: "type" >//| < UNCOMMITTED: "uncommitted" >//| < UNNAMED: "unnamed" >//}

/**
 * TOKEN <ADQL-reserved-word>
 * 
 * bnf-start
 *  <ADQL-reserved-word> ::=
 *        TOP
 *      | ABS 
 *      | CEILING 
 *      | DEGREES 
 *      | EXP 
 *      | FLOOR 
 *      | LOG 
 *      | PI 
 *      | POWER 
 *      | RADIANS 
 *      | SQRT 
 *      | SQUARE 
 *      | LOG10 
 *      | RAND 
 *      | ROUND 
 *      | TRUNCATE 
 *      | SIN 
 *      | COS 
 *      | TAN 
 *      | COT 
 *      | ASIN 
 *      | ACOS 
 *      | ATAN 
 *      | ATAN2
 * bnf-end
 
 */
TOKEN : // <ADQL-reserved-word>
{

	< TOP: "top" >

|	< XMATCH: "xmatch" >

	//region
|	< REGION: "region" >
|	< CIRCLE : "circle" >
|   < ELLIPSE : "ellipse" >	
|   < POLYGON : "polygon" >
|   < SECTOR : "sector" >
|   < CONVEX : "convex" >
|   < CONVEX_HULL : "convex hull" >
|   < INTERSECTION : "intersection" >
|   < FILL_FACTOR : "fill factor" >
|   < UNIT : "unit" >
|   < COORD_SYSTEM : "coordsystem" | "cs" >   
|   < CENTER : "center" >
|   < RADIUS : "radius" >
|   < RADII : "radii" >
|   < POS_ANGLE : "angle" >

|   < DEG : "deg" >
|   < DEG_DEG_M : "deg deg m" >
|   < RAD : "rad" >
// <H: "h"> causes severe problems with "h" appearing on its own, as this
//          consumes the token. Eg: table alias h is not then workable
|   < H : "_h_" >             
|   < ARCMIN : "arcmin" > 
|   < ARCSEC : "arcsec" >
// < M : "m" > causes severe problems with "m" appearing on its own, as this
//          consumes the token. Eg: table alias m is not then workable
|   < M : "_m_" >
|   < KM : "km" >
|   < MM : "mm" >
|   < AU : "au" >
|   < PC : "pc" >
|   < KPC : "kpc" >
|   < MPC : "Mpc" >
|   < LYR : "lyr" >   
	
	//math
|   < ABS: "abs" >
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >

|	< ASCII_STRING_LITERAL : "\'" (~["\'"])* "\'" >

//| 	< ASCIIStringLiteral : "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >
//|	< UnicodeStringLiteral : "n" "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >

}

/**
 * TOKEN <ADQL-special-character>
 *
 * bnf-start
 *  <ADQL-special-character> ::=
 *      <left_brace>
 *    | <right_brace>
 *    | <dollar>
 * bnf-end
 * bnf-single <left_brace> ::= {
 * bnf-single <right_brace> ::= }
 * bnf-single <dollar> ::= $
 */
TOKEN : // <ADQL-special-character>
{ 
	< LBRACE : "{" >
|	< RBRACE : "}" >
|	< DOLLAR : "$" >		
}

/**
 * TOKEN miscellaneous SQL92 
 *
 * bnf-single <not_equals_operator1> ::= <>
 * bnf-single <not_equals_operator2> ::= !=
 * bnf-single <not_equals_operator> ::= <not_equals_operator1> | <not_equals_operator2>
 * bnf-single <less_than_or_equals_operator> ::= <=
 * bnf-single <greater_than_or_equals_operator> ::= >=
 * bnf-single <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 * bnf-start
 *  <simple_Latin_letter> ::=
 *      <simple_Latin_upper_case_letter>
 *    | <simple_Latin_lower_case_letter>
 * bnf-end
 * bnf-start
 *  <simple_Latin_upper_case_letter> ::=
 *      A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
 *    | P | Q | R | S | T | U | V | W | X | Y | Z
 * bnf-end
 * bnf-start
 *  <simple_Latin_lower_case_letter> ::=
 *      a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
 *    | p | q | r | s | t | u | v | w | x | y | z
 * bnf-end
 * bnf-start
 *  <regular_identifier> ::=
 *      <simple_Latin_letter>... 
 *      [ { <digit> | <simple_Latin_letter> | <dollar> | <underscore> }... ]
 * bnf-end
 * bnf-start
 *  <delimited_identifier> ::=
 *  !! Begins and ends with a double quote as delimiters
 *     but contains no double quotes or white space
 * bnf-end
 * bnf-single <unsigned_integer> ::= <digit>...
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 * bnf-single <mantissa> ::= <exact_numeric_literal>
 * bnf-single <exponent> ::= <signed_integer> 
 * bnf-single <signed_integer> ::= [ <sign> ] <unsigned_integer>
 *
 */
TOKEN : // miscellaneous SQL92 
{
	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< CROSS_JOIN : "cross join">
|	< GROUPBY: "group by" >
|	< ORDERBY : "order by" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TRUTH_VALUE : "true" | "false" | "unknown" >
| < REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">

|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] >   
|   < APPROXIMATE_NUMERIC_LITERAL : <MANTISSA> <E> <EXPONENT> > 
|   < EXACT_NUMERIC_LITERAL : 
        ( <UNSIGNED_INTEGER> ( <PERIOD> ( <UNSIGNED_INTEGER> )? )? )
        | 
        ( <PERIOD> <UNSIGNED_INTEGER> ) >
|   < #MANTISSA : <EXACT_NUMERIC_LITERAL> >
|   < #EXPONENT : <SIGNED_INTEGER> > 
|   < #SIGNED_INTEGER : ( <SIGN> )? <UNSIGNED_INTEGER> >       
|   < #SIGN : <PLUS_SIGN> | <MINUS_SIGN> >
|   < #E : ["E", "e"] >

}

/**
 * TOKEN The remainder men.
 *
 *
 */
TOKEN : // The remainder
{
 	< OTHER : ~[] >
}


/**
 * actual_identifier_S
 *
 * bnf-single <actual_identifier> ::= <regular_identifier> | <delimited_identifier>
 *
 */
void actual_identifier_S() #ActualIdentifier : 
{
    if( log.isTraceEnabled() ) enterTrace ( "actual_identifier_S()" ) ;
} 
{
    //S:
    // <regular_identifier> | <delimited_identifier>
	( <REGULAR_IDENTIFIER> | <DELIMITED_IDENTIFIER> )
	{
		if( log.isTraceEnabled() ) exitTrace ( "actual_identifier_S()" ) ;		
	}
}

Long signed_integer_S() : 
{
	Token tSign = null ;
	Token tInteger = null ;

}
{
	[ tSign=<PLUS_SIGN> | tSign=<MINUS_SIGN> ] tInteger=<UNSIGNED_INTEGER>     
    {       if( tInteger != null ) {
      	  Long l = new Long( tInteger.image ) ;
      	  if( tSign != null ) {
      	  	 if( tSign.image.startsWith( "-" ) ) {
      	  	 	l = new Long( -l.longValue() ) ;
      	  	 }	
      	  }
      	  return l ;        }    }}

/**
 * between_predicate_A
 *
 * bnf-start
 * <between_predicate> ::=
 *     <value_expression> [ NOT ] BETWEEN
 *     <value_expression> AND <value_expression>
 * bnf-end
 *
 */
void between_predicate_A() #BetweenPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "between_predicate_A()" ) ;
	// Assume "BETWEEN"...
	tracker.setType( BetweenPredType.type ) ;
}
{
	//S:
	// <row_value_constructor> [ NOT ] BETWEEN
    // <row_value_constructor> AND <row_value_constructor>
    
    // Note the absence of row_value_constructor...	
    (
       { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A() 
	   { tracker.pop() ; }
	   [ <NOT> 
	     // We know now it is a "NOT BETWEEN"...
	     { tracker.setType( NotBetweenPredType.type ) ;
	       jjtThis.setBetween(false); } 
	   ] 
	   <BETWEEN> 
	   { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A()
	   { tracker.pop() ; }
	   <AND> 
	   { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A()
	   { tracker.pop() ; }
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "between_predicate_A()" ) ;
	}
}

/**
 * boolean_primary_S
 *
 * bnf-start
 *  <boolean_primary> ::=
 *     | <left_paren> <search_condition> <right_paren> 
 *       <predicate> 
 * bnf-end
 *
 */
void boolean_primary_S() #BooleanPrimary :  
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_primary_S()" ) ;
} 
{
	//S:
	// <boolean_primary> ::=
    //    <predicate>
    //  | <left_paren> <search_condition> <right_paren>
// 	try {
	    (
	    // lookahead was 6 and not happy about this 
	    // as the error messages produced are gargantuan
	       LOOKAHEAD( <LEFT_PAREN> search_condition_S() <RIGHT_PAREN> )
		   ( 
		     <LEFT_PAREN> 
		     { 
		     	tracker.push( compiler.CONDITION_ELEMENT, ClosedSearchType.type ) ; 
		        jjtThis.setParenthesized() ; 
		     }
		     search_condition_S() 
		     { tracker.pop() ; }
		     <RIGHT_PAREN> 
		   )
		   |
		   predicate_A()
	    )
// 	}// 	catch ( ParseException pex ) {		// 	   throw pex ;	// 	}
    {  	
    	if( log.isTraceEnabled() ) exitTrace ( "boolean_primary_S()" ) ;
    }
}

/**
 * boolean_term_S
 *
 * bnf-start
 *  <boolean_term> ::=
 *      <boolean_factor>
 *    | <boolean_term> AND <boolean_factor>
 * bnf-end
 *
 */
void boolean_term_S() #BooleanTerm : 
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_term_S()" ) ;
}
{
	//S:
	// <boolean_term> ::=
    //    <boolean_factor>
    //  | <boolean_term> AND <boolean_factor>

	// Refactored to
	// boolean_factor_S() ( <AND> boolean_factor_S() )?
	// which I believe is equivalent to the above
//	try {
		( boolean_factor_S() 
		  ( LOOKAHEAD(3) 
		    <AND> 
		    { tracker.push( compiler.CONDITION_ELEMENT, IntersectionSearchType.type ) ; }
		    boolean_term_S()
		    { tracker.pop() ; } 
		  )? 
		) 
//	}//	catch( ParseException pex ) {//	   errorSkipTo( new int[]{ token.kind }, pex ) ;				//	}	
	{
		if( log.isTraceEnabled() ) exitTrace ( "boolean_term_S()" ) ;
	}
}

/**
 * boolean_factor_S
 *
 * bnf-single <boolean_factor> ::= [ NOT ] <boolean_test>
 *
 */
void boolean_factor_S() #BooleanFactor :
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_factor_S()" ) ;
	Token t = null ;
}
{
//	try {
		( [ t=<NOT> ]
		  { if( t != null ) {
		  	   tracker.push( compiler.CONDITION_ELEMENT, InverseSearchType.type ) ;
		  	   jjtThis.setInverse(true);
		  	} 
		  }
		  boolean_test_A() 
		)
//	}//	catch( ParseException pex ) {//	    errorSkipTo( new int[]{ token.kind }, pex ) ;		//	}
	{ if( log.isTraceEnabled() ) exitTrace ( "boolean_factor_S()" ) ; }
}

/**
 * boolean_test_A
 *
 * bnf-start
 *  <boolean_test> ::= <boolean_primary>
 * bnf-end
 *
 */
void boolean_test_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_test_A()" ) ;
}
{
	//S:
	// <boolean_test> ::=
    //  <boolean_primary> [ IS [ NOT ] <truth_value> ]
	
	// NB: There is no accommodation of truth value in ADQL
	boolean_primary_S() 
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "boolean_test_A()" ) ; 
	}
}

/**
 * like_predicate_A
 *
 * bnf-start
 *  <like_predicate> ::=
 *      <match_value> [ NOT ] LIKE <pattern>
 * bnf-end
 *
 */
void like_predicate_A() #LikePredicate: 
{
	if( log.isTraceEnabled() ) enterTrace ( "like_predicate_A()" ) ;
}
{
	//S: 
	// <like_predicate> ::=
	//   <match_value> [ NOT ] LIKE <pattern> [ ESCAPE <escape_character> ]
      
	( match_value_S() [ <NOT> {jjtThis.setLike(false);} ] <LIKE> pattern_A() )
	{
		if( log.isTraceEnabled() ) exitTrace ( "like_predicate_A()" ) ;
	}
}

void caseExpression_S() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification_S() : {}
{
	"6-TBD castSpecification"
}

/**
 * character_factor_A
 *
 * bnf-start
 *  <character_factor> ::= <character_primary>
 * bnf-end
 *
 */
void character_factor_A() : {}
{
	//S:
	// <character_factor> ::= <character_primary> [ <collate_clause> ]
	character_primary_A()
}

/**
 * character_primary_A
 *
 * bnf-start
 *  <character_primary> ::= <value_expression_primary>
 * bnf-end
 *
 */
void character_primary_A() : {}
{
	//S:
	//  <character_primary> ::=
    //    <value_expression_primary> | <string_value_function>
//    LOOKAHEAD(16)
	value_expression_primary_A()
//	|
//    user_defined_function_A()
}

/**
 * character_string_literal_A
 *
 * bnf-start
 *  <character_string_literal> ::=
 *     <quote> [ <character_representation>... ] <quote>
 *     [ { <quote> [ <character_representation>... ] <quote> }... ]
 * bnf-end
 *
 * bnf-start
 *  <character_representation> ::=
 *  !! At present this is one ASCII character (but not a single quote).
 * bnf-end
 *
 */
void character_string_literal_A() #CharacterStringLiteral : {}
{
	//S:
	// <character_string_literal> ::=
    //    [ <introducer><character_set_specification> ]
    //    <quote> [ <character_representation>... ] <quote>
    //    [ { <separator>... <quote> [ <character_representGroupingColumnReferenceListation>... ] <quote> }... ]
	ASCIIStringLiteral()
}

void ASCIIStringLiteral() #ASCIIStringLiteral : {}
{
	( ASCIIStringLiteralPart() )+ 
}

void ASCIIStringLiteralPart() #ASCIIStringLiteralPart : {}
{
	<ASCII_STRING_LITERAL>
}

/**
 * character_value_expression_A
 *
 * bnf-start
 *  <character_value_expression> ::= <character_factor>
 * bnf-end
 *
 */
void character_value_expression_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "character_value_expression_A()" ) ;
}
{
	//S:
	// <character_value_expression> ::=
    //     <concatenation>
    //   | <character_factor>

	character_factor_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "character_value_expression_A()" ) ;
	}	
}

void collate_clause_S() : {}
{
	//S:
	// <collate_clause> ::= COLLATE <collation_name>
    // <collation_name> ::= <qualified_name>
	
	// refactored to
	<COLLATE> qualified_name_A()	
}

/**
 * column_name_S
 *
 * bnf-single <column_name> ::= <identifier>
 *
 */
void column_name_S() #ColumnName :  
{
	if( log.isTraceEnabled() ) enterTrace ( "column_name_S()" ) ;
}
{
	//S:
	// <column_name> ::= <identifier>
	identifier_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "column_name_S()" ) ;
	}
}

/**
 * column_name_list_S
 *
 * bnf-single <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
 *
 */
void column_name_list_S() : {}
{
	//S:
	// <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
	 column_name_S() ( <COMMA> column_name_S() )*	
}

/**
 * column_reference_A
 *
 * bnf-start
 *  <column_reference> ::= 
 *     [ <schema_name> <period> ] <table_name> <period> <column_name>
 *  !! Enforces qualified column names.
 * bnf-end
 *
 */
void column_reference_A() #ColumnReference : {	if( log.isTraceEnabled() ) enterTrace ( "column_reference_A()" ) ;	tracker.setType( ColumnReferenceType.type ) ;}{	//S: 	// <column_reference> ::= [ <qualifier> <period> ] <column_name>	(
	   LOOKAHEAD(5)	   ( schema_name_A() <PERIOD> table_name_A() <PERIOD> column_name_S() )
	   |
	   ( table_name_A() <PERIOD> column_name_S() )	)	{		if( log.isTraceEnabled() ) exitTrace ( "column_reference_A()" ) ;						}}

///**// * aliased_expression_reference_A// *// *-bnf-start// *- <aliased_expression_reference> ::= <identifier>// *- !! ADQL specific. // *- NB. This is simply a reference to an aliased expression.// *-bnf-end// *// *///AliasSelectionItemType aliased_expression_reference_A() ://{//	if( log.isTraceEnabled() ) enterTrace ( "aliased_expression_reference_A()" ) ;//	AliasSelectionItemType asiType = null ;//	String name = null ;//}//{//	////	// Note especially that this is simply a reference to an//	// aliased expression defined elsewhere. At this point we//	// only have the name of the alias, not the content, so we//	// can only construct an empty AliasSelectionItemType.//	// Filling in these must wait until the whole query has//	// been assembled and is thought to be syntactically correct!!!//	name=identifier_A()//	{//		if( name != null ) {//		    asiType = AliasSelectionItemType.Factory.newInstance() ;//			asiType.setAs( name ) ;//		}//	    if( log.isTraceEnabled() ) exitTrace ( "aliased_expression_reference_A()" ) ;		//	    return asiType ;	//	}//}

/**
 * value_expression_primary_A
 *
 * NB: Referred in some sources as <common_primary>
 *
 * bnf-start
 *  <value_expression_primary> ::=
 *      <unsigned_value_specification>
 *    | <column_reference>
 *    | <set_function_specification>
 *    | <left_paren> <value_expression> <right_paren>
 * bnf-end
 *
 */
void value_expression_primary_A() #ValueExpressionPrimary : 
{
	if( log.isTraceEnabled() ) enterTrace ( "value_expression_primary_A()" ) ;
}
{
	//S:
	//	<value_expression_primary> ::=
	//      <unsigned_value_specification>
	//    | <column_reference>
	//    | <set_function_specification>
	//    | <scalar_subquery>
	//    | <case_expression>
	//    | <left_paren> <value_expression> <right_paren>
	//    | <cast_specification>

	(
		// Foreshortened 
		unsigned_value_specification_S() 
		|
		column_reference_A()
		|
		set_function_specification_S()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)
	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()
	//	| 
		( 
		  <LEFT_PAREN>
		  value_expression_A() 
		  <RIGHT_PAREN> { jjtThis.setParenthesized(); }
		)
	// JBL: cast ommitted in initial version
	//	|
	//	castSpecification()
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "value_expression_primary_A()" ) ;
	}
}

/**
 * comp_op_S
 *
 * bnf-start
 *  <comp_op> ::=
 *      <equals_operator>
 *    | <not_equals_operator>
 *    | <less_than_operator>
 *    | <greater_than_operator>
 *    | <less_than_or_equals_operator>
 *    | <greater_than_or_equals_operator>
 * bnf-end
 *
 */
void comp_op_S() #Comparison : 
{
	if( log.isTraceEnabled() ) enterTrace ( "comp_op_S()" ) ;
}
{
	//S:
	// <comp_op> ::=
    //    <equals_operator>
    //  | <not_equals_operator>
    //  | <less_than_operator>
    //  | <greater_than_operator>
    //  | <less_than_or_equals_operator>
    //  | <greater_than_or_equals_operator>
	(
	   <EQUALS_OPERATOR> 
	   |
	   <NOT_EQUALS_OPERATOR> 
	   |
	   <LESS_THAN_OPERATOR> 
	   | 
	   <GREATER_THEN_OPERATOR> 
	   | 
	   <LESS_THAN_OR_EQUALS_OPERATOR> 
	   | 
	   <GREATER_THAN_OR_EQUALS_OPERATOR>	
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "comp_op_S()" ) ;
	}
}

/**
 * comparison_predicate_A
 *
 * bnf-start
 *  <comparison_predicate> ::=
 *      <value_expression> <comp_op> <value_expression>
 * bnf-end
 *
 */
void comparison_predicate_A() #ComparisonPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "comparison_predicate_A()" ) ;
	tracker.setType( ComparisonPredType.type ) ;
}
{
	//S:
	//  <row_value_constructor> <comp_op> <row_value_constructor>
//	try {		( 
		  { tracker.push( compiler.ARG_ELEMENT ) ; }
		  value_expression_A() 
		  { tracker.pop() ; }
		  comp_op_S() 
		  { tracker.push( compiler.ARG_ELEMENT ) ; }
		  value_expression_A() 
		  { tracker.pop() ; }
		)
//	}//	catch( ParseException pex ) {//		errorSkipTo( new int[]{ token.kind }, pex ) ;//	}
	{ 
	   if( log.isTraceEnabled() ) exitTrace( "comparison_predicate_A()" ) ;	
	}
}

/**
 * correlation_name_S
 *
 * bnf-single <correlation_name> ::= <identifier>
 *
 */
void correlation_name_S() #CorrelationName : 
{
	if( log.isTraceEnabled() ) enterTrace ( "correlation_name_S()" ) ;
}
{
	//S:
	// <correlation_name> ::= <identifier>
	try {
	   identifier_A()
	}
	catch( ParseException pex ) {
		compiler.errorSkipTo( new int[]{ token.kind }, pex ) ;	
	}
	
	{ if( log.isTraceEnabled() ) exitTrace ( "correlation_name_S()" ) ; }
}

void datetime_factor_S() : {}
{
	//S:
	//  <datetime_factor> ::=
    //     <datetime_primary> [ <time_zone> ]
    
	datetime_primary_S() [  LOOKAHEAD(2) time_zone_S() ]
}

void datetime_primary_S() : {}
{
	//S:
	// <datetime_primary> ::=
    //    <value_expression_primary>
    //  | <datetime_value_function>

	value_expression_primary_A()
    | 
    datetime_value_function_S()
}

void datetime_term_S() : {}
{
	//S:
	// <datetime_term> ::= <datetime_factor>
    datetime_factor_S()
}

void datetime_value_expression_S() : {}
{
	//S:
	// <datetime_value_expression> ::=
    //    <datetime_term>
    //  | <interval_value_expression> <plus_sign> <datetime_term>
    //  | <datetime_value_expression> <plus_sign> <interval_term>
    //  | <datetime_value_expression> <minus_sign> <interval_term>

	// refactored to
	LOOKAHEAD(3)
    ( datetime_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) datetime_value_expression_S() )* )
    |
    ( interval_value_expression_S() <PLUS_SIGN> datetime_term_S() )
}

void datetime_value_function_S() : {}
{
	//S:
	// <datetime_value_function> ::=
    //    <current_date_value_function>
    //  | <current_time_value_function>
    //  | <current_timestamp_value_function>

	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LEFT_PAREN> time_precision_S() <RIGHT_PAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LEFT_PAREN> timestamp_precision_S() <RIGHT_PAREN> ]
}

/**
 * derived_column_list_S
 *
 * bnf-single <derived_column_list> ::= <column_name_list>
 *
 */
void derived_column_list_S() : {}
{
	//S:
	// <derived_column_list> ::= <column_name_list>
   column_name_list_S()	
}

void derived_table_S() : {}
{
	//S:
	// <derived_table> ::= <table_subquery>
   	table_subquery_S()
}

void end_field_S() : {}
{
	//S:
	// <end_field> ::=
    //    <non-second_datetime_field>
    //  | SECOND [ <left_paren> <interval_fractional_seconds_precision> <right_paren> ]
	nonsecond_datetime_field_S() | <SECOND> [ <LEFT_PAREN> interval_fractional_seconds_precision_S() <RIGHT_PAREN> ]
}

void escape_character_A() : {}
{
	//S:
	// <escape_character> ::= <character_value_expression>
	character_value_expression_A()	
}

/**
 * exact_numeric_literal_S
 *
 * bnf-start
 *  <exact_numeric_literal> ::=
 *      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]
 *    | <period> <unsigned_integer>
 * bnf-end
 *
 */
void exact_numeric_literal_S( int possibleSignChange ) #ExactNumericLiteral :
{
	if( log.isTraceEnabled() ) enterTrace ( "exact_numeric_literal_S()" ) ;
	jjtThis.setPossibleSignChange( possibleSignChange ) ;
	//tracker.setType( AtomType.type ) ;
}
{
	//S:
	//  <exact_numeric_literal> ::=    //      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]    //    | <period> <unsigned_integer>
    
    // NB: The repeat check below for <UNSIGNED_INTEGER>!
    // Not sure whether there is a better way of doing this...
    // <EXACT_NUMERIC_LITERAL> and <UNSIGNED_INTEGER> compete
    // with each other as tokens. Where only an unsigned integer
    // is used, they both represent the same thing (!), and the token
    // manager chooses unsigned integer (probably because it happens
    // to be before exact numeric literal in the token list)!
    //
    // This is probably worthy of study to see whether a more
    // stable way of doing this is possible.
//    try {
		( <EXACT_NUMERIC_LITERAL> | <UNSIGNED_INTEGER> )
		{ if( log.isTraceEnabled() ) exitTrace ( "exact_numeric_literal_S()" ) ; }
//    }//    catch( ParseException pex ) {//    	log.debug( "exact_numeric_literal_S complained, token.image: " + token.image ) ;//    	throw pex ;//    }
}

SearchType exists_predicate_S() : 
{
	SearchType st = null ;
}
{
	//S: 
	// <exists_predicate> ::= EXISTS <table_subquery>
	<EXISTS> st=table_subquery_S()
	{ 
		if( st != null ) {
		}
		
		return st ;	
	}	
}

void explicit_table_S() : {}
{
	//S:
	// <explicit_table> ::= TABLE <table_name>
	<TABLE> table_name_A()
}

/**
 * factor_S
 *
 * bnf-single <factor> ::= [ <sign> ] <numeric_primary> 
 *
 */
void factor_S() #Factor : 
{
	if( log.isTraceEnabled() ) enterTrace ( "factor_S()" ) ;
	Token t = null ;
}
{
	//S:
	// <factor> ::= [ <sign> ] <numeric_primary>  
	( 
	  [
	    t=sign_S() 
	    {  if( t!=null ) {
	    	  jjtThis.setSign(t) ;
	       }
	    } 
	  ] 
	  numeric_primary_S() 
	)
	{ 
	   if( log.isTraceEnabled() ) exitTrace ( "factor_S()" ) ;
	}
}

/**
 * sign
 *
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 *
 */
Token sign_S() #Sign : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sign_S()" ) ;
    Token t = null ;
}
{
	( t=<PLUS_SIGN> | t=<MINUS_SIGN> )
	{ 
	   if( log.isTraceEnabled() ) exitTrace ( "sign_S()" ) ;
	   return t ;
	}
}

/**
 * from_clause_S
 *
 * bnf-start
 *  <from_clause> ::= FROM <table_reference>
 *     [ { <comma> <table_reference> }... ]
 * bnf-end
 *
 */
void from_clause_S() #From : 
{
    if( log.isTraceEnabled() ) enterTrace ( "from_clause_S()" ) ;
    tracker.push( compiler.FROM_ELEMENT, FromType.type ) ;
}
{
	//S:
	// FROM <table_reference>
    // [ { <comma> <table_reference> }... ]
	try {		
	   (  <FROM> table_reference_A() ( <COMMA> table_reference_A() )*  )
	}
	catch( ParseException pex ) {		compiler.errorSkipTo( compiler.FROM_SKIP_TO, pex ) ;
	}
	finally {
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "from_clause_S()" ) ;
	}

}


/**
 * general_literal_A
 *
 * bnf-start
 *  <general_literal> ::= <character_string_literal>
 * bnf-end
 *
 */
void general_literal_A() : {}
{
	//S:
	//  <general_literal> ::=
    //    <character_string_literal>
    //  | <national_character_string_literal>
    //  | <bit_string_literal>
    //  | <hex_string_literal>
    //  | <datetime_literal>
    //  | <interval_literal>
	character_string_literal_A()	
}

/**
 * general_set_function_A
 *
 * bnf-start
 *  <general_set_function> ::=
 *     <set_function_type>
 *         <left_paren> <value_expression> <right_paren>
 * bnf-end
 *
 * bnf-single <set_function_type> ::= AVG | MAX | MIN | SUM | COUNT
 *
 */
void general_set_function_A() #GeneralSetFunction : 
{  tracker.setType( AggregateFunctionType.type ) ; }
{
	//S:
	// <general_set_function> ::=
    //   <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>

	// JBL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( <AVG> | <MAX> | <MIN> | <SUM> | <COUNT> ) <LEFT_PAREN> [ setQuantifier() ] value_expression_A() <RIGHT_PAREN>	
	( <AVG> | <MAX> | <MIN> | <SUM> | <COUNT> ) 
	<LEFT_PAREN>
	   { tracker.push( compiler.ARG_ELEMENT ) ; } 
	   value_expression_A() 
	   { tracker.pop() ; }
	<RIGHT_PAREN>
}

/**
 * general_value_specification_A
 *
 * -bnf-start
 * - <general_value_specification> ::= <variable_specification>
 * - !! There is no accommodation for <parameter_specification>, <dynamic_parameter_specification>,
   -    USER, CURRENT_USER, SESSION_USER, SYSTEM_USER and VALUE
 * -bnf-end
 *
 */
ScalarExpressionType general_value_specification_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	//<general_value_specification> ::=
    //   <parameter_specification>
    // | <dynamic_parameter_specification>
    // | <variable_specification>
    // | USER
    // | CURRENT_USER
    // | SESSION_USER
    // | SYSTEM_USER
    // | VALUE
	
	// Foreshortened
	seType=variable_specification_A()
	{ return seType ; }	
}

/**
 * group_by_clause_S
 *
 * bnf-start
 *  <group_by_clause> ::= GROUP BY <grouping_column_reference_list>
 * bnf-end
 *
 */
void group_by_clause_S() #GroupBy : 
{
	if( log.isTraceEnabled() ) enterTrace ( "group_by_clause_S()" ) ;
	tracker.push( compiler.GROUPBY_ELEMENT, GroupByType.type ) ; 
}
{
	//S:
	// GROUP BY <grouping_column_reference_list>
	( <GROUPBY> grouping_column_reference_list_S() )
	{
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "group_by_clause_S()" ) ;
	}
}

/**
 * grouping_column_reference_list_S
 *
 * bnf-start
 *  <grouping_column_reference_list> ::=
 *      <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
 * bnf-end
 *
 */
void grouping_column_reference_list_S() #GroupingColumnReferenceList : 
{
    if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_list_S()" ) ;
}
{
	//S:
	// <grouping_column_reference_list> ::=
    //   <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
	( grouping_column_reference_A() ( <COMMA> grouping_column_reference_A() )* ) 
	{
		if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_list_S()" ) ;
	}
}

/**
 * grouping_column_reference_A
 *
 * bnf-start
 *  <grouping_column_reference> ::= <column_reference> 
 * bnf-end
 *
 */
void grouping_column_reference_A() : 
{
    if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_A()" ) ;
}
{
    //S:
    // <grouping_column_reference> ::=
    //      <column_reference> [ <collate_clause> ]
	column_reference_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_A()" ) ;
	}	
}

/**
 * having_clause_S
 *
 * bnf-single <having_clause> ::= HAVING <search_condition>	
 *
 */
void having_clause_S() #Having :
{
	if( log.isTraceEnabled() ) enterTrace ( "having_clause_S()" ) ;
	tracker.push( compiler.HAVING_ELEMENT, HavingType.type ) ;
}
{	
	//S:
	//  HAVING <search_condition>	
	( <HAVING> search_condition_S() )
	{	
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "having_clause_S()" ) ;	
	}
}

/**
 * identifier_A
 *
 * bnf-start
 *  <identifier> ::= <actual_identifier>
 * bnf-end
 *
 */
void identifier_A() : {}
{
	//S:
	// <identifier> ::=
    //   [ <introducer><character_set_specification> ] <actual_identifier>
	actual_identifier_S()
} 

/**
 * in_predicate_A
 *
 * bnf-start
 *  <in_predicate> ::=
 *      <value_expression> [ NOT ] IN <in_predicate_value>
 * bnf-end
 *
 */
void in_predicate_A() #InPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "in_predicate_A()" ) ;
}
{
	//S:
	// <in_predicate> ::=
    //   <row_value_constructor> [ NOT ] IN <in_predicate_value>
    
	// refactored to
	( 
	  value_expression_A() [ <NOT> {jjtThis.setIn(false);} ] <IN> in_predicate_value_S()
	)
    {
       if( log.isTraceEnabled() ) exitTrace ( "in_predicate_A()" ) ;	
	}
}

/**
 * in_predicate_value_S
 *
 * bnf-start
 *  <in_predicate_value> ::=
 *     <table_subquery> | <left_paren> <in_value_list> <right_paren>
 * bnf-end
 *
 */
void in_predicate_value_S() #InPredicateValue : 
{
	if( log.isTraceEnabled() ) enterTrace ( "in_predicate_value_S()" ) ;
}
{
	//S:
    // <in_predicate_value> ::= <table_subquery>  | <left_paren> <in_value_list> <right_paren>
	
	( LOOKAHEAD(2) table_subquery_A() | ( <LEFT_PAREN> in_value_list_A() <RIGHT_PAREN> ) )
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "in_predicate_value_S()" ) ;
	} 	
}

void interval_factor_S() : {}
{
	//S:
	// <interval_factor> ::=
    //   [ <sign> ] <interval_primary>

    [ <PLUS_SIGN> | <MINUS_SIGN> ] interval_primary_S()
}

void interval_fractional_seconds_precision_S() : {}
{
	//S:
	// <interval_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_leading_field_precision_S() : {}
{
	//S:
	// <interval_leading_field_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_primary_S() : {}
{
	//S:
	// <interval_primary> ::=
    //    <value_expression_primary> [ <interval_qualifier> ]

      value_expression_primary_A() [ LOOKAHEAD(2) interval_qualifier_S() ]
}

void interval_qualifier_S() : {}
{
	//S:
	// <interval_qualifier> ::=
    //    <start_field> TO <end_field> | <single_datetime_field>

	LOOKAHEAD(3)
    start_field_S() <TO> end_field_S()
    | 
    single_datetime_field_S()
}

void interval_term_S() : {}
{
	//S:
	// <interval_term> ::=
    //    <interval_factor>
    //  | <interval_term_2> <asterisk> <factor>
    //  | <interval_term_2> <solidus> <factor>
    //  | <term> <asterisk> <interval_factor>

	// refactored...
	LOOKAHEAD(3)
	interval_factor_S() 
    |
	LOOKAHEAD(3)    
    factor_S() (<ASTERISK> | <SOLIDUS>) interval_term_S()
    | 
    term_S() <ASTERISK> interval_factor_S()
}

void interval_value_expression_S() : {}
{
	//S:
	// <interval_value_expression> ::=
    //    <interval_term>
    //  | <interval_value_expression_1> <plus_sign> <interval_term_1>
    //  | <interval_value_expression_1> <minus_sign> <interval_term_1>
    //  | <left_paren> <datetime_value_expression> <minus_sign>
    //      <datetime_term> <right_paren> <interval_qualifier>

	// refactored
	LOOKAHEAD(3)
	interval_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) interval_term_S() )*
    | 
    <LEFT_PAREN> datetime_value_expression_S() <MINUS_SIGN> datetime_term_S() <RIGHT_PAREN> interval_qualifier_S()
}

/**
 * in_value_list_A
 *
 * bnf-start
 *  <in_value_list> ::=
 *      <in_value_list_constant> { <comma> <in_value_list_constant> }...
 * bnf-end
 *
 */
void in_value_list_A() #InValueList : {}
{
	//S:
	// <in_value_list> ::=
    //   <value_expression> { <comma> <value_expression> }...    
    ( in_value_list_constant_A() ( <COMMA> in_value_list_constant_A() )* )
}

/**
 * in_value_list_constant_A
 *
 * bnf-start
 *  <in_value_list_constant> ::=
 *	       [ <plus_sign> | <minus_sign> ] <exact_numeric_literal>
 *	    |  <character_string_literal> 
 * bnf-end
 *
 */
void in_value_list_constant_A() #InValueListConstant : 
{
	int signChange = +1 ;
	Token t = null ;
}
{
	//A:
	// <in_value_list_constant_A> ::=
	//      [ <plus> | <minus> ] <exact_numeric_literal_S>
	//      |
	//      <character_string_literal_A> 
	(
	  (
	    ( [ (<PLUS_SIGN> | t=<MINUS_SIGN>) {if(t != null) signChange = -1 ;} ] ) exact_numeric_literal_S( signChange ) 
	  )
	  |
	  character_string_literal_A()
	)
}

/**
 * join_specification_A
 *
 * bnf-start
 *  <join_specification> ::= <join_condition>	
 * bnf-end
 *
 * bnf-start
 *  <join_condition> ::= ON <comparison_predicate>
 * bnf-end
 *
 */
void join_specification_A() : {}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
    
	<ON> comparison_predicate_A()
}

/**
 * joined_table_S
 *
 *-bnf-start
 *- <joined_table> ::=
 *-     <cross_join>
 *-   | <qualified_join>
 *-   | <left_paren> <joined_table> <right_paren>
 *-bnf-end
 
 * bnf-start
 *  <joined_table> ::=
 *      <qualified_join>
 * bnf-end
 *
 */
void joined_table_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "joined_table_S()" ) ;
}
{
	//S:
	// <joined_table> ::=
    //    <cross_join>
    //  | <qualified_join>
    //  | <left_paren> <joined_table> <right_paren>
	(
// 
//		LOOKAHEAD(4)//		cross_join_S()//		|
//		LOOKAHEAD(4)
		qualified_join_S()
// JBL. 29/01/2008 Commented out to disable n-way explicit joins with brackets.
//		|//		( <LEFT_PAREN> joined_table_S() <RIGHT_PAREN> )
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "joined_table_S()" ) ;
	}
}

/**
 * join_type_A
 *
 * bnf-start
 *  <join_type> ::=
 *     INNER
 *   | <outer_join_type> [ OUTER ]
 * bnf-end
 *
 * bnf-single <outer_join_type> ::= LEFT | RIGHT 
 *
 */
void join_type_A() #JoinType : {}
{
	//S:
	// <join_type> ::=
    //    INNER
    //  | <outer_join_type> [ OUTER ]
    //  | UNION

		// refactored to...
		(
		   <INNER>
	       | 
// JBL. 30/01/2008 FULL removed. Cannot currently support it in MySQL
//	       ( ( <LEFT> | <RIGHT> | <FULL> ) [ <OUTER> ] )
	       ( ( <LEFT> | <RIGHT> ) [ <OUTER> ] )
// JL. Adql does not appear to support UNION
//	       | 
//	       <UNION>
        )
}

/**
 * match_value_S
 *
 * bnf-single <match_value> ::= <character_value_expression>
 *
 */
void match_value_S() #MatchValue : 
{
    if( log.isTraceEnabled() ) enterTrace ( "match_value_S()" ) ;
}
{
	//S:
	// <match_value> ::= <character_value_expression>

	character_value_expression_A()
	{
	   if( log.isTraceEnabled() ) exitTrace ( "match_value_S()" ) ;
	}	
}

void match_predicate_S() : {}
{
	//S:
	// <match_predicate> ::=
    //   <row_value_constructor> MATCH [ UNIQUE ] [ PARTIAL | FULL ] <table_subquery>

	row_value_constructor_S() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] table_subquery_S() 
}

/**
 * math_function_A
 *
 * bnf-start
 *  <math_function> ::=
 *      ABS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | CEILING <left_paren> <numeric_value_expression> <right_paren> 
 *	  | DEGREES <left_paren> <numeric_value_expression> <right_paren> 
 *	  | EXP <left_paren> <numeric_value_expression> <right_paren> 
 *	  | FLOOR <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG <left_paren> <numeric_value_expression> <right_paren> 
 *	  | PI <left_paren><right_paren> 
 *	  | POWER <left_paren> <numeric_value_expression> <comma> <unsigned_integer> <right_paren> 
 *	  | RADIANS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQUARE <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQRT <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG10 <left_paren> <numeric_value_expression> <right_paren> 
 *	  | RAND <left_paren> [ <unsigned_integer> ] <right_paren> 
 *	  | ROUND <left_paren> <numeric_value_expression> [ <comma> <signed_integer> ] <right_paren> 
 *	  | TRUNCATE <left_paren> <numeric_value_expression> [ <comma> <signed_integer> ] <right_paren> 
 * bnf-end
 *
 */
void math_function_A() #MathFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "math_function_A()" ) ;
    Token arg2 = null ;
    Long signedLong ;
    tracker.setType( MathFunctionType.type ) ;
}
{
	(
		( <ABS> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } 
		        numeric_value_expression_S() 
		        { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <CEILING> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <DEGREES> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <EXP> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <FLOOR> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <LOG> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <PI> 
		     <LEFT_PAREN><RIGHT_PAREN> )
		|
		( <POWER> 
		     <LEFT_PAREN> 
                { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <COMMA> 
		        arg2=<UNSIGNED_INTEGER> {jjtThis.setArg2(new Long(arg2.image));} 
		     <RIGHT_PAREN> )
		|
		( <RADIANS> 
		     <LEFT_PAREN> 
                { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <SQUARE> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <SQRT> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <LOG10> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <RAND> 
		     <LEFT_PAREN> 
		         [ { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } ] 
		     <RIGHT_PAREN> )
		|
		( <ROUND> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		        [ <COMMA> signedLong=signed_integer_S() { jjtThis.setArg2( signedLong ) ; } ]
		     <RIGHT_PAREN> )
		|
		( <TRUNCATE> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		        [ <COMMA> signedLong=signed_integer_S() { jjtThis.setArg2( signedLong ) ; } ]
		     <RIGHT_PAREN> )
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "math_function_A()" ) ;
	}
}

void null_predicate_S() : {}
{
	//S:
	// <null_predicate> ::= 
	//   <row_value_constructor> IS [ NOT ] NULL

	row_value_constructor_S() <IS> [ <NOT> ] <NULL>	
}

/**
 * numeric_primary_S
 *
 * bnf-start
 *  <numeric_primary> ::=
 *      <value_expression_primary>
 *    | <numeric_value_function>
 * bnf-end
 *
 */
void numeric_primary_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_primary_S()" ) ;
}
{
	//S:
	// <numeric_primary> ::=
    //    <value_expression_primary>
    //  | <numeric_value_function>
    
    // Refactored to...
	( 
	  LOOKAHEAD(3)
	  numeric_value_function_A()	
	  |
	  value_expression_primary_A()
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "numeric_primary_S()" ) ;
	} 
	
}

/**
 * numeric_value_expression_S
 *
 * bnf-start
 *  <numeric_value_expression> ::=
 *      <term>
 *    | <numeric_value_expression> <plus_sign> <term>
 *    | <numeric_value_expression> <minus_sign> <term>
 * bnf-end
 *
 */
void numeric_value_expression_S() #NumericValueExpression : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_value_expression_S()" ) ;
	Token t = null ;
}
{
	//S:
	// <numeric_value_expression> ::=
    //    <term>
    //  | <numeric_value_expression> <plus_sign> <term>
    //  | <numeric_value_expression> <minus_sign> <term>
	
	// refactored to...
	( term_S() 
	  ( 
	     LOOKAHEAD(3) 
	     ( 
	        ( t=<PLUS_SIGN> | t=<MINUS_SIGN> ) 
	        { 
	           if( t!=null ) {
	           	  jjtThis.setOperator(t);
	           }
	        } 
	     ) numeric_value_expression_S() )? 
	)
    {
        if( log.isTraceEnabled() ) exitTrace ( "numeric_value_expression_S()" ) ;		
	}
}

/**
 * numeric_value_function_A
 *
 * bnf-start
 *  <numeric_value_function> ::= <trig_function> | <math_function>	
 * bnf-end
 *
 */
void numeric_value_function_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_value_function_A()" ) ;
}
{
	//S:
	//<numeric_value_function> ::=
    //   <position_expression>
    // | <extract_expression>
    // | <length_expression>

	(
		// JBL ADQL adaptation
		trig_function_A()
		|
		math_function_A()	
//	    |
//	    user_defined_function_A()
		
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "numeric_value_function_A()" ) ;	
	}
}

// JL Note: Experimental.
void user_defined_function_A() #UserDefinedFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "user_defined_function_A()" ) ;
	tracker.setType( UserDefinedFunctionType.type ) ;
	Token t = null ;
}
{
	(
		( t=<REGULAR_IDENTIFIER> 
		     <LEFT_PAREN> 
		     [
                { tracker.push( compiler.ARG_ELEMENT ) ; } value_expression_A() { tracker.pop() ; }
                ( <COMMA> 
                  { tracker.push( compiler.ARG_ELEMENT ) ; } value_expression_A() { tracker.pop() ; } )* 
             ]	       
		     <RIGHT_PAREN> 
		     { if(t!=null) {
		     	  if( t.image.startsWith( "f" ) == false ) {
		     	  	 throw new ParseException( "User Defined Functions must begin with \"f\"" ) ;
		     	  }
		          jjtThis.setFunctionName( t.image ) ;
		       }
		     }
		)
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "user_defined_function_A()" ) ;
	}
}


/**
 * order_by_clause
 *
 * bnf-start
 *  <order_by_clause> ::= ORDER BY <sort_specification_list>
 * bnf-end
 *
 */
void order_by_clause_S() #OrderByClause :
 //	public static final String ORDERBY_ELEMENT = "OrderBy" ;
{ 
	if( log.isTraceEnabled() ) enterTrace ( "order_by_clause_S()" ) ;
	tracker.push( compiler.ORDERBY_ELEMENT ) ; 
} 
{
	//S:
	//	ORDER BY <sort_specification_list>
	//
	( <ORDERBY> sort_specification_list() )
	{ 
	  tracker.pop() ; 
	  if( log.isTraceEnabled() ) exitTrace ( "order_by_clause_S()" ) ;
	}
}

/**
 * sort_specification_list
 *
 * bnf-start
 *  <sort_specification_list> ::=
 *      <sort_specification> [ { <comma> <sort_specification> }... ]
 * bnf-end 
 *
 */
void sort_specification_list() #SortSpecificationList : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sort_specification_list()" ) ;
} 
{
	//S:
	// <sort_specification_list> ::=
	//    <sort_specification> [ { <comma> <sort_specification> }... ]
	
	// refactored to...
	( sort_specification_A() ( <COMMA> sort_specification_A() )* )
	
	{
		if( log.isTraceEnabled() ) exitTrace ( "sort_specification_list()" ) ;	
	}
}

/**
 * sort_specification_A
 *
 * bnf-start
 *  <sort_specification> ::=
 *      <sort_key> [ <ordering_specification> ]e>
 * bnf-end
 *
 * bnf-start
 *  <sort_key> ::= <value_expression>
 * bnf-end 
 *
 * bnf-single <ordering_specification> ::= ASC | DESC
 */
void sort_specification_A() #SortSpecification : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sort_specification_A()" ) ;
}
{
	( value_expression_A() [ ordering_specification_S() ] )
	
	{
		if( log.isTraceEnabled() ) exitTrace ( "sort_specification_A()" ) ;
	}
}

void ordering_specification_S() #OrderingSpecification : 
{
    if( log.isTraceEnabled() ) enterTrace ( "ordering_specification_S()" ) ;
}
{
	( <ASC> | <DESC> )
	{
		if( log.isTraceEnabled() ) exitTrace ( "ordering_specification_S()" ) ;
	}
}

void overlaps_predicate_S() : {}
{
	//S:
	// <overlaps_predicate> ::=
    //   <row_value_constructor_1> OVERLAPS <row_value_constructor_2>
    //
    // <row_value_constructor_1> ::= <row_value_constructor>
    // <row_value_constructor_2> ::= <row_value_constructor>

	row_value_constructor_S() <OVERLAPS> row_value_constructor_S()	
}

/**
 * pattern_A
 *
 * bnf-start
 *  <pattern> ::= <character_string_literal>
 * bnf-end
 *
 */
void pattern_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "pattern_A()" ) ;
}
{
	//S:
	//   <pattern> ::= <character_value_expression>
	character_string_literal_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "pattern_A()" ) ;
	}	
}

/**
 * predicate_A
 *
 * bnf-start
 *  <predicate> ::=
 *     <comparison_predicate>
 *   | <between_predicate>
 *   | <in_predicate>
 *   | <like_predicate>
 * bnf-end
 *
 */
void predicate_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "predicate_A()" ) ;
	tracker.push( compiler.CONDITION_ELEMENT ) ;
}
{
	//S:
	//    <comparison_predicate>
	//    | <between_predicate>
	//    | <in_predicate>
	//    | <like_predicate>
	//    | <null_predicate>
	//    | <quantified_comparison_predicate>
	//    | <exists_predicate>
	//    | <unique_predicate>
	//    | <match_predicate>
	//    | <overlaps_predicate>
//	try {
		  (
	//		region_predicate_A()    
	//		|
	
	// NB: Possible site of some specialized processing to make the
	//     lookahead more efficient (and of greater range!!!)
	//     LOOKAHEAD(2147483647)
 		    LOOKAHEAD(2147483647)
			comparison_predicate_A()
		    | 
		    LOOKAHEAD(2147483647)
		    between_predicate_A()
		    |
		    LOOKAHEAD(2147483647)
		    in_predicate_A()
		    |
		    LOOKAHEAD(2147483647) // WAS DEFAULT
		    like_predicate_A()
	//	    | 
	// adql does not support the null predicate!
	//	    LOOKAHEAD(3)
	//	    nullPredicate()
	//	    | 
	// adql does not support quantified comparisons
	//	    LOOKAHEAD(3)
	//		quantifiedComparisonPredicate()
	//	    |
	// adql does not support EXISTS 
	//	    existsPredicate()
	//	    | 
	// adql does not support UNIQUE
	//	    uniquePredicate()
	//	    | 
	// adql does not support match
	//	    LOOKAHEAD(3)
	//	    matchPredicate()
	//	    | 
	// adql does not support overlap
	//	    overlapsPredicate()
	//    		        
	    )
//	}//	catch( ParseException pex ) {//	    errorSkipTo( new int[] { token.kind }, pex ) ;	//	}
    { 
    	tracker.pop() ;
    	if( log.isTraceEnabled() ) exitTrace ( "predicate_A()" ) ;
    }
}

/**
 * qualified_join_S
 *
 * bnf-start
 *  <qualified_join> ::=
 *      <simple_table_reference> [ <join_type> ] JOIN
 *      <simple_table_reference> [ <join_specification> ]
 * bnf-end
 *
 * 
 *
 */
void qualified_join_S() #QualifiedJoin : 
{
	if( log.isTraceEnabled() ) enterTrace ( "qualified_join_S()" ) ;
}
{
	//S:
	// <qualified_join> ::=
    //    <table_reference> [ NATURAL ] [ <join_type> ] JOIN
    //    <table_reference> [ <join_specification> ]
	
	(
		tableReferenceBarJoinedTable() 
// JBL: 29/01/2008 Natural cannot be supported in current XML schema
//		[ <NATURAL> ] 
		join_type_A() 
		<JOIN> 
		tableReferenceBarJoinedTable() 
		[ LOOKAHEAD(3) join_specification_A() ]
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "qualified_join_S()" ) ;
	}
} 


void table_array_fragment() #TableArrayFragment : 
{
    if( log.isTraceEnabled() ) enterTrace ( "table_array_fragment()" ) ;
}
{
	(
	   tableReferenceBarJoinedTable()
	   <COMMA> 
	   table_reference_A() 
	   <SEMICOLON>
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "table_array_fragment()" ) ;	
	}
}


/**
 * qualified_name_A
 *  
 *  JL Note: Removed for the moment. Problems with semantic lookahead
 *           made this approach too difficult in the time available.
 * 
 * -bnf-start
 *  -<qualified_name> ::= [ <schema_name> <period> ] <identifier>
 *  -!! SQL92 has [ <schema_name> <period> ] <qualified_identifier>
 * -bnf-end
 *
 */
void qualified_name_A() #QualifiedName : 
{
    if( log.isTraceEnabled() ) enterTrace ( "qualified_name_A()" ) ;
} 
{
	//S:
	// <qualified_name> ::=
    //   [ <schema_name> <period> ] <qualified_identifier>
    
    // JL: LOOKAHEAD requires explanation
    ( [ LOOKAHEAD( schema_name_A() <PERIOD>                 , { ( getToken(3).kind == AdqlStoXConstants.REGULAR_IDENTIFIER                  	   ||                 	   getToken(3).kind == AdqlStoXConstants.DELIMITED_IDENTIFIER                 	 )                 	 &&                  	 ( getToken(4).kind == AdqlStoXConstants.PERIOD )                 	 &&                 	 ( getToken(5).kind == AdqlStoXConstants.REGULAR_IDENTIFIER                  	   ||                 	   getToken(5).kind == AdqlStoXConstants.DELIMITED_IDENTIFIER                 	 )                   } 
                 )
        schema_name_A() <PERIOD> ]    ) 
       identifier_A() 
    {
        if( log.isTraceEnabled() ) exitTrace ( "qualified_name_A()" ) ;	
    }
}


/**
 * schema_name_A
 *
 * bnf-start
 *    <schema_name> ::= <identifier>
 * bnf-end
 *
 */
void schema_name_A() #SchemaName : 
{
   if( log.isTraceEnabled() ) enterTrace ( "schema_name_A()" ) ;
}
{
	//S:
	//  <schema name> ::=
	//    [ <catalog name> <period> ] <unqualified schema name>
	identifier_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "schema_name_A()" ) ;
	}
}

/**
 * 
 *
 * bnf-start
 *  <qualifier> ::= <table_name> 
 * bnf-end
 *
 */
void qualifier_A() : 
{
   if( log.isTraceEnabled() ) enterTrace ( "qualifier_A()" ) ;
}
{
	//S:
	// <qualifier> ::=
    //    <table_name> 
    //  | <correlation_name>

	// Foreshortened
	table_name_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "qualifier_A()" ) ;
	}
}

/**
 * 
 *
 * bnf-start
 *  <query_specification> ::=
 *      SELECT [ <set_quantifier> ] [ <set_limit> ] <select_list> <table_expression>
 * bnf-end
 *
 * bnf-start
 *  <table_expression> ::=
 *      <from_clause>
 *      [ <where_clause> ]
 *      [ <group_by_clause> ]
 *      [ <having_clause> ]
 *      [ <order_by_clause> ]
 * bnf-end 
 *
 */
void query_specification_A() #Select : 
{
    if( log.isTraceEnabled() ) enterTrace ( "query_specification_A()" ) ;
    tracker.push( compiler.SELECT_ELEMENT, SelectType.type ) ;
}
{ 
	(
	//S:
	// SELECT [ <set_quantifier> ] <select_list> <table_expression>
	//
	// <table_expression> ::=
	//    <from_clause>
    //    [ <where_clause> ]
    //    [ <group_by_clause> ]
    //    [ <having_clause> ]
	 
	//A:
	// Refactored to include <set-limit> and to bring up <table_expression> 
	// into this method. <table_expression> also now includes <order_by_clause>

		<SELECT>
		[ set_quantifier_S() ]
		[ set_limit_A() ] 
		select_list_S() 
		from_clause_S() 
		[ LOOKAHEAD(3) where_clause_S() ] 		
		[ LOOKAHEAD(3) group_by_clause_S() ] 		
		[ LOOKAHEAD(3) having_clause_S() ] 		
		[ LOOKAHEAD(3) order_by_clause_S() ]	
		[ <SEMICOLON> ]
    )
	{ 
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "query_specification_A()" ) ;
	}
}

RegionSearchType region_predicate_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "region_predicate_A()" ) ;
	RegionSearchType st = null ;
	RegionType rt = null ;
	Token t = null ;
}
{
	//A:
	// <region> <left_paren> <region_specification_A> <right_paren>
	<REGION> <LEFT_PAREN> rt=region_specification_A() t=<RIGHT_PAREN>
	{ 
		if( t != null ) {
		   st = RegionSearchType.Factory.newInstance() ;	
		   st.setRegion( rt ) ;
		}
		if( log.isTraceEnabled() ) exitTrace ( "region_predicate_A()" ) ;
		return st ; 
	}
	
}

RegionType region_specification_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "region_specification_A()" ) ;
    RegionType rt = null ;
}
{
	(
		rt=circle_region_A() 
		|
		rt=ellipse_region_A()
		|
		polygon_region_A()
		|
		sector_region_A()
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "region_specification_A()" ) ;
		return rt ; 
	}
}

CircleType circle_region_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_region_A()" ) ;
	String coordSystem = null ;
	Object[] radiusParams = null ;
	List coords = null ;
	CircleType circleType = null ;
}
{
	(
	<CIRCLE> coordSystem=coord_system_A()
	<CENTER> <EQUALS_OPERATOR> coords=coords_2_A() 
	<RADIUS> <EQUALS_OPERATOR> radiusParams=circle_radius_A()
	)	
	{
		if( radiusParams != null ) {
			circleType = CircleType.Factory.newInstance() ;
			circleType.setCenter( coords ) ;
			circleType.setRadius( ((Double)radiusParams[0]).doubleValue() ) ;
			circleType.setCoordSystemId( coordSystem ) ;
			circleType.setUnit( (PosUnitType.Enum)radiusParams[1] ) ;
		}
		if( log.isTraceEnabled() ) exitTrace ( "circle_region_A()" ) ;
		return circleType ;
	}
}

EllipseType ellipse_region_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "ellipse_region_A()" ) ;
	Double minorRadius = null ;
	Double majorRadius = null ;
	List coords = null ;
	EllipseType ellipseType = null ;
	Object[] radiusParams = null ;
	String coordSystem = null ;
	Object[] angleParams = null ;
}
{
	(
	<ELLIPSE> coordSystem=coord_system_A()
	<CENTER> <EQUALS_OPERATOR> coords=coords_2_A() 
	<RADII> <EQUALS_OPERATOR> radiusParams=ellipse_radius_A()
	<POS_ANGLE> <EQUALS_OPERATOR> angleParams=ellipse_angle_A()
	)
	{
		if( radiusParams != null ) {
			ellipseType = EllipseType.Factory.newInstance() ;
			ellipseType.setCenter( coords ) ;
			ellipseType.setMinorRadius( ((Double)radiusParams[0]).doubleValue() ) ;
			ellipseType.setRadius( ((Double)radiusParams[1]).doubleValue() ) ;
			ellipseType.setCoordSystemId( coordSystem ) ;
			ellipseType.setUnit( (PosUnitType.Enum)radiusParams[2] ) ;
			ellipseType.setPosAngle( ((Double)angleParams[0]).doubleValue() ) ;
			ellipseType.setPosAngleUnit( (AngleUnitType.Enum)angleParams[1] ) ;
		}
		if( log.isTraceEnabled() ) exitTrace ( "ellipse_region_A()" ) ;
		return ellipseType ;
	}
}

void polygon_region_A() : 
{
}
{
	<POLYGON> 
}

void sector_region_A() : 
{
}
{
	<SECTOR>
}

void convex_region_A() : 
{
}
{
	<CONVEX>	
}
void convex_hull_region_A() : 
{
}
{
	<CONVEX_HULL> 	
}//|   < CONVEX_HULL : "convex hull" >//|   < UNION : "union" >//|   < INTERSECTION : "intersection" >

String coord_system_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "coord_system_A()" ) ;
	String cs = null ;
	Token t1 = null ;
}
{
	(
	   <COORD_SYSTEM> <EQUALS_OPERATOR> t1=<REGULAR_IDENTIFIER> 
    )
	{	
		if( t1 !=  null ) {
		   cs = t1.image ;
	    }	
	    if( log.isTraceEnabled() ) exitTrace ( "coord_system_A()" ) ;
		return cs ;		
	}
}

void row_subquery_S() : {} 
{
	//S:
	// <row_subquery> ::= <subquery>
	subquery_S()	
}

Double double_numeric_literal_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "double_numeric_literal_A()" ) ;
	Token s = null ;
	Token t = null ;
	Double dnl = null ;
}
{
	( [ <PLUS_SIGN> | s=<MINUS_SIGN> ]  t=<EXACT_NUMERIC_LITERAL> | t=<UNSIGNED_INTEGER> )
	{
		if( t != null ) {
           dnl = new Double( (s!=null ? '-' : '+' ) + t.image ) ;		
		}
		if( log.isTraceEnabled() ) exitTrace ( "double_numeric_literal_A()" ) ;
		return dnl ;
	}
}

List coords_2_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "coords_2_A" ) ;
	Double coord1 = null ;
	Double coord2 = null ;
	Token t = null ;
	ArrayList list = null ;
}
{
    ( <LEFT_PAREN> coord1=double_numeric_literal_A() <COMMA> coord2=double_numeric_literal_A() t=<RIGHT_PAREN> )
    {
    	if( t != null ) {
    		list = new ArrayList( 2 ) ;
    		list.add( coord1 ) ;
    		list.add( coord2 ) ;
    	}
    	if( log.isTraceEnabled() ) exitTrace ( "coords_2_A" ) ;
    	return list ;
    }
}

Object[] circle_radius_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_radius_A" ) ;
	Double rad = null ;
	String putString = null ;
	PosUnitType.Enum unitType ;
	Object[] radiusParams = null ;
}
{
	(
	    rad=double_numeric_literal_A() 
	    | 
	    ( <LEFT_PAREN> rad=double_numeric_literal_A() <COMMA> putString=pos_unit_type_A() <RIGHT_PAREN> )
	)
	{
	   if( rad !=  null ) {
		   radiusParams = new Object[2] ;
		   if( putString == null ) {
			   unitType = PosUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = PosUnitType.Enum.forString( putString ) ;
		   }
		   radiusParams[0] = rad ;
		   radiusParams[1] = unitType ;
	   }
	   if( log.isTraceEnabled() ) exitTrace ( "circle_radius_A" ) ;
	   return radiusParams ;		
    }
}

Object[] ellipse_radius_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "ellipse_radius_A" ) ;
	Double minorRad = null ;
	Double majorRad = null ;
	PosUnitType.Enum unitType = null ;
	String putString = null ;
	Object[] ellipseParams = null ;
}
{
	( <LEFT_PAREN> 
	    minorRad=double_numeric_literal_A() <COMMA> majorRad=double_numeric_literal_A() 
	    ( <COMMA> putString=pos_unit_type_A() )?
	  <RIGHT_PAREN> 
	)
	{
	   if( majorRad !=  null ) {
		   ellipseParams = new Object[3] ;
		   if( putString == null ) {
			   unitType = PosUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = PosUnitType.Enum.forString( putString ) ;
		   }
		   ellipseParams[0] = minorRad ;
		   ellipseParams[1] = majorRad ;
		   ellipseParams[2] = unitType ;
	   }
	   if( log.isTraceEnabled() ) exitTrace ( "ellipse_radius_A" ) ;
	   return ellipseParams ;		
    }
}

String pos_unit_type_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "pos_unit_type_A" ) ;
	String putString = null ;
	Token t = null ;
}
{
	( t=<DEG> | t=<DEG_DEG_M> | t=<RAD> | t=<H> | t=<ARCMIN> | t=<ARCSEC> |   
	t=<M> | t=<KM> | t=<MM> | t=<AU> | t=<PC> | t=<KPC> | t=<MPC> | t=<LYR> )
	{ 
		if( t != null ) {
			putString = t.image ;
		}
		if( log.isTraceEnabled() ) exitTrace ( "pos_unit_type_A" ) ;
		return putString ;
	}	
}

String pos_angle_type_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "pos_angle_type_A" ) ;
	String patString = null ;
	Token t = null ;
}
{
	( t=<DEG> | t=<RAD> | t=<H> | t=<ARCMIN> | t=<ARCSEC> )
	{ 
		if( t != null ) {
			patString = t.image ;
		}
		if( log.isTraceEnabled() ) exitTrace ( "pos_angle_type_A" ) ;
		return patString ;
	}	
}

Object[] ellipse_angle_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "ellipse_angle_A" ) ;
	Double angle = null ;
	String patString = null ;
	AngleUnitType.Enum unitType ;
	Object[] angleParams = null ;
}
{
	(
	    angle=double_numeric_literal_A() 
	    | 
	    ( <LEFT_PAREN> angle=double_numeric_literal_A() <COMMA> patString=pos_angle_type_A() <RIGHT_PAREN> )
	)
	{
	   if( angle !=  null ) {
		   angleParams = new Object[2] ;
		   if( patString == null ) {
			   unitType = AngleUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = AngleUnitType.Enum.forString( patString ) ;
		   }
		   angleParams[0] = angle ;
		   angleParams[1] = unitType ;
	   }
	   if( log.isTraceEnabled() ) exitTrace ( "ellipse_angle_A" ) ;
	   return angleParams ;		
    }
}

ScalarExpressionType row_value_constructor_S() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <row_value_constructor> ::=
    //     <row_value_constructor_element>
    //  | <left_paren> <row_value_constructor_list> <right_paren>
    //  | <row_subquery>

	(
		LOOKAHEAD(3)
		row_value_constructor_element_S()
	    | 
	    LOOKAHEAD(2)
	    <LEFT_PAREN> row_value_constructor_list_S() <RIGHT_PAREN>
	    | 
	    row_subquery_S()
	 )
	 { return seType ; }
}

ScalarExpressionType row_value_constructor_element_S() : 
{
	ScalarExpressionType seType = null ;
} 
{
	//S:
	//  <row_value_constructor_element> ::=
    //     <value_expression>
    //   | <null_specification>
    //   | <default_specification>

	value_expression_A()
// adql has nothing to support the embedding of keywords...
//    | 
//    <NULL>
//    | 
//    <SQL_DEFAULT>

	{ return seType ; }
}

void row_value_constructor_list_S() : {}
{
	//S:
	//  <row_value_constructor_list> ::=
    //    <row_value_constructor_element> [ { <comma> <row_value_constructor_element> }... ]

	row_value_constructor_element_S() ( <COMMA> row_value_constructor_element_S() ) *
}

void scalar_subquery_S() : {}
{
	//S:
	// <scalar_subquery> ::= <subquery>
	subquery_S()
}

/**
 * 
 *
 * bnf-start
 *  <search_condition> ::=
 *      <boolean_term>
 *    | <search_condition> OR <boolean_term>
 * bnf-end
 *
 */
void search_condition_S() #SearchCondition : 
{
	if( log.isTraceEnabled() ) enterTrace ( "search_condition_S" ) ;
}
{
	//S:
	// <search_condition> ::=
    //    <boolean_term>
    //  | <search_condition> OR <boolean_term>

    // Refactored to
	// boolean_term() ( <OR> search_condition() )?
	// which I believe is equivalent to the above
//    try {
		( boolean_term_S() 
		  ( <OR>
		    { tracker.push( compiler.CONDITION_ELEMENT, UnionSearchType.type ) ; }	      
		    search_condition_S() 
		    { tracker.pop() ; }
		  )? 
		)
//    }//    catch( ParseException pex ) {//        errorSkipTo( new int[]{ token.kind }, pex ) ;	//    } 
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "search_condition_S" ) ;	
	}
}

//SearchType booleanTermList() : //{//	if( log.isTraceEnabled() ) enterTrace ( "booleanTermList" ) ;//	Stack stack = null ;//	SearchType st = null ;//}//{//	( //	  LOOKAHEAD(3)//	  st=booleanTermSingleton() //	  { if( stack == null )//	  	   stack = new Stack() ;//	  	stack.push( st ) ;//	  } //	)*//	{ //		if( stack != null ) {//			UnionSearchType heldOr = null ;//			SearchType[] conditions = new SearchType[2] ;//			while( stack.empty() == false ) {//				st = (SearchType)stack.pop() ;//				if( heldOr != null ) {//					conditions[0] = st ;//					conditions[1] = heldOr ;//					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;//					orType.setConditionArray( conditions ) ;//					heldOr = orType ;//				}//				else if( stack.empty() == false  ) {//					conditions[0] = (SearchType)stack.pop() ;//					conditions[1] = st ;//					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;//					orType.setConditionArray( conditions ) ;//					heldOr = orType ;//				}//			}//			if( heldOr != null )//				st = heldOr ; //		}	//		if( log.isTraceEnabled() ) exitTrace ( "booleanTermList" ) ;	//		return st ;//	}//}////SearchType booleanTermSingleton() ://{//	if( log.isTraceEnabled() ) enterTrace ( "booleanTermSingleton" ) ;//	SearchType st = null ;//	Token t = null ;//}//{////	t=<OR>{if(t!=null){_lt(UnionSearchType.type);_lp(CONDITION_ELEMENT);}}  //	st=boolean_term_S() //	{ //		_lp() ;//		if( log.isTraceEnabled() ) exitTrace ( "booleanTermSingleton" ) ;//		return st ; //	}//}

/**
 * select_list_S
 *
 * bnf-start
 *  <select_list> ::=
 *      <asterisk>
 *    | <select_sublist> [ { <comma> <select_sublist> }... ]
 * bnf-end
 *
 */
void select_list_S() #SelectionList : 
{
	if( log.isTraceEnabled() ) enterTrace ( "select_list_S()" ) ;
	tracker.push( compiler.SELECTION_LIST_ELEMENT, SelectionListType.type ) ;
}
{
	//S:
	// <select_list> ::=
	//   <asterisk>
    // | <select_sublist> [ { <comma> <select_sublist> }... ]
    try {
		(
			allSelectionItem()
			| 
			( select_sublist_A( true ) ( <COMMA> select_sublist_A( false ) )* )		
		)
    }    catch( ParseException pex ) {
    	compiler.errorSkipTo( new int[] { AdqlStoXConstants.FROM }, pex ) ;    }
    finally {
    	tracker.pop() ;
    	if( log.isTraceEnabled() ) exitTrace ( "select_list_S()" ) ;	
    }
	
}

void allSelectionItem() #AllSelectionItem : 
{ tracker.push( compiler.ITEM_ELEMENT, AllSelectionItemType.type ) ; }
{
	<ASTERISK>
    { tracker.pop() ; }
}

/**
 * 
 *
 * bnf-start
 *  <select_sublist> ::=
 *      <derived_column>
 * bnf-end
 *
 */
void select_sublist_A( boolean first ) #SelectSublist : 
{ 
	if( log.isTraceEnabled() ) enterTrace ( "select_sublist_A()" ) ;
	tracker.push( compiler.ITEM_ELEMENT ) ; 
	if( first ) {
		compiler.selectSublistEnsureNotComma() ;
	}
}
{   
	//S:
	// <select_sublist> ::= <derived_column> | <qualifier> <period> <asterisk>
    try {
	   (derived_column_S() { compiler.selectSublistEnsureCommaOrFrom() ; } )
	   |
	   { compiler.selectSublistError( first, new ParseException( "Error within selection list." ) ) ; }
    }    catch( ParseException pex ) {       compiler.selectSublistError( first, pex ) ;	    }
    finally {
       tracker.pop() ;
       if( log.isTraceEnabled() ) exitTrace ( "select_sublist_A()" ) ;
    }
	
}


/**
 * derived_column_S
 *
 * bnf-start
 *  <derived_column> ::= <value_expression> [ <as_clause> ]
 * bnf-end
 * bnf-start
 *  <as_clause> ::= [ AS ] <column_name>
 * bnf-end
 */
void derived_column_S() #DerivedColumn : 
{
	if( log.isTraceEnabled() ) enterTrace ( "derived_column_S()" ) ;
}
{
	try {
		//S:
		// <derived_column> ::= <value_expression> [ <as_clause> ]
		// <as_clause> ::= [ AS ] <column_name>
		( value_expression_A() [ [ <AS> ] column_name_S() ] ) 
	}
	finally { 
		if( log.isTraceEnabled() ) exitTrace ( "derived_column_S()" ) ;
	}	
}

/**
 * set_function_specification_S
 *
 * bnf-start
 *  <set_function_specification> ::=
 *      COUNT <left_paren> <asterisk> <right_paren>
 *    | <general_set_function>
 * bnf-end
 *
 */
void set_function_specification_S() #SetFunctionSpecification : {}
{
	//S:
	//  <set_function_specification> ::=
    //     COUNT <left_paren> <asterisk> <right_paren>
    //   | <general_set_function>


	( 
	  LOOKAHEAD(3)
	  ( <COUNT> <LEFT_PAREN> <ASTERISK> <RIGHT_PAREN> ) 
	  |
	  general_set_function_A()
	)
}

void set_function_specification_part_fragment() #SetFunctionSpecificationPartFragment : 
{
	if( log.isTraceEnabled() ) enterTrace ( "set_function_specification_part_fragment()" ) ;
}
{
		( ( <ASTERISK> | value_expression_A() ) )
		{
		  if( log.isTraceEnabled() ) exitTrace ( "set_function_specification_part_fragment()" ) ;
		}
}

/**
 * 
 *
 * bnf-start
 *  <set_limit> ::= TOP <unsigned_integer>
 * bnf-end
 *
 */
void set_limit_A() #Restrict : 
{ if( log.isTraceEnabled() ) enterTrace ( "set_limit_A" ) ;
  tracker.push( compiler.RESTRICT_ELEMENT, SelectionLimitType.type ) ; 
  Token t = null ;
}
{
	// There is no equivalent in the SQL/92 standard
	//
	try { 
		( <TOP> 
		  t=<UNSIGNED_INTEGER> 
		  {
		  	if( t!=null ) {
				try { 
				   jjtThis.setLimit( ( new Integer( t.image )).intValue() ) ;
				}
				catch( NumberFormatException ex ) {
				   throw new ParseException( ex.getLocalizedMessage() ) ;	
				}
			}
		  }
		)
	}	catch( ParseException pex ) {
	    tracker.setError( pex.getLocalizedMessage() ) ;	}
	{ 		
		tracker.pop() ;
        if( log.isTraceEnabled() ) exitTrace ( "set_limit_A" ) ;
	}
}

/**
 * set_quantifier_S
 *
 * bnf-single <set_quantifier> ::= DISTINCT | ALL
 *
 */
void set_quantifier_S() #Allow : 
{ tracker.push( compiler.ALLOW_ELEMENT, SelectionOptionType.type ) ; }
{
	//S:
	// <set_quantifier> ::= DISTINCT | ALL
	//
	( <DISTINCT> | <ALL> )
	{ tracker.pop() ; }
}


void single_datetime_field_S() : {}
{
	//S:
	//  <single_datetime_field> ::=
    //     <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]
    //   | SECOND [ <left_paren> <interval_leading_field_precision> [ <comma> <interval_fractional_seconds_precision> ] <right_paren> ]

	nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
    | 
    <SECOND> [ <LEFT_PAREN> interval_leading_field_precision_S() [ <COMMA> interval_fractional_seconds_precision_S() ] <RIGHT_PAREN> ]
}

void start_field_S() : {}
{
	//S:
	//  <start_field> ::=
    //    <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]

    nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
}

/**
 * 
 *
 * bnf-start
 *  <string_value_expression> ::=
 *      <character_value_expression>
 * bnf-end
 *
 */
void string_value_expression_A() : {}
{
	//S:
	// <string_value_expression> ::=
    //    <character_value_expression>
    //  | <bit_value_expression>
	character_value_expression_A()
}

/**
 * subquery_S
 *
 */
SearchType subquery_S() : 
{
	SearchType st = null ;
}
{
	//S:
	//  <subquery> ::= <left_paren> <query_expression> <right_paren>
	( <LEFT_PAREN> query_expression_S() <RIGHT_PAREN> )
	{ return st ; }		
}


void quantified_comparison_predicate_S() : {}
{
	//S:
	// <quantified_comparison_predicate> ::=
    //    <row_value_constructor> <comp_op> <quantifier> <table_subquery>

	row_value_constructor_S() comp_op_S() quantifier_S() table_subquery_S()	
}

void quantifier_S() : {}
{
	//S:
	// <quantifier> ::= <all> | <some>
	//
	// <all> ::= ALL
	// <some> ::= SOME | ANY
	//
	<ALL> | ( <SOME> | <ANY> )	
}

void query_expression_S() : {}
{
	//S:
	// <query_expression> ::=
    //    <non-join_query_expression>
    //  | <joined_table>
	
	LOOKAHEAD(3)
	nonjoin_query_expression_S()
	|
	joined_table_S()
}

void query_primary_S() : {}
{
	//S:
	// <query_primary> ::=
    //    <non-join_query_primary>
    //  | <joined_table>

    LOOKAHEAD(3)
 	nonjoin_query_primary_S()
    | 
    joined_table_S()
}


void query_term_S() : {}
{
	//S:
	// <query_term> ::=
    //    <non-join_query_term>
    //  | <joined_table>

	LOOKAHEAD(2)
	nonjoin_query_term_S()
	|
	joined_table_S()	
}

void corresponding_spec_S() : {}
{
	//S:
	// <corresponding_spec> ::=
    //    CORRESPONDING [ BY <left_paren> <corresponding_column_list> <right_paren> ]
	<CORRESPONDING> [ <BY> <LEFT_PAREN> corresponding_column_list_S() <RIGHT_PAREN> ] 
}
    
void corresponding_column_list_S() : {}
{
	//S:
	// <corresponding_column_list> ::= <column_name_list>
	column_name_list_S()	
}

/**
 * cross_join_S
 *
 *-bnf-start
 *- <cross_join> ::=
 *-     <table_reference> CROSS JOIN <table_reference>
 *-bnf-end
 *
 */
JoinTableType cross_join_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "cross_join_S()" ) ;
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	//S:
	// <cross_join> ::=
    //    <table_reference> CROSS JOIN <table_reference>
	( tableReferenceBarJoinedTable() <CROSS_JOIN> table_reference_A() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JointTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   if( log.isTraceEnabled() ) exitTrace ( "cross_join_S()" ) ;
	   return jtType ;	
	}
}


void nonjoin_query_expression_S() : {}
{
	//S:
	// <non-join_query_expression> ::=
    //    <non-join_query_term>
    //  | <query_expression> UNION  [ ALL ] [ <corresponding_spec> ] <query_term>
    //  | <query_expression> EXCEPT [ ALL ] [ <corresponding_spec> ] <query_term>

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	LOOKAHEAD(4)
	( query_term_S() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ corresponding_spec_S() ] query_term_S() )* )
	|
	nonjoin_query_term_S()
}

void nonjoin_query_term_S() : {}
{
	//S:
	// <non-join_query_term> ::=
    //    <non-join_query_primary>
    //  | <query_term> INTERSECT [ ALL ] [ <corresponding_spec> ] <query_primary>

	// Refactored to...
	LOOKAHEAD(3)
	nonjoin_query_primary_S()
	|
	( query_primary_S() <INTERSECT> [ <ALL> ] [ corresponding_spec_S() ] query_primary_S() )	
}

void nonjoin_query_primary_S() : {}
{
	//S:
	//  <non-join_query_primary> ::=
    //    <simple_table>
    //  | <left_paren> <non-join_query_expression> <right_paren>
    
	simple_table_S()
	|
	( <LEFT_PAREN> nonjoin_query_expression_S() <RIGHT_PAREN> )
}

void nonsecond_datetime_field_S() : {}
{
	//S:
	// <non-second_datetime_field> ::= YEAR | MONTH | DAY | HOUR | MINUTE
	<YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE>
}

void simple_table_S() : {}
{
	//S:
	// <simple_table> ::=
    //    <query_specification>
    //  | <table_value_constructor>
    //  | <explicit_table>

	query_specification_A()
	|
	table_value_constructor_S()
	|
	explicit_table_S()	
}

///**// * table_expression_A// *// *-bnf-start// *- <table_expression> ::=// *-     <from_clause>// *-     [ <where_clause> ]// *-     [ <group_by_clause> ]// *-     [ <having_clause> ]// *-     [ <order_by_clause> ]// *-!! ADQL adds <order_by_clause>// *-bnf-end// *// */
//void table_expression_A( SelectType st ) : //{//	if( log.isTraceEnabled() ) enterTrace ( "table_expression_A" ) ;//} //{//	//S://	// <table_expression> ::=//	// <from_clause>//    // [ <where_clause> ]//    // [ <group_by_clause> ]//    // [ <having_clause> ]//	(//		from_clause_S( st ) 		//		[ LOOKAHEAD(3) where_clause_S( st ) ] //		//		[ LOOKAHEAD(3) group_by_clause_S( st ) ] //		//		[ LOOKAHEAD(3) having_clause_S( st ) ] //		//		[ LOOKAHEAD(3) order_by_clause( st ) ]	//	)//	{ //		if( log.isTraceEnabled() ) exitTrace ( "table_expression_A" ) ;//	}//}

/**
 * table_name_A
 *
 * bnf-start
 *  <table_name> ::=
 *      <identifier>
 * bnf-end
 *
 */
void table_name_A() #TableName : 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_name_A()" ) ;
}
{
	//S:
	// <table_name> ::=
    //  <qualified_name> | <qualified_local_table_name>
	identifier_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "table_name_A()" ) ;
	}
}

/** 
 * table_reference_A
 *
 * bnf-start
 *  <table_reference> ::=
 *      <simple_table_reference>
 *    | <joined_table> 
 * bnf-end
 *
 */
void table_reference_A() #Table : 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_reference_A()" ) ;
} 
{
	//S:
	//  <table_reference> ::=
    //     <table_name> [ [ AS ] <correlation_name> [ <left_paren> <derived_column_list> <right_paren> ] ]
    //   | <derived_table> [ AS ] <correlation_name> [ <left_paren> <derived_column_list> <right_paren> ]
    //   | <joined_table>
	try {
	(
		// refactored... 
		// 1. derivedTable() moved to first choice point
		// 2. joinedTable() moved to second choice point
//	    LOOKAHEAD(4) 
//	    derivedTable() [ <AS> ] correlationName() [ <LEFT_PAREN> derived_column_list_S() <RIGHT_PAREN> ]
//	    |	
//		LOOKAHEAD(4)
//	    joinedTable()
//	    |
//		tableName() [ [ <AS> ] correlationName() [ <LEFT_PAREN> derived_column_list_S() <RIGHT_PAREN> ] ]    

		// Foreshortened. 
		// derivedColumnList not supported in adql
		// derivedTable not supported in adql
//		LOOKAHEAD(4)
//	    derivedTable() [ <AS> ] correlationName()
//	    |	
		LOOKAHEAD(6)
	    joined_table_S()
	    |
	    ( ( LOOKAHEAD(6) schema_name_A() <PERIOD> )? table_name_A() ( [ <AS> ] correlation_name_S() )? )	
	)
	}
	catch( ParseException pex ) {
		compiler.errorSkipTo( compiler.TABLE_REF_SKIP_TO, pex ) ;
	}
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "table_reference_A()" ) ;
	} 
}

/** 
 * simple_table_reference_A
 *
 * bnf-start
 *  <simple_table_reference> ::=
 *      [ <schema_name> <period> ] <table_name> [ [ AS ] <correlation_name> ] 
 * bnf-end
 *
 */
void tableReferenceBarJoinedTable() #TableReferenceBarJoinedTable : 
{
	if( log.isTraceEnabled() ) enterTrace ( "tableReferenceBarJoinedTable()" ) ;
}
{
	( ( LOOKAHEAD(5) schema_name_A() <PERIOD> )? table_name_A() [ [ <AS> ] correlation_name_S() ] )
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "tableReferenceBarJoinedTable()" ) ;
	}
}

SearchType table_subquery_S() : {	SearchType st = null ;}{	//S:	// <table_subquery> ::= <subquery>	st=subquery_S()		{ return st ; }}

/**
 * table_subquery_A
 *
 * bnf-start
 *  <table_subquery> ::= 
 *      <left_paren> <query_specification> <right_paren>
 * bnf-end
 *
 */
void table_subquery_A() #TableSubQuery: 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_subquery_A" ) ;
}
{
	//S:
	// <table_subquery> ::= <subquery>
	( <LEFT_PAREN> query_specification_A() <RIGHT_PAREN> )	
	{
		if( log.isTraceEnabled() ) exitTrace ( "table_subquery_A" ) ;
	}
}

void table_value_constructor_S() : {}
{
	//S:
	//  <table_value_constructor> ::=
    //     VALUES <table_value_constructor_list>

	<VALUES> table_value_constructor_list_S()
}

void table_value_constructor_list_S() : {}
{
	//S:
	// <table_value_constructor_list> ::=
    //    <row_value_constructor> [ { <comma> <row_value_constructor> }... ]

	row_value_constructor_S() ( <COMMA> row_value_constructor_S() )*	
}

/**
 * term_S
 *
 * bnf-start
 *  <term> ::=
 *      <factor>
 *    | <term> <asterisk> <factor>
 *    | <term> <solidus> <factor>
 * bnf-end
 *
 */
void term_S() #Term :  
{
	if( log.isTraceEnabled() ) enterTrace ( "term_S()" ) ;
	Token t = null ;
}
{
	//S:
	//  <term> ::=
    //     <factor>
    //   | <term> <asterisk> <factor>
    //   | <term> <solidus> <factor>

	// refactored
	// factor() ( LOOKAHEAD(2) (<ASTERISK> | <SOLIDUS> ) term() )?
	( 
	   factor_S() 
	   ( LOOKAHEAD(2) 
	     ( 
	       ( t=<ASTERISK> | t=<SOLIDUS> ) 
	       {   if( t!=null ) {
	           	  jjtThis.setOperator(t);
	           }
	       } 
	     ) 
	     term_S() 
	   )? 	
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "term_S()" ) ;
	}
}

//ScalarExpressionType[] termList() : //{//	ArrayList list = null ;//	ScalarExpressionType[] exprPairs1 = null ;//	ScalarExpressionType[] exprPairs2 = null ;//	ScalarExpressionType[] retExprPairs = null ;	//}//{//	( LOOKAHEAD(3) exprPairs1=termSingleton() //	  { if( list == null )//	  	   list = new ArrayList() ;//	  	list.add( exprPairs1 ) ;//	  } //	)*//	{ //		if( list != null ) {//			ListIterator iterator = list.listIterator() ;//			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;//			ScalarExpressionType[] args = new ScalarExpressionType[2] ;//			BinaryExprType beType = null ;//			while( iterator.hasNext() ) {//				exprPairs2 = (ScalarExpressionType[])iterator.next() ;//				args[0] = exprPairs1[1] ;//				args[1] = exprPairs2[1] ;//				beType = (BinaryExprType)exprPairs2[0] ;//				beType.setArgArray( args ) ;//				exprPairs1 = exprPairs2 ;//			}//		}		//		return retExprPairs ;//	}//}////ScalarExpressionType[] termSingleton() ://{////	ScalarExpressionType[] retPairs = null ;//	BinaryExprType beType = null ;//	ScalarExpressionType seType = null ;//	Token t = null ; //}//{//	( t=<ASTERISK> | t=<SOLIDUS> ) seType=term_S()	//	{//		if( t != null ) {//			retPairs = new ScalarExpressionType[2] ;		//			beType = BinaryExprType.Factory.newInstance() ;//			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;//			retPairs[0] = beType ;//			retPairs[1] = seType ;//		}////		return retPairs ;//	}//}

void time_fractional_seconds_precision_S() : {}
{
	//S:
	// <time_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER> 	
}

void time_precision_S() : {}
{
	//S:
	// <time_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void timestamp_precision_S() : {}
{
	//S:
	// <timestamp_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void time_zone_S() : {}
{
	//S:
	//  <time_zone> ::= AT <time_zone_specifier>
    //  <time_zone_specifier> ::= LOCAL | TIME ZONE <interval_value_expression>

	// refactored
    <AT> ( <LOCAL> | ( <TIME_ZONE> interval_value_expression_S() ) ) 
}

/**
 * 
 *
 * bnf-start
 *  <trig_function> ::=
 *      ACOS <left_paren> <numeric_value_expression> <right_paren>
 *    | ASIN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN2 <left_paren> <numeric_value_expression> <comma> <numeric_value_expression> <right_paren>
 *    | COS <left_paren> <numeric_value_expression> <right_paren>
 *    | COT <left_paren> <numeric_value_expression> <right_paren>
 *    | SIN <left_paren> <numeric_value_expression> <right_paren>
 *    | TAN <left_paren> <numeric_value_expression> <right_paren>L
 * bnf-end
 *
 */
void trig_function_A() #TrigFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "trig_function_A()" ) ;
	tracker.setType( TrigonometricFunctionType.type ) ;
}
{
	(
		<ACOS> <LEFT_PAREN>
		          { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		       <RIGHT_PAREN>
		|
		<ASIN> <LEFT_PAREN> 
		          { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		       <RIGHT_PAREN>
		|
        <ATAN> <LEFT_PAREN> 
                  { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
               <RIGHT_PAREN>
		|
		( <ATAN2> <LEFT_PAREN> 
		             { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		          <COMMA> 
		             { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		          <RIGHT_PAREN> )
		|
		<COS> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
		|
		<COT> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		      <RIGHT_PAREN>
		|
		<SIN> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
		|
		<TAN> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "trig_function_A()" ) ;
	}
}

void unique_predicate_S() : {}
{
	//S:
	// <unique_predicate> ::= UNIQUE <table_subquery>
	<UNIQUE> table_subquery_S()	
}

/**
 * unsigned_literal_S
 *
 * bnf-single <unsigned_literal> ::= <unsigned_numeric_literal> | <general_literal>
 *
 */
void unsigned_literal_S() : {}
{
	//S: 
	// <unsigned_literal> ::=
    //    <unsigned_numeric_literal>
    //  | <general_literal>
	unsigned_numeric_literal_S()
    | 
    general_literal_A()
}

/**
 * unsigned_numeric_literal_S
 *
 * bnf-start
 *  <unsigned_numeric_literal> ::=
 *     <exact_numeric_literal>
 *     |
 *     <approximate_numeric_literal>
 * bnf-end
 *
 */
void unsigned_numeric_literal_S() : {} 
{
	//S:
	//  <unsigned_numeric_literal> ::=
    //      <exact_numeric_literal>
    //    | <approximate_numeric_literal>

	exact_numeric_literal_S( DONT_CHANGE_SIGN )
	|
	approximate_numeric_literal_S() 
}

/**
 * approximate_numeric_literal_S
 *
 * bnf-start
 *  <approximate_numeric_literal> ::= <mantissa>E<exponent>
 * bnf-end
 *
 */
void approximate_numeric_literal_S() #ApproximateNumericLiteral : {} 
{
	<APPROXIMATE_NUMERIC_LITERAL>	
}

/**
 * unsigned_value_specification_S
 *
 * bnf-start
 *  <unsigned_value_specification> ::=
 *      <unsigned_literal>
 * bnf-end
 *
 */
void unsigned_value_specification_S() : {} 
{
	//S:
	// <unsigned_value_specification> ::=
    //     <unsigned_literal>
    //   | <general_value_specification>
	unsigned_literal_S()
	|
	general_value_specification_A()
}

/**
 * value_expression_A
 *
 * bnf-start
 *  <value_expression> ::=
 *	    <numeric_value_expression>
 *    | <string_value_expression>
 * bnf-end
 *
 */
void value_expression_A() #ValueExpression : 
{
    if( log.isTraceEnabled() ) enterTrace ( "value_expression_A()" ) ;
} 
{
	//S:
	// <value_expression> ::=
	//    <numeric_value_expression>
    //  | <string_value_expression>
    //  | <datetime_value_expression>
    //  | <interval_value_expression>
    try {
		(
		LOOKAHEAD(16) 
		numeric_value_expression_S() 
		|
		LOOKAHEAD(16) 	
		string_value_expression_A() 
		// JL. foreshortened. At present there seems no accommodation for
		// datetime and interval expressions in adql
	//	|
	//	LOOKAHEAD(3) 
	//	dateTimeValueExpression() 
	//	|
	//	intervalValueExpression()
	
		)
    }    catch( ParseException pex ) {
    	if( log.isDebugEnabled() ) log.debug( "value_expression_A() throwing pex" ) ;		throw pex ;    }
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "value_expression_A()" ) ;
	}
	
}

/**
 * variable_specification_A
 *
 * -bnf-start
 * -<variable_specification> ::=
 *  -!! Yet to be worked out.
 * -bnf-end
 *
 */
ScalarExpressionType variable_specification_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <variable_specification> ::=
    //    <embedded_variable_name> [ <indicator_variable> ]
    
	// JBL ADQL adaptation to accommodate scripting variables.
	// Details still to be worked out.
	( <DOLLAR> <LBRACE> <REGULAR_IDENTIFIER> <RBRACE> )
	{ return seType ; }
}

/**
 * where_clause_S
 *
 * bnf-single <where_clause> ::= WHERE <search_condition>
 *
 */
void where_clause_S() #Where : 
{
	if( log.isTraceEnabled() ) enterTrace ( "where_clause_S" ) ;
	tracker.push( compiler.WHERE_ELEMENT, WhereType.type ) ;
}
{
	//S:
	// WHERE <search_condition>
    try {   	
	  ( <WHERE> search_condition_S() )
    }
    catch( ParseException pex ) {
       compiler.errorSkipTo( compiler.WHERE_SKIP_TO, pex ) ;	
    }
	{ 			
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "where_clause_S" ) ;
	}
}
    
/* 
$Log: AdqlStoX.jjt,v $
Revision 1.3  2009/06/29 09:40:04  jl99
Removed javacc plugin to prevent regeneration of code.

Revision 1.2  2009/06/17 10:13:29  jl99
Merge of adql v1 parser with maven 2 build.
Due to some necessary restructuring, the maven 1 build process has been removed.

Revision 1.1.2.1  2009/06/16 07:49:39  jl99
First commit of maven 2 build

Revision 1.39  2008/04/16 11:04:22  jl99
Merge of branch adql-jl-2731

Revision 1.38.4.1  2008/04/15 14:09:55  jl99
(1) ROUND and TRUNCATE functions have changed cardinality.
(2) Some improvements to comment processing.

Revision 1.38  2008/03/19 20:53:21  jl99
Merge of branch adql-jl2650

Revision 1.37.2.1  2008/03/18 15:51:42  jl99
Improved comment processing (C/C++ style comments accommodated)
Improved sub list error processing.

Revision 1.37  2008/02/04 17:47:30  jl99
Merge of branch adql-jl-2504

Revision 1.36.2.4  2008/02/01 09:50:09  jl99
Updates to the explicit join syntax

Revision 1.36.2.3  2008/01/29 15:30:02  jl99
Minor touches to table reference. Added <simple table reference>

Revision 1.36.2.2  2008/01/29 14:12:09  jl99
Parentheses allowing joined tables within joined tables removed.
This disallows n-way explicit joins using brackets,
which we will have difficulty supporting with the current XML structure.
It DOES still allow 2-way explicit joins.

Revision 1.36.2.1  2008/01/17 13:15:12  jl99
Dec removed from SQL reserved word list.

Revision 1.36  2007/06/17 15:17:20  jl99
AdqlStoX.jtt alone...
Minor correction to definitions that hide aliases H and M (upper or lower case).
Passed all 134 unit tests, and thought it worth the risk to commit straight to head,
for the sake of speed. The following documents the changes...
// <H: "h"> causes severe problems with "h" appearing on its own, as this
//          consumes the token. Eg: table alias h is not then workable. Changed to
|   < H : "_h_" >
// < M : "m" > causes severe problems with "m" appearing on its own, as this
//          consumes the token. Eg: table alias m is not then workable. Changed to
|   < M : "_m_" >

Revision 1.35  2007/06/06 18:19:28  jl99
Merge of branch adql-jl-2135

Revision 1.34.2.36  2007/06/06 16:51:28  jl99
Tidy just prior to merge of branch adql-jl-2135

Revision 1.34.2.35  2007/06/06 10:53:22  jl99
Code tidy just prior to merge of branch adql-jl-2135

Revision 1.34.2.34  2007/05/29 18:59:12  jl99
Correction to set_function_specification_part_fragment

Revision 1.34.2.33  2007/05/22 10:35:35  jl99
Refinement to user defined functions.

Revision 1.34.2.32  2007/05/21 17:39:38  jl99
First experiment with user defined functions.

Revision 1.34.2.31  2007/05/18 12:45:29  jl99
Bug fix on the predicate clause.

Revision 1.34.2.30  2007/05/17 11:25:11  jl99
Code tidy

Revision 1.34.2.29  2007/05/10 18:57:55  jl99
Reorg to improve AST_ classes and memory usage: fragment processing

Revision 1.34.2.28  2007/05/09 13:58:08  jl99
Reorg to improve AST_ classes and memory usage: fragment processing

Revision 1.34.2.27  2007/05/09 08:51:11  jl99
Reorg to improve AST_ classes and memory usage.

Revision 1.34.2.26  2007/05/08 15:52:35  jl99
Reorg to improve AST_ classes and memory usage.

Revision 1.34.2.25  2007/05/01 08:35:18  jl99
Updating unit test in line with improvement in comment processing.

Revision 1.34.2.24  2007/04/30 17:23:24  jl99
Better comment processing.

Revision 1.34.2.23  2007/04/30 10:22:23  jl99
Better comment processing.

Revision 1.34.2.22  2007/04/27 20:40:55  jl99
Improvements to comment processing.

Revision 1.34.2.21  2007/04/26 14:50:34  jl99
Strengthening unit tests

Revision 1.34.2.20  2007/04/26 09:02:35  jl99
Tidying tracing.

Revision 1.34.2.19  2007/04/25 07:49:48  jl99
Minor improvements to tracing

Revision 1.34.2.18  2007/04/24 17:30:56  jl99
First working version that includes multiple archives.

Revision 1.34.2.17  2007/04/24 14:43:26  jl99
First attempt at including multiple archives.

Revision 1.34.2.16  2007/04/23 12:31:35  jl99
Introduction of module AdqlCompiler to contain majority of java code previously in AdqlStoX.
AdqlStoX is a non-java source module which must be pre-processed to produce java.
AdqlCompiler makes for ease of maintenance and clarity.

Revision 1.34.2.15  2007/04/20 21:52:34  jl99
Tighter fragment processing

Revision 1.34.2.14  2007/04/19 11:49:50  jl99
Changes to public methods to accommodate multiple error recording.

Revision 1.34.2.13  2007/04/17 15:45:29  jl99
Rationalizing multiple error reporting

Revision 1.34.2.12  2007/04/04 17:34:52  jl99
Improvements to compiling beyond the first error.

Revision 1.34.2.11  2007/04/02 16:26:35  jl99
Improvements to compiling beyond the first error.

Revision 1.34.2.10  2007/03/23 21:22:32  jl99
First attempts to continue compiling beyond the first error.

Revision 1.34.2.9  2007/03/14 12:55:54  jl99
Restrict (eg: top 1000) misbehaving

Revision 1.34.2.8  2007/03/10 14:00:42  jl99
Fixed bug in set_limit_A()

Revision 1.34.2.7  2007/03/09 09:21:16  jl99
Started to use position tracking for errors. At present only in debugging messages.

Revision 1.34.2.6  2007/03/08 17:44:47  jl99
Position Tracking

Revision 1.34.2.5  2007/03/08 16:28:03  jl99
Position Tracking

Revision 1.34.2.4  2007/03/06 11:59:44  jl99
Tracking comments: principles revised and processing of trailing comment added.
The tracking principles are in process of revision.
The writing of comments no longer needs the tracker object.
Tracking will be used for multiple error recording.

Revision 1.34.2.3  2007/03/04 22:54:09  jl99
More coverage of comments.

Revision 1.34.2.2  2007/03/03 00:22:20  jl99
Tracking comments: principles established.

Revision 1.34.2.1  2007/03/02 21:14:13  jl99
Tracking comments introduced. First attempt to track position.

Revision 1.34  2007/01/26 09:45:53  jl99
Merge of adql-jl-2031-a into HEAD

Revision 1.33.4.8  2007/01/25 14:13:21  jl99
Logging adjustments

Revision 1.33.4.7  2007/01/19 08:30:43  jl99
Improvements to nested processing, plus the inclusion of approximate numeric literals into the grammar

Revision 1.33.4.6  2007/01/12 12:16:22  jl99
Renamed userDefinedObject and associated methods to generatedObject

Revision 1.33.4.5  2007/01/11 13:55:00  jl99
The technique for undertaking fragment processing is now probably complete.

Revision 1.33.4.4  2007/01/11 12:46:45  jl99
Made ending <SEMICOLON> optional on full query

Revision 1.33.4.3  2007/01/11 12:09:12  jl99
Improved fragment processing.

Revision 1.33.4.2  2007/01/10 22:39:24  jl99
(1) ParseException generated for unprocessed "dangling" source.
(2) Improved fragment processing.

Revision 1.33.4.1  2007/01/10 13:58:59  jl99
First commit after cvs recovery.

Revision 1.33.2.4  2006-12-19 14:22:36  jl99
More revision and refinement of fragment processing: more elements and types

Revision 1.33.2.3  2006/12/12 11:34:53  jl99
Revision of fragment processing.

Revision 1.33.2.2  2006/12/09 19:26:23  jl99
More fragments defined.

Revision 1.33.2.1  2006/11/30 16:42:51  jl99
More fragments defined.

Revision 1.33  2006/11/27 18:05:47  jl99
Merge of branch adql-jl-2020

Revision 1.32.2.3  2006/11/27 16:35:28  jl99
Adopted a more short term approach to Delimited Identifiers. In our terms these are quoted identifiers, eg: "2xmmp" as a table name. We now allow quoted identifiers (partially) in order to differentiate possible name clashes but do not format them into the xml (that's the partial bit). This is acceptable since the dsa still works on xml and does not need quotes to differentiate name clashes.

Revision 1.32.2.2  2006/11/17 13:45:45  jl99
More on compiling fragments of ADQL

Revision 1.32.2.1  2006/11/16 22:11:34  jl99
First experiment with compiling fragments

Revision 1.32  2006/11/13 21:02:18  jl99
Slight code rationalization

Revision 1.31  2006/11/12 20:06:00  jl99
Removed support for Cross Joins.
Difficult to support this with the current Adlq/x schema which has a join condition as mandatory.

Revision 1.30  2006/10/28 22:08:05  jl99
Rejig to enable more speedy adaptation to aliased expressions
when these become feasible. At present ADQL/x is broken in this area.

Revision 1.29  2006/10/27 14:29:56  jl99
Made alliases for tables compulsary. Not sure this is such a good idea,
but it obeys the adql/x 1.01 standard.

Revision 1.28  2006/10/25 13:22:15  jl99
Extra convenience methods to trigger compilations with differing output
(XmlBeans, XmlText, Xml Dom Node etc)

Revision 1.27  2006/10/23 22:39:10  jl99
Corrections to embedded BNF documentation

Revision 1.26  2006/10/22 20:47:10  jl99
More BNF Documentation

Revision 1.25  2006/10/20 13:02:10  jl99
More BNF Documentation

Revision 1.24  2006/10/20 08:53:25  jl99
BNF Documentation

Revision 1.23  2006/10/18 22:35:53  jl99
Some systematization of token definitions.

Revision 1.22  2006/10/16 15:35:49  jl99
Region: Circle and Ellipse at STCregion v1.10.
This is not the latest spec for region. But is appropriate as a prototype.

Revision 1.21  2006/10/16 11:37:46  jl99
First Attempt at Region.

Revision 1.20  2006/10/14 16:14:52  jl99
like_predicate complete (according to adql/x v1.01a).

Revision 1.19  2006/10/14 13:09:19  jl99
in_predicate complete (according to adql/x v1.01a).

Revision 1.18  2006/10/13 21:01:59  jl99
in_predicate begun.

Revision 1.17  2006/10/13 13:29:24  jl99
(1) Some logging added.
(2) Improved processing for unary values.

Revision 1.16  2006/10/11 20:36:25  jl99
(1) Change of signature to exec method. Now throws a ParserException.

Revision 1.15  2006/10/02 09:03:35  jl99
First attempt at mavenizing project

Revision 1.14  2006/09/28 15:08:55  jl99
Errors corrected.

Revision 1.13  2006/09/28 08:50:02  jl99
Reorg on method naming convention: complete.

Revision 1.12  2006/09/28 08:43:29  jl99
Reorg on method naming convention: 4.

Revision 1.11  2006/09/27 20:51:55  jl99
Reorg on method naming convention: 3.

Revision 1.10  2006/09/26 13:44:11  jl99
Reorg on method naming convention: 1.

*/


