/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.4";
  STATIC=false;
  MULTI=true;
  VISITOR=true;
  NODE_USES_PARSER=true;
  NODE_DEFAULT_VOID=true;
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import java.util.* ;
import org.astrogrid.adql.v1_0.beans.* ;

public class AdqlStoX {
	
	private final static ScalarExpressionType DUMMY_ARG = ScalarExpressionType.Factory.newInstance() ;

	public SelectDocument exec() {
		SelectDocument selectDoc = null ;
		try {			
			ASTSelect query = topQuery();
			AdqlStoXVisitor visitor = new AdqlStoXVisitorImpl() ;
			selectDoc = SelectDocument.Factory.newInstance() ;
			query.jjtAccept( visitor, selectDoc ) ;		
		}
		catch( ParseException pex ) {
			pex.printStackTrace() ;
			//System.out.println( pex.getMessage() ) ;
		}
		catch( Error err ) {
			err.printStackTrace() ;
			//System.out.println( err.getMessage() ) ;
		}
		return selectDoc ;
	
	}

}
PARSER_END(AdqlStoX)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}


TOKEN : 
{
	< LBRACE : "{" >
|	< RBRACE : "}" >
	
|	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< EQUALS_OPERATOR : "=" >
|	< LESS_THAN_OPERATOR : "<" >
|	< GREATER_THEN_OPERATOR : ">" >

|	< ADD: "add" >
|	< ALL: "all" >
|	< AND: "and" >
|	< ANY: "any" >
|	< AS: "as" >
|	< ASC: "asc" >
|	< AT : "at" >
|	< AUTHORIZATION: "authorization" >
|	< BASE64: "base64" >
|	< BEGIN: "begin" >
|	< BETWEEN: "between" >
|	< BINARY: "binary" >
|	< BREAK: "break" >
|	< BY: "by" >
|	< CASE: "case" >
|	< CAST: "cast" >
|	< CHECKPOINT: "checkpoint" >
|	< CLOSE: "close" >
|	< CLUSTERED: "clustered" >

|   < COALESCE: "coalesce" >
|	< COLLATE: "collate" >
|	< COLUMN: "column" >
|	< COMMIT: "commit" >
|	< COMPUTE: "compute" >
|	< CONCAT: "concat" >
|	< CONSTRAINT: "constraint" >
|	< CONTAINS: "contains" >
|	< CONTAINSTABLE: "containstable" >
|	< CONTINUE: "continue" >

|	< CORRESPONDING : "corresponding" >

	//| < CONVERT: "convert" >
|	< CREATE: "create" >
//|	< CROSS: "cross" >
|	< CROSS_JOIN : "cross join">
|	< CUBE: "cube" >
|	< CURRENT: "current" >
|	< CURRENT_DATE: "current_date" >
|	< CURRENT_TIME: "current_time" >
|	< CURRENT_TIMESTAMP: "current_timestamp" >
|	< CURRENT_USER: "current_user" >
|	< CURSOR: "cursor" >
|	< DATABASE: "database" >
|	< DBCC: "dbcc" >
|	< DEALLOCATE: "deallocate" >
|	< DECLARE: "declare" >
|	< SQL_DEFAULT: "default" >
|	< DELETE: "delete" >
|	< DENY: "deny" >
|	< DESC: "desc" >
|	< DISK: "disk" >
|	< DISTINCT: "distinct" >
|	< DISTRIBUTED: "distributed" >
|	< DOT: "." >
|	< DOUBLE: "double" >
|	< DROP: "drop" >
|	< DUMP: "dump" >
|	< ELEMENTS: "elements" >
|	< ELSE: "else" >
|	< END: "end" >
|	< ERRLVL: "errlvl" >
|	< ESCAPE: "escape" >
|	< EXCEPT: "except" >
|	< EXEC: "exec" >
|	< EXECUTE: "execute" >
|	< EXISTS: "exists" >
|	< EXIT: "exit" >
|	< EXPAND: "expand" >
|	< EXPLICIT: "explicit" >
|	< FAST: "fast" >
|	< FASTFIRSTROW: "fastfirstrow" >
|	< FETCH: "fetch" >
|	< FILE: "file" >
|	< FILLFACTOR: "fillfactor" >
|	< FOR: "for" >
|	< FORCE: "force" >
|	< FOREIGN: "foreign" >
|	< FREETEXT: "freetext" >
|	< FREETEXTTABLE: "freetexttable" >
|	< FROM: "from" >
|	< FULL: "full" >
|	< FUNCTION: "function" >
|	< GOTO: "goto" >
|	< GRANT: "grant" >
|	< GROUPBY: "group by" >
|	< HASH: "hash" >
|	< HAVING: "having" >
|	< HOLDLOCK: "holdlock" >
|	< IDENTITY: "identity" >
|	< IDENTITY_INSERT: "identity_insert" >
|	< IDENTITYCOL: "identitycol" >
|	< IF: "if" >
|	< IN: "in" >
|	< INDEX: "index" >
|	< INNER: "inner" >
|	< INSERT: "insert" >
|	< INTERSECT: "intersect" >
|	< INTO: "into" >
|	< IS: "is" >
|	< JOIN: "join" >
|	< KEEP: "keep" >
|	< KEEPFIXED: "keepfixed" >
|	< KEY: "key" >
|	< KILL: "kill" >
|	< LEFT: "left" >
|	< LIKE: "like" >
|	< LINENO: "lineno" >
|	< LOCAL: "local" >
|	< LOAD: "load" >
|	< LOOP: "loop" >
|	< MATCH : "match" >
|	< MAXDOP: "maxdop" >	
|	< MERGE: "merge" >
|	< NATIONAL: "national" >
|	< NATURAL: "natural" >
|	< NOCHECK: "nocheck" >
|	< NOLOCK: "nolock" >
|	< NONCLUSTERED: "nonclustered" >
|	< NOT: "not" >
|	< NULL: "null" >

	//| < NULLIF: "nullif" >
|	< OF: "of" >
|	< OFF: "off" >
|	< OFFSETS: "offsets" >
|	< ON: "on" >
|	< OPEN: "open" >
|	< OPENDATASOURCE: "opendatasource" >
|	< OPENQUERY: "openquery" >
|	< OPENROWSET: "openrowset" >
|	< OPENXML: "openxml" >
|	< OPTION: "option" >
|	< OR: "or" >
|	< ORDER: "order" >
|	< OUTER: "outer" >
|	< OVER: "over" >
|	< OVERLAPS : "overlaps" >
|	< PAGLOCK: "paglock" >
|	< PARTIAL : "partial" >
|	< PERCENT: "percent" >
|	< PLAN: "plan" >
|	< PRECISION: "precision" >
|	< PRIMARY: "primary" >
|	< PRINT: "print" >
|	< PROC: "proc" >
|	< PROCEDURE: "procedure" >
|	< PUBLIC: "public" >
|	< RAISERROR: "raiserror" >
|	< RAW: "raw" >
|	< READ: "read" >
|	< READCOMMITED: "readcommited" >
|	< READPAST: "readpast" >
|	< READTEXT: "readtext" >
|	< READUNCOMMITED: "readuncommited" >
|	< RECONFIGURE: "reconfigure" >
|	< REFERENCES: "references" >
|	< REGION: "region" >
|	< REMOTE: "remote" >
|	< REPEATABLEREAD: "repeatableread" >
|	< REPLICATION: "replication" >
|	< RESTORE: "restore" >
|	< RESTRICT: "restrict" >
|	< RETURN: "return" >
|	< REVOKE: "revoke" >
|	< RIGHT: "right" >
|	< ROBUST: "robust" >
|	< ROLLBACK: "rollback" >
|	< ROLLUP: "rollup" >
|	< ROWCOUNT: "rowcount" >
|	< ROWGUIDCOL: "rowguidcol" >
|	< ROWLOCK: "rowlock" >
|	< RULE: "rule" >
|	< SAVE: "save" >
|	< SCHEMA: "schema" >
|	< SELECT: "select" >
|	< SERIALIZABLE: "serializable" >
|	< SESSION_USER: "session_user" >
|	< SET: "set" >
|	< SETUSER: "setuser" >
|	< SHUTDOWN: "shutdown" >
|	< SOME: "some" >
|	< STATISTICS: "statistics" >
|	< SYSTEM_USER: "system_user" >
|	< TABLE: "table" >
|	< TABLOCK: "tablock" >
|	< TABLOCKX: "tablockx" >
|	< TEXTSIZE: "textsize" >
|	< THEN: "then" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TIES: "ties" >
|	< TO: "to" >
|	< TOP: "top" >
|	< TRAN: "tran" >
|	< TRANSACTION: "transaction" >
|	< TRIGGER: "trigger" >
|	< TRUTH_VALUE : "true" | "falsed" | "unknown" >
|	< TSEQUAL: "tsequal" >
|	< UNION: "union" >
|	< UNIQUE: "unique" >
|	< UPDATE: "update" >
|	< UPDATETEXT: "updatetext" >
|	< UPDLOCK: "updlock" >
|	< USE: "use" >
|	< USER: "user" >
|	< USING : "using" >
|	< VALUES: "values" >
|	< VARYING: "varying" >
|	< VIEW: "view" >
|	< VIEWS: "views" >
|	< WAITFOR: "waitfor" >
|	< WHEN: "when" >
|	< WHERE: "where" >
|	< WHILE: "while" >
|	< WITH: "with" >
|	< WRITETEXT: "writetext" >
|	< XLOCK: "xlock" >
|	< XMATCH: "xmatch" >
|	< XML: "xml" >
|	< XMLDATA: "xmldata" >

	//math
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >
	
	//aggregate
|	< MAX: "max" >
|	< MIN: "min" >
|	< SUM: "sum" >
|	< AVG: "avg" >
|	< COUNT: "count" >


|	< COLON : ":" >
|	< COMMA : "," >
|	< SEMICOLON : ";" >
|	< LPAREN : "(" >
|	< RPAREN : ")" >
|	< LSQUARE : "[" >
|	< RSQUARE : "]" >

|	< DIVIDE : "/" >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< STAR : "*" >
|	< MOD : "%" >
|	< AMPERSAND : "&" >
|	< TILDE : "~" >
|	< BITWISEOR : "|" >
|	< BITWISEXOR : "^" >
|	< BANG : "!" >
|	< QUESTIONMARK : "?" >

|	< DOLLAR : "$" >
|	< SECOND: "second" >

|  	< REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >
|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">

|	< SIGN : <PLUS> | <MINUS> >
|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] > 
|	< SIGNED_INTEGER : (<PLUS> |<MINUS>) <UNSIGNED_INTEGER> >
|	< EXPONENT : ["e", "E"] <SIGNED_INTEGER> >

|	< NON_SECOND_DATETIME_FIELD: <YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE> >
|	< #YEAR: "year" >
|	< #MONTH: "month" >
|	< #DAY: "day" >
|	< #HOUR: "hour" >
|	< #MINUTE: "minute" >

|	< OTHER : ~[] >
}
 

ASTSelect topQuery() : 
{ 	ASTSelect retValue ; 	}
{
	retValue = querySpecification() <SEMICOLON> 
	{  return retValue ; }
}

//=================================

String actualIdentifier() : 
{
	Token t ;
}
{
	( t=<REGULAR_IDENTIFIER> | t=<DELIMITED_IDENTIFIER> )
	{ return t.image ;}
}


// JL. The adql/x schema does not have such a beast!
void approximateNumericLiteral() : {}
{
	mantissa() <EXPONENT>
}

void betweenPredicate() : {}
{
	rowValueConstructor() [ <NOT> ] <BETWEEN> rowValueConstructor() <AND> rowValueConstructor()	
}

void booleanPrimary() : {} 
{
	LOOKAHEAD(3)
	predicate()
    | 
    <LPAREN> searchCondition() <RPAREN>
}

void booleanTerm() : {}
{
	// refactored
	[ <NOT> ] booleanTest() ( <AND> [ <NOT> ] booleanTest() )*
}

void booleanTest() : {}
{
	booleanPrimary() [ <IS> [ <NOT> ] <TRUTH_VALUE> ]
}

void likePredicate() : {}
{
	match() [ <NOT> ] <LIKE> pattern() [ <ESCAPE> escapeCharacter() ]	
}

void mantissa() : {}
{
	exactNumericLiteral()
}

void caseExpression() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification() : {}
{
	"6-TBD castSpecification"
}

ScalarExpressionType characterFactor() : 
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=characterPrimary()
	{ return seType ; }
}

ScalarExpressionType characterPrimary() : 
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=commonPrimary()
	{ return seType ; }
}

ScalarExpressionType characterValueExpression() : 
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=characterFactor()
	{ return seType ; }	
}

void collateClause() : {}
{
	// refactored
	<COLLATE> qualifiedName()	
}

String columnName() : 
{
	String name = null ;
}
{
	name=identifier()
	{ return name ; }
}

void columnNameList()  : {}
{
	 columnName() ( <COMMA> columnName() )*	
}

ColumnReferenceType columnReference() : 
{
	ColumnReferenceType crType = null ;
	String q = null ;
	String n = null ;
}
{
	( [ LOOKAHEAD(2) q=qualifier() <DOT> ] n=columnName() )
	{ 
		if( n != null ) {
			crType = ColumnReferenceType.Factory.newInstance() ;
			crType.setName( n ) ;
			if( q != null ) {
				crType.setTable( q ) ;	
			}
		}		
		return crType ; 	
	}
}

ScalarExpressionType commonPrimary() : 
{
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	(
		// Foreshortened 
		seType=unsignedValueSpecification()
		|
		seType=columnReference()
		|
		seType=setFunctionSpecification()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()	//	|
		( <LPAREN> seType=valueExpression() <RPAREN> ) 
		{
			if( seType != null ) {
				ClosedExprType ceType = ClosedExprType.Factory.newInstance() ;
				ceType.setArg( seType ) ;	
				seType = ceType ;			
			}
		}
	// JBL: cast ommitted in initial version	//	|	//	castSpecification()
	)
	{ return seType ; }
}

void comparisonOperator() : {}
{
	<EQUALS_OPERATOR> |<NOT_EQUALS_OPERATOR> |<LESS_THAN_OPERATOR> | <GREATER_THEN_OPERATOR> | <LESS_THAN_OR_EQUALS_OPERATOR> | <GREATER_THAN_OR_EQUALS_OPERATOR>	
}

void comparisonPredicate() : {}
{
	rowValueConstructor() comparisonOperator() rowValueConstructor()
}

String correlationName() : 
{
	String name = null ;
}
{
	name=identifier()
	{ return name ; }
}

void dateTimeFactor() : {}
{
	dateTimePrimary() [  LOOKAHEAD(2) timeZone() ]
}

void dateTimePrimary() : {}
{
	commonPrimary()
    | 
    dateTimeValueFunction()
}

void dateTimeTerm() : {}
{
    dateTimeFactor()
}

void dateTimeValueExpression() : {}
{
	// refactored
	LOOKAHEAD(3)
    ( dateTimeTerm() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) dateTimeValueExpression() )* )
    |
    ( intervalValueExpression() <PLUS> dateTimeTerm() )
}

void dateTimeValueFunction() : {}
{
	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LPAREN> timePrecision() <RPAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LPAREN> timeStampPrecision() <RPAREN> ]
}

void derivedColumnList() : {}
{
   columnNameList()	
}

void derivedTable() : {}
{
   tableSubQuery()
}

void endField() : {}
{
	<NON_SECOND_DATETIME_FIELD> | <SECOND> [ <LPAREN> intervalFractionalSecondsPrecision() <RPAREN> ]
}

void escapeCharacter() : {}
{
	characterValueExpression()	
}

AtomType exactNumericLiteral() : 
{
	AtomType atomType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{ 
	(
		LOOKAHEAD(3) 
		( t1=<UNSIGNED_INTEGER> [ <DOT> [ t2=<UNSIGNED_INTEGER> ] ] ) 
		| 
		( <DOT> t2=<UNSIGNED_INTEGER> )
	)
	{ 
		if( t1 != null || t2 != null ) {
			atomType = AtomType.Factory.newInstance() ;	
		}
		if( t1 != null && t2 == null ) {
			IntegerType intType = IntegerType.Factory.newInstance() ;
			intType.setValue( new Long( t1.image ).longValue() ) ;
			atomType.setLiteral( intType ) ;
		}
		else if( t1 != null && t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( t1.image + '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}		
		else if( t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}
		return atomType ;
	}
}

void existsPredicate() : {}
{
	<EXISTS> tableSubQuery()	
}

void explicitTable() : {}
{
	<TABLE> tableName()
}

ScalarExpressionType factor() : 
{
	ScalarExpressionType retType = null ;
	ScalarExpressionType seType = null ;
	UnaryExprType ueType = null ;
}
{
	// ( [ <PLUS> | <MINUS> ] numericPrimary() )
	( ueType=factor_Unary() seType=numericPrimary() )
	{ 
	   if( ueType != null ) {
	   	  ueType.setArg( seType ) ;
	   	  retType = ueType ;
	   }
	   else {
	   	  retType = seType ;
	   }
	   return retType ;
	}
}

UnaryExprType factor_Unary() : 
{
	UnaryExprType ueType = null ;
	Token t = null ;
}
{
	( [ t=<PLUS> | t=<MINUS> ] )
	{ 
	   if( t != null ) {
	   		ueType = UnaryExprType.Factory.newInstance() ;
	   		ueType.setOper( UnaryOperatorType.Enum.forString( t.image ) ) ;	   	
	   }
	   return ueType ;
	}
}

void fromClause() #From : 
{
	FromTableType ftType = null ;
}
{
	( 
		<FROM> ftType=tableReference() { jjtThis.tableRefList.add( ftType ) ; } 
		( <COMMA> ftType=tableReference() { jjtThis.tableRefList.add( ftType ) ; } )* 
	)
	
}

AggregateFunctionType generalSetFunction() : 
{
	AggregateFunctionType afType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	// JL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> [ setQuantifier() ] seType=valueExpression() <RPAREN>	
	( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> seType=valueExpression() <RPAREN>
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			argArray[0] = seType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }	
}

ScalarExpressionType generalValueSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=variableSpecification()
	{ return seType ; }	
}

void groupByClause() #GroupBy : {}
{
	<GROUPBY> groupingColumnReferenceList()
}

void groupingColumnReferenceList() : {}
{
	groupingColumnReference() ( <COMMA> groupingColumnReference() )* 
}

void groupingColumnReference() : {}
{
	columnReference() [ collateClause() ]	
}

void havingClause() #Having : {}
{	
	<HAVING> searchCondition()
}

String identifier() : 
{ String retValue ;}
{
	// Foreshortened
	retValue=actualIdentifier()
	{ return retValue ; }
} 

void inPredicate() : {}
{
	// refactored
	LOOKAHEAD(3)
	rowValueConstructor() [ <NOT> ] <IN> tableSubQuery() | ( <LPAREN> inValueList() <RPAREN> )  
}

void intervalFactor() : {}
{
    [ <PLUS> | <MINUS> ] intervalPrimary()
}

void intervalFractionalSecondsPrecision() : {}
{
	<UNSIGNED_INTEGER>	
}

void intervalLeadingFieldPrecision() : {}
{
	<UNSIGNED_INTEGER>	
}

void intervalPrimary() : {}
{
      commonPrimary() [ LOOKAHEAD(2) intervalQualifier() ]
}

void intervalQualifier() : {}
{
	LOOKAHEAD(3)
    startField() <TO> endField()
    | 
    singleDateTimeField()
}

void intervalTerm() : {}
{
	// refactored
	LOOKAHEAD(3)
	intervalFactor() 
    |
	LOOKAHEAD(3)    
    factor() (<STAR> | <DIVIDE>) intervalTerm()
    | 
    term() <STAR> intervalFactor()
}

void intervalValueExpression() : {}
{
	// refactored
	LOOKAHEAD(3)
	intervalTerm() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) intervalTerm() )*
    | 
    <LPAREN> dateTimeValueExpression() <MINUS> dateTimeTerm() <RPAREN> intervalQualifier()
}

void inValueList() : {}
{
    valueExpression() ( <COMMA> valueExpression() )*		
}

ComparisonPredType joinSpecification() : 
{
	ComparisonPredType cpType = null ;
}
{
	(
		// refactored
		<ON> searchCondition()
// foreshortened. columnNameList not supported in adql
//	    |//	    <USING> <LPAREN> columnNameList() <RPAREN>
    )
    { return cpType ; }
}

JoinTableType joinedTable() : 
{
	JoinTableType jtType = null ;
	Token t = null ;
}
{
	(
		LOOKAHEAD(3)
		jtType=crossJoin()
		|
		LOOKAHEAD(3)
		jtType=qualifiedJoin()
		|
		( t=<LPAREN> jtType=joinedTable() <RPAREN> )
	)
	{ return jtType ; }
}

JointTableQualifierType joinType() : 
{
	JointTableQualifierType jType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	(
		// refactored
		t1=<INNER>
	    | 
	    ( t1=<LEFT> | t1=<RIGHT> | t1=<FULL> ) [ t2=<OUTER> ] 
// JL. Adql does not appear to support UNION
//	    | //	    t1=<UNION>
    )
    {
    	if( t1 != null ) {
    		jType = JointTableQualifierType.Factory.newInstance() ;
    		 switch ( t1.kind ) {
    			case AdqlStoXConstants.INNER :
      				jType.set( JointTableQualifierType.INNER );
      				break;
      			case AdqlStoXConstants.LEFT :
      				jType.set( JointTableQualifierType.LEFT_OUTER );
      				break;
      			case AdqlStoXConstants.RIGHT :
      				jType.set( JointTableQualifierType.RIGHT_OUTER );
      				break;
      			case AdqlStoXConstants.FULL :
      				jType.set( JointTableQualifierType.FULL_OUTER );
      				break;
//      			case AdqlStoXConstants.UNION ://      				jType.set( JointTableQualifierType.??? );//      				break;
    		}   		
    	}
    	return jType ;
    }
}


void match() : {}
{
	characterValueExpression()	
}

void matchPredicate() : {}
{
	rowValueConstructor() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] tableSubQuery() 
}

MathFunctionType mathFunctions() : 
{
	MathFunctionType mfType = null ; 
	ScalarExpressionType arg1 = null ;
	Token t = null ;
	Token t2 = null ;
}
{
	(
		( t=<CEILING> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<DEGREES> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<EXP> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<FLOOR> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<PI> <LPAREN><RPAREN> )
		|
		( t=<POWER> <LPAREN> arg1=numericValueExpression() <COMMA> t2=<UNSIGNED_INTEGER> <RPAREN> )
		|
		( t=<RADIANS> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<SQRT> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG10> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<RAND> <LPAREN> [ arg1=numericValueExpression() ] <RPAREN> )
		|
		( t=<ROUND> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<TRUNCATE> <LPAREN> arg1=numericValueExpression() <RPAREN> )
	)
	{
	   if( t != null ) {
	   	  mfType = MathFunctionType.Factory.newInstance() ;
	   	  mfType.setName( MathFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
	   	  if( arg1 != null ) {
	   	  	 SelectionItemType[] argArray ;
	   	  	 if( t.kind != AdqlStoXConstants.POWER ) {
	   	        argArray = new SelectionItemType[1] ;
	   	        argArray[0] = arg1 ;
	   	  	 }
	   	  	 else {
	   	  	 	argArray = new SelectionItemType[2] ;
	   	  	 	argArray[0] = arg1 ;
	   	  	 	AtomType atomType = AtomType.Factory.newInstance() ;
	   	  	 	IntegerType intType = IntegerType.Factory.newInstance() ;
	   	  	 	intType.setValue( new Long( t2.image ).longValue() ) ;
	   	  	 	atomType.setLiteral( intType ) ;
	   	  	 	argArray[1] = atomType ;
	   	  	 }
	   	     mfType.setArgArray( argArray ) ;
	   	  }
	   }
	   return mfType ;
	}
}

void nullPredicate() : {}
{
	rowValueConstructor() <IS> [ <NOT> ] <NULL>	
}

ScalarExpressionType numericPrimary() : 
{
	ScalarExpressionType seType = null ;
}
{
	( 
	  seType=numericValueFunction()	
	  |	  seType=commonPrimary()
	)
	{ return seType ; } 
	
}

ScalarExpressionType numericValueExpression() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// term() ( LOOKAHEAD(2) ( <PLUS> | <MINUS> ) numericValueExpression() )*
	seType=term() exprPairs=numericValueExpression_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] numericValueExpression_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;
	Token t = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=numericValueExpression_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] numericValueExpression_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<PLUS> | t=<MINUS> ) seType=numericValueExpression()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;					beType = BinaryExprType.Factory.newInstance() ;			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}

ScalarExpressionType numericValueFunction() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		// JBL ADQL adaptation
		seType=trigFunctions()
		|
		seType=mathFunctions()	
	)
	{ return seType ; }
}

void orderBy() #OrderBy : {} 
{
	<ASC> | <DESC>	
}

void overlapsPredicate() : {}
{
	rowValueConstructor() <OVERLAPS> rowValueConstructor()	
}

void pattern() : {}
{
	characterValueExpression()	
}

void predicate() : {}
{
	LOOKAHEAD(3)
	comparisonPredicate()
    | 
    LOOKAHEAD(3)
    betweenPredicate()
    | 
    LOOKAHEAD(3)
    inPredicate()
    | 
    LOOKAHEAD(3)    likePredicate()    | 
    LOOKAHEAD(3)    nullPredicate()    | 
    LOOKAHEAD(3)
	quantifiedComparisonPredicate()    |     existsPredicate()    |     uniquePredicate()    | 
    LOOKAHEAD(3)    matchPredicate()    |     overlapsPredicate()
}

JoinTableType qualifiedJoin() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
	JointTableQualifierType jtqType = null ;
	ComparisonPredType cpType = null ;
}
{
	(
		fType1=tableReferenceBarJoinedTable() 
		[ <NATURAL> ] 
		jtqType=joinType() 
		<JOIN> 
		fType2=tableReference() 
		[ LOOKAHEAD(3) cpType=joinSpecification() ]
	)
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	      jtType.xsetQualifier( jtqType ) ;
	      if( cpType != null ) {
	      		jtType.setCondition( cpType ) ;
	      }
	   }
	   return jtType ;	
	}
}

String qualifiedName() : 
{
	String retValue ;
} 
{
	retValue = identifier()
	{ return retValue ; }	
}

String qualifier() : 
{	
	String retValue ;
}
{
	// Foreshortened
	retValue=tableName()
	{ return retValue ; }
}

ASTSelect querySpecification() #Select : {}
{
	<SELECT> [ setQuantifier() ] [ setLimit() ] selectList() tableExpression()
	{ return jjtThis ; }
}

void rowSubquery() : {}
{
	subQuery()	
}

void rowValueConstructor() : {}
{
	LOOKAHEAD(3)
	rowValueConstructorElement()
    | 
    LOOKAHEAD(2)
    <LPAREN> rowValueConstructorList() <RPAREN>
    | 
    rowSubquery()
}

void rowValueConstructorElement() : {}
{
	valueExpression()
    | 
    <NULL>
    | 
    <SQL_DEFAULT>
}

void rowValueConstructorList() : {}
{
	rowValueConstructorElement() ( <COMMA> rowValueConstructorElement() ) *
}

void scalarSubquery() : {}
{
	subQuery()
}

void searchCondition() : {}
{
	// refactored
	booleanTerm() ( <OR> booleanTerm() )*
}

void selectList() # SelectionList : {}
{
	allSelectionItem( jjtThis.itemList ) | ( selectSublist( jjtThis.itemList ) ( <COMMA> selectSublist( jjtThis.itemList ) )* )
}

void allSelectionItem( ArrayList itemList ) : {}
{
	<STAR>
	{ itemList.add( AllSelectionItemType.Factory.newInstance() ) ; }
}

void selectSublist( ArrayList itemList ) : 
{ 
	SelectionItemType siType = null ;
}
{   
	LOOKAHEAD(3)
	selectSublist_Qualifier() 
	|
	siType=selectSublist_ValueExpression()
	{ itemList.add( siType ) ; }		
}

String selectSublist_Qualifier() : 
{
	String retValue ;
}
{
	// NOTE. someTable.* is not currently within the adql/x schema!
	retValue=qualifier() <DOT> <STAR> 
	{ return retValue + ".*" ;}
}

SelectionItemType selectSublist_ValueExpression() : 
{
	SelectionItemType siType = null ;
}
{
	( siType=valueExpression() [ [<AS>] columnName() ] )	
	{ return siType ; }	
}

AggregateFunctionType setFunctionSpecification() : 
{
	AggregateFunctionType afType = null ;
	Token t = null ;
}
{
	(
		LOOKAHEAD(3)
		( t=<COUNT> <LPAREN> <STAR> <RPAREN> ) 
		|
		afType=generalSetFunction()
	)
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.COUNT ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			AtomType atomType = AtomType.Factory.newInstance() ;
			StringType star = StringType.Factory.newInstance() ;
			star.setValue( "*" ) ;
			atomType.setLiteral( star ) ;
			argArray[0] = atomType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }
}

void setLimit() #Restrict : 
{ 
	Token t ;
}
{
	<TOP> <LPAREN> t=<UNSIGNED_INTEGER> <RPAREN>
	{ jjtThis.setValue( ( new Integer( t.image )).intValue()) ;}
}

void setQuantifier() #Allow : 
{
	Token t ;
}
{
	t=<ALL> | t=<DISTINCT>
	{ 	
		if( t.kind == AdqlStoXConstants.ALL ) {
			jjtThis.setValue( AllOrDistinctType.ALL ) ;
		}
		else {
			jjtThis.setValue( AllOrDistinctType.DISTINCT ) ;
		}
	}
}

void singleDateTimeField() : {}
{
	<NON_SECOND_DATETIME_FIELD> [ <LPAREN> intervalLeadingFieldPrecision() <RPAREN> ]
    | 
    <SECOND> [ <LPAREN> intervalLeadingFieldPrecision() [ <COMMA> intervalFractionalSecondsPrecision() ] <RPAREN> ]
}

void startField() : {}
{
    <NON_SECOND_DATETIME_FIELD> [ <LPAREN> intervalLeadingFieldPrecision() <RPAREN> ]
}

ScalarExpressionType stringValueExpression() :
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=characterValueExpression()
	{ return seType ; }
}

void subQuery() : {}
{
	<LPAREN> queryExpression() <RPAREN>
}

void quantifiedComparisonPredicate() : {}
{
	rowValueConstructor() comparisonOperator() quantifier() tableSubQuery()	
}

void quantifier() : {}
{
	<ALL> | ( <SOME> | <ANY> )	
}

void queryExpression() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryExpression()
	|
	joinedTable()
}

void queryPrimary() : {}
{
    LOOKAHEAD(3)
 	nonJoinQueryPrimary()
    | 
    joinedTable()
}


void queryTerm() : {}
{
	LOOKAHEAD(2)
	nonJoinQueryTerm()
	|
	joinedTable()	
}

void correspondingSpec() : {}
{
	<CORRESPONDING> [ <BY> <LPAREN> correspondingColumnList() <RPAREN> ] 
}
    
void correspondingColumnList() : {}
{
	columnNameList()	
}

JoinTableType crossJoin() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	( fType1=tableReferenceBarJoinedTable() <CROSS_JOIN> fType2=tableReference() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JointTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   return jtType ;	
	}
}


void nonJoinQueryExpression() : {}
{
// Originally ...
//	nonJoinQueryTerm()//	|//	queryExpression() <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm()//	|//	queryExpression() <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm()

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	
//	LOOKAHEAD(3)//	queryTerm() ( <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	LOOKAHEAD(3)//	queryTerm() ( <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	nonJoinQueryTerm()

	LOOKAHEAD(4)
	queryTerm() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ correspondingSpec() ] queryTerm() )*
	|
	nonJoinQueryTerm()
}

void nonJoinQueryTerm() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryPrimary()
	|
	queryPrimary() <INTERSECT> [ <ALL> ] [ correspondingSpec() ] queryPrimary()	
}

void nonJoinQueryPrimary() : {}
{
	simpleTable()
	|
	<LPAREN> nonJoinQueryExpression() <RPAREN>
}

void simpleTable() : {}
{
	querySpecification()
	|
	tableValueConstructor()
	|
	explicitTable()	
}

void tableExpression() : {} 
{
	fromClause() [ whereClause() ] [ groupByClause() ] [ havingClause() ] [ orderBy() ]	
}

String tableName() : 
{
	String retValue = null ;
}
{
	// Forshortened
	retValue=qualifiedName()
	{ return retValue ; }
}

FromTableType tableReference() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
} 
{
	(
		// refactored... 
		// 1. derivedTable() moved to first choice point
		// 2. joinedTable() moved to second choice point
//	    LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName() [ <LPAREN> derivedColumnList() <RPAREN> ]//	    |	//		LOOKAHEAD(4)//	    joinedTable()//	    |//		tableName() [ [ <AS> ] correlationName() [ <LPAREN> derivedColumnList() <RPAREN> ] ]    

		// Foreshortened. 
		// derivedColumnList not supported in adql
		// derivedTable not supported in adql
//		LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName()//	    |	
		LOOKAHEAD(4)
	    ftType=joinedTable()
	    |
		( tName=tableName() [ [ <AS> ] cName=correlationName() ] )
		{
			if( tName != null ) {	
				TableType tableType = TableType.Factory.newInstance() ;
				tableType.setName( tName ) ;
				if( cName != null )
					tableType.setAlias( cName ) ;
				ftType = tableType ;
			}
		} 
	)
	{ return ftType ; } 
}

// Adaptation of tableReference()
FromTableType tableReferenceBarJoinedTable() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
}
{
	( tName=tableName() [ [ <AS> ] cName=correlationName() ] )
	{
		if( tName != null ) {	
			TableType tableType = TableType.Factory.newInstance() ;
			tableType.setName( tName ) ;
			if( cName != null )
				tableType.setAlias( cName ) ;
			ftType = tableType ;
		}
	}
	{ return ftType ; }
}

void tableSubQuery() : {}
{
	subQuery()	
}

void tableValueConstructor() : {}
{
	<VALUES> tableValueConstructorList()
}

void tableValueConstructorList() : {}
{
	rowValueConstructor() ( <COMMA> rowValueConstructor() )*	
}

//ScalarExpressionType term() : //{//	ScalarExpressionType seType = null ;//}//{//	// refactored//	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*//	factor() term_List() //	{ return seType ; }//}

ScalarExpressionType term() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*
	seType=factor() exprPairs=term_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] term_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;
	Token t = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=term_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] term_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<STAR> | t=<DIVIDE> ) seType=term()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;		
			beType = BinaryExprType.Factory.newInstance() ;
			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}




void timeFractionalSecondsPrecision() : {}
{
	<UNSIGNED_INTEGER> 	
}

void timePrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeStampPrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeZone() : {}
{
	// refactored
    <AT> ( <LOCAL> | (<TIME_ZONE> intervalValueExpression() ) ) 
}

TrigonometricFunctionType trigFunctions() : 
{
	TrigonometricFunctionType tfType = null ; 
	ScalarExpressionType arg1 = null ;
	ScalarExpressionType arg2 = null ;
	Token t = null ;
}
{
	(
		t=<ACOS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ASIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN2> <LPAREN> arg1=numericValueExpression() <COMMA> arg2=numericValueExpression() <RPAREN>
		|
		t=<COS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<COT> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<SIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<TAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
	)
	{
		if( t != null ) {
			ScalarExpressionType[] argArray = null ;
			tfType = TrigonometricFunctionType.Factory.newInstance() ;
			tfType.setName( TrigonometricFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			if( arg2 != null ) {
				argArray = new ScalarExpressionType[2] ;
				argArray[0] = arg1 ;
				argArray[1] = arg2 ;
			}
			else {
				argArray = new ScalarExpressionType[1] ;
				argArray[0] = arg1 ;
			}
			tfType.setArgArray( argArray ) ;
		}
		return tfType ;
	}
}

void uniquePredicate() : {}
{
	<UNIQUE> tableSubQuery()	
}

AtomType unsignedLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
		// foreshortened
	    atomType=unsignedNumericLiteral()
		// | 		// generalLiteral()
	)
	{ return atomType ; }
}

AtomType unsignedNumericLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
// JL. Note the adql/x schema does not possess an approximateNumericLiteral
//		LOOKAHEAD(3)//		exactNumericLiteral()//	    | //	    approximateNumericLiteral()

		atomType=exactNumericLiteral()
    )
    { return atomType ; }
}


ScalarExpressionType unsignedValueSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		seType=unsignedLiteral()
		|
		generalValueSpecification()
	)
	{ return seType ;  }
}

ScalarExpressionType valueExpression() : 
{
	ScalarExpressionType retValue = null ;
} 
{
	(
	LOOKAHEAD(3) 
	retValue=numericValueExpression() 
	|
	LOOKAHEAD(3) 	
	retValue=stringValueExpression() 
	// JL. foreshortened. At present there seems no accommodation for
	// datetime and interval expressions in adql
//	|//	LOOKAHEAD(3) //	dateTimeValueExpression() //	|//	intervalValueExpression()
	)
	{ return retValue ; }
	
}

ScalarExpressionType variableSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	// JBL ADQL adaptation to accommodate scripting variables.
	// Details still to be worked out.
	<DOLLAR> <LBRACE> <REGULAR_IDENTIFIER> <RBRACE>
	{ return seType ; }
}

void whereClause() #Where : {}
{
	<WHERE>	searchCondition()
}