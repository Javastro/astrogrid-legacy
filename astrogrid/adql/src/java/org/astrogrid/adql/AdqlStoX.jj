/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./AdqlStoX.jj */
/*@egen*//**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.4";
  STATIC=false;                                                                                      
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import java.util.* ;
import org.astrogrid.adql.v1_0.beans.* ;

public class AdqlStoX/*@bgen(jjtree)*/implements AdqlStoXTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTAdqlStoXState jjtree = new JJTAdqlStoXState();

/*@egen*/
	
	public SelectDocument exec() {
		SelectDocument selectDoc = null ;
		try {			
			selectDoc = selectDocument();
		}
		catch( ParseException pex ) {
			pex.printStackTrace() ;
			//System.out.println( pex.getMessage() ) ;
		}
		catch( Error err ) {
			err.printStackTrace() ;
			//System.out.println( err.getMessage() ) ;
		}
		return selectDoc ;	
	}

}
PARSER_END(AdqlStoX)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}


TOKEN : 
{
	< LBRACE : "{" >
|	< RBRACE : "}" >
	
|	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< EQUALS_OPERATOR : "=" >
|	< LESS_THAN_OPERATOR : "<" >
|	< GREATER_THEN_OPERATOR : ">" >

|	< ADD: "add" >
|	< ALL: "all" >
|	< AND: "and" >
|	< ANY: "any" >
|	< AS: "as" >
|	< ASC: "asc" >
|	< AT : "at" >
|	< AUTHORIZATION: "authorization" >
|	< BASE64: "base64" >
|	< BEGIN: "begin" >
|	< BETWEEN: "between" >
|	< BINARY: "binary" >
|	< BREAK: "break" >
|	< BY: "by" >
|	< CASE: "case" >
|	< CAST: "cast" >
|	< CHECKPOINT: "checkpoint" >
|	< CLOSE: "close" >
|	< CLUSTERED: "clustered" >

|   < COALESCE: "coalesce" >
|	< COLLATE: "collate" >
|	< COLUMN: "column" >
|	< COMMIT: "commit" >
|	< COMPUTE: "compute" >
|	< CONCAT: "concat" >
|	< CONSTRAINT: "constraint" >
|	< CONTAINS: "contains" >
|	< CONTAINSTABLE: "containstable" >
|	< CONTINUE: "continue" >

|	< CORRESPONDING : "corresponding" >

	//| < CONVERT: "convert" >
|	< CREATE: "create" >
//|	< CROSS: "cross" >
|	< CROSS_JOIN : "cross join">
|	< CUBE: "cube" >
|	< CURRENT: "current" >
|	< CURRENT_DATE: "current_date" >
|	< CURRENT_TIME: "current_time" >
|	< CURRENT_TIMESTAMP: "current_timestamp" >
|	< CURRENT_USER: "current_user" >
|	< CURSOR: "cursor" >
|	< DATABASE: "database" >
|	< DBCC: "dbcc" >
|	< DEALLOCATE: "deallocate" >
|	< DECLARE: "declare" >
|	< SQL_DEFAULT: "default" >
|	< DELETE: "delete" >
|	< DENY: "deny" >
|	< DESC: "desc" >
|	< DISK: "disk" >
|	< DISTINCT: "distinct" >
|	< DISTRIBUTED: "distributed" >
|	< DOT: "." >
|	< DOUBLE: "double" >
|	< DROP: "drop" >
|	< DUMP: "dump" >
|	< ELEMENTS: "elements" >
|	< ELSE: "else" >
|	< END: "end" >
|	< ERRLVL: "errlvl" >
|	< ESCAPE: "escape" >
|	< EXCEPT: "except" >
|	< EXEC: "exec" >
|	< EXECUTE: "execute" >
|	< EXISTS: "exists" >
|	< EXIT: "exit" >
|	< EXPAND: "expand" >
|	< EXPLICIT: "explicit" >
|	< FAST: "fast" >
|	< FASTFIRSTROW: "fastfirstrow" >
|	< FETCH: "fetch" >
|	< FILE: "file" >
|	< FILLFACTOR: "fillfactor" >
|	< FOR: "for" >
|	< FORCE: "force" >
|	< FOREIGN: "foreign" >
|	< FREETEXT: "freetext" >
|	< FREETEXTTABLE: "freetexttable" >
|	< FROM: "from" >
|	< FULL: "full" >
|	< FUNCTION: "function" >
|	< GOTO: "goto" >
|	< GRANT: "grant" >
|	< GROUPBY: "group by" >
|	< HASH: "hash" >
|	< HAVING: "having" >
|	< HOLDLOCK: "holdlock" >
|	< IDENTITY: "identity" >
|	< IDENTITY_INSERT: "identity_insert" >
|	< IDENTITYCOL: "identitycol" >
|	< IF: "if" >
|	< IN: "in" >
|	< INDEX: "index" >
|	< INNER: "inner" >
|	< INSERT: "insert" >
|	< INTERSECT: "intersect" >
|	< INTO: "into" >
|	< IS: "is" >
|	< JOIN: "join" >
|	< KEEP: "keep" >
|	< KEEPFIXED: "keepfixed" >
|	< KEY: "key" >
|	< KILL: "kill" >
|	< LEFT: "left" >
|	< LIKE: "like" >
|	< LINENO: "lineno" >
|	< LOCAL: "local" >
|	< LOAD: "load" >
|	< LOOP: "loop" >
|	< MATCH : "match" >
|	< MAXDOP: "maxdop" >	
|	< MERGE: "merge" >
|	< NATIONAL: "national" >
|	< NATURAL: "natural" >
|	< NOCHECK: "nocheck" >
|	< NOLOCK: "nolock" >
|	< NONCLUSTERED: "nonclustered" >
|	< NOT: "not" >
|	< NULL: "null" >

	//| < NULLIF: "nullif" >
|	< OF: "of" >
|	< OFF: "off" >
|	< OFFSETS: "offsets" >
|	< ON: "on" >
|	< OPEN: "open" >
|	< OPENDATASOURCE: "opendatasource" >
|	< OPENQUERY: "openquery" >
|	< OPENROWSET: "openrowset" >
|	< OPENXML: "openxml" >
|	< OPTION: "option" >
|	< OR: "or" >
|	< ORDER: "order" >
|	< ORDERBY : "order by" >
|	< OUTER: "outer" >
|	< OVER: "over" >
|	< OVERLAPS : "overlaps" >
|	< PAGLOCK: "paglock" >
|	< PARTIAL : "partial" >
|	< PERCENT: "percent" >
|	< PLAN: "plan" >
|	< PRECISION: "precision" >
|	< PRIMARY: "primary" >
|	< PRINT: "print" >
|	< PROC: "proc" >
|	< PROCEDURE: "procedure" >
|	< PUBLIC: "public" >
//|	< QUOTE : "'" >
|	< RAISERROR: "raiserror" >
|	< RAW: "raw" >
|	< READ: "read" >
|	< READCOMMITED: "readcommited" >
|	< READPAST: "readpast" >
|	< READTEXT: "readtext" >
|	< READUNCOMMITED: "readuncommited" >
|	< RECONFIGURE: "reconfigure" >
|	< REFERENCES: "references" >
|	< REGION: "region" >
|	< REMOTE: "remote" >
|	< REPEATABLEREAD: "repeatableread" >
|	< REPLICATION: "replication" >
|	< RESTORE: "restore" >
|	< RESTRICT: "restrict" >
|	< RETURN: "return" >
|	< REVOKE: "revoke" >
|	< RIGHT: "right" >
|	< ROBUST: "robust" >
|	< ROLLBACK: "rollback" >
|	< ROLLUP: "rollup" >
|	< ROWCOUNT: "rowcount" >
|	< ROWGUIDCOL: "rowguidcol" >
|	< ROWLOCK: "rowlock" >
|	< RULE: "rule" >
|	< SAVE: "save" >
|	< SCHEMA: "schema" >
|	< SELECT: "select" >
|	< SERIALIZABLE: "serializable" >
|	< SESSION_USER: "session_user" >
|	< SET: "set" >
|	< SETUSER: "setuser" >
|	< SHUTDOWN: "shutdown" >
|	< SOME: "some" >
|	< STATISTICS: "statistics" >
|	< SYSTEM_USER: "system_user" >
|	< TABLE: "table" >
|	< TABLOCK: "tablock" >
|	< TABLOCKX: "tablockx" >
|	< TEXTSIZE: "textsize" >
|	< THEN: "then" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TIES: "ties" >
|	< TO: "to" >
|	< TOP: "top" >
|	< TRAN: "tran" >
|	< TRANSACTION: "transaction" >
|	< TRIGGER: "trigger" >
|	< TRUTH_VALUE : "true" | "falsed" | "unknown" >
|	< TSEQUAL: "tsequal" >
|	< UNION: "union" >
|	< UNIQUE: "unique" >
|	< UPDATE: "update" >
|	< UPDATETEXT: "updatetext" >
|	< UPDLOCK: "updlock" >
|	< USE: "use" >
|	< USER: "user" >
|	< USING : "using" >
|	< VALUES: "values" >
|	< VARYING: "varying" >
|	< VIEW: "view" >
|	< VIEWS: "views" >
|	< WAITFOR: "waitfor" >
|	< WHEN: "when" >
|	< WHERE: "where" >
|	< WHILE: "while" >
|	< WITH: "with" >
|	< WRITETEXT: "writetext" >
|	< XLOCK: "xlock" >
|	< XMATCH: "xmatch" >
|	< XML: "xml" >
|	< XMLDATA: "xmldata" >

	//math
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >
	
	//aggregate
|	< MAX: "max" >
|	< MIN: "min" >
|	< SUM: "sum" >
|	< AVG: "avg" >
|	< COUNT: "count" >


|	< COLON : ":" >
|	< COMMA : "," >
|	< SEMICOLON : ";" >
|	< LPAREN : "(" >
|	< RPAREN : ")" >
|	< LSQUARE : "[" >
|	< RSQUARE : "]" >

|	< DIVIDE : "/" >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< STAR : "*" >
|	< MOD : "%" >
|	< AMPERSAND : "&" >
|	< TILDE : "~" >
|	< BITWISEOR : "|" >
|	< BITWISEXOR : "^" >
|	< BANG : "!" >
|	< QUESTIONMARK : "?" >

|	< DOLLAR : "$" >
|	< SECOND: "second" >

|  	< REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >
|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">

|	< SIGN : <PLUS> | <MINUS> >
|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] > 
|	< SIGNED_INTEGER : (<PLUS> |<MINUS>) <UNSIGNED_INTEGER> >
|	< EXPONENT : ["e", "E"] <SIGNED_INTEGER> >

|	< NON_SECOND_DATETIME_FIELD: <YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE> >
|	< #YEAR: "year" >
|	< #MONTH: "month" >
|	< #DAY: "day" >
|	< #HOUR: "hour" >
|	< #MINUTE: "minute" >

|	< ASCII_STRING_LITERAL : "\'" (~["\'"])* "\'" >

//| 	< ASCIIStringLiteral : "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >//|	< UnicodeStringLiteral : "n" "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >

|	< OTHER : ~[] >
}
 

SelectDocument selectDocument() : 
{ 	
	SelectDocument selectDoc = null ; 	
	SelectType st = null ;	
}
{
	st=query_specification_A() [ <SEMICOLON> ] 
	{  
		if( st != null ) {
			selectDoc =  SelectDocument.Factory.newInstance() ;
			selectDoc.setSelect( st ) ;
		}
		return selectDoc ; }
}

//=================================

String actualIdentifier() : 
{
	Token t ;
}
{
	( t=<REGULAR_IDENTIFIER> | t=<DELIMITED_IDENTIFIER> )
	{ return t.image ;}
}


// JL. The adql/x schema does not have such a beast!
void approximateNumericLiteral() : {}
{
	mantissa() <EXPONENT>
}

void betweenPredicate() : {}
{
	rowValueConstructor() [ <NOT> ] <BETWEEN> rowValueConstructor() <AND> rowValueConstructor()	
}

SearchType betweenPredicate_AG() : 
{
	
	ScalarExpressionType se1 = null ;
	ScalarExpressionType se2 = null ;
	ScalarExpressionType se3 = null ;
	Token t = null ;
}
{
//  Should be...
//	rowValueConstructor() [ <NOT> ] <BETWEEN> rowValueConstructor() <AND> rowValueConstructor()	

	( se1=valueExpression() [ t=<NOT> ] <BETWEEN> se2=valueExpression() <AND> se3=valueExpression()	)
	{
		if( se3!=null ) {
			ScalarExpressionType[] args = new ScalarExpressionType[3] ;
			args[0] = se1 ;
			args[1] = se2 ;
			args[2] = se3 ;
			if( t==null ) {
				BetweenPredType bp = BetweenPredType.Factory.newInstance() ;
				bp.setArgArray( args ) ;
				return bp ;			
			}
			else {
				NotBetweenPredType nbp = NotBetweenPredType.Factory.newInstance() ;
				nbp.setArgArray( args ) ;
				return nbp ;		
			}
		}
		return null ;
	}
}

SearchType booleanPrimary() : 
{
	SearchType st = null ;
	Token t = null ;
} 
{
	(
		LOOKAHEAD(3)
		st=predicate()
	    | 
	    <LPAREN> st=searchCondition() t=<RPAREN>
    )
    {
    	if( t != null ) {
    		ClosedSearchType cs = ClosedSearchType.Factory.newInstance() ;
    		cs.setCondition( st ) ;
    		return cs ;	
    	}
    	return st ;
    }
}

SearchType booleanTerm() : 
{
	SearchType st=null ;
	SearchType[] stPair = null ;
}
{
	// refactored
	// [ <NOT> ] booleanTest() ( <AND> [ <NOT> ] booleanTest() )*
	st=booleanTest_WithNot() stPair=booleanTest_List()
	{
		if( stPair == null ) {
		   return st ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st ;
		   conditionArray[1] = stPair[1] ;
		   IntersectionSearchType andType = (IntersectionSearchType)stPair[0] ;
		   andType.setConditionArray( conditionArray ) ;
		   return andType ;
		}	
	}
}

SearchType booleanTest_WithNot() :
{
	SearchType sc = null ;
	Token t = null ;
}
{
	[ t=<NOT> ] sc=booleanTest()
	{
		if( t != null ) {
			InverseSearchType is = InverseSearchType.Factory.newInstance() ;
			is.setCondition( sc ) ;
			return is ;		
		}
		return sc ;
	}
}

SearchType[] booleanTest_List() :
{
	ArrayList list = null ;
	SearchType[] stPair1 = null ;
	SearchType[] stPair2 = null ;
	SearchType[] retPair = null ;
}
{
	( 
		stPair1=booleanTest_Singleton() 
		{ if( list == null )
	  	     list = new ArrayList() ;
	  	  list.add( stPair1 ) ;
	  	} 	
	)*
	{
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retPair = stPair1 = (SearchType[])iterator.next() ;
			SearchType[] conditions = new SearchType[2] ;
			IntersectionSearchType andType = null ;
			while( iterator.hasNext() ) {
				stPair2 = (SearchType[])iterator.next() ;
				conditions[0] = stPair1[1] ;
				conditions[1] = stPair2[1] ;
				andType = (IntersectionSearchType)stPair2[0] ;
				andType.setConditionArray( conditions ) ;
				stPair1 = stPair2 ;
			}
		}		
		return retPair ;
	}
}

SearchType[] booleanTest_Singleton() :
{
	SearchType[] retPair = null ;
	IntersectionSearchType andType = null ;
	SearchType st = null ;
}
{
	<AND> st=booleanTest_WithNot()
	{
		if( st != null ) {
			retPair = new SearchType[2] ;		
			andType = IntersectionSearchType.Factory.newInstance() ;
			retPair[0] = andType ;
			retPair[1] = st ;
		}
		return retPair ;
	}
}

SearchType booleanTest() : 
{
	SearchType st = null ;
}
{
	st=booleanPrimary() [ <IS> [ <NOT> ] <TRUTH_VALUE> ]
	{ return st ; }
}

SearchType booleanTest_AG() : 
{
	SearchType st = null ;
}
{
	// foreshortened. adql does not support <TRUTH_VALUE> et al !!!
	st=booleanPrimary() 
	{ return st ; }
}

SearchType likePredicate() : 
{
	SearchType st = null ;
	Token t = null ;
	AtomType p = null ;
}
{
// adql does not support escape characters...
//	( match() [ <NOT> ] <LIKE> pattern() [ <ESCAPE> escapeCharacter() ]	)
	( match() [ <NOT> ] <LIKE> pattern() )

	{
		return st ;	
	}
}

void mantissa() : {}
{
	exactNumericLiteral()
}

void caseExpression() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification() : {}
{
	"6-TBD castSpecification"
}

ScalarExpressionType characterFactor() : 
{
	ScalarExpressionType seType = null ;
}
{
	// <character_primary> [ <collate_clause> ]
	
	// Foreshortened
	seType=characterPrimary()
	{ return seType ; }
}

ScalarExpressionType characterPrimary() : 
{
	ScalarExpressionType seType = null ;
}
{
	//   <value_expression_primary>
    // | <string_value_function>

	// Foreshortened
	seType=commonPrimary()
	{ return seType ; }
}


AtomType characterStringLiteral_AG() : 
{
	AtomType atomType = null ;
}
{
//  [ <introducer><character_set_specification> ]//  <quote> [ <character_representation>... ] <quote>//  [ { <separator>... <quote> [ <character_representation>... ] <quote> }... ]	

//	( t=<UnicodeStringLiteral> | t=<ASCIIStringLiteral> )
	atomType=ASCIIStringLiteral_AG()
	{ 
		return atomType ; 		
	} 
}

AtomType ASCIIStringLiteral_AG() : 
{
	AtomType at = null ;
	ArrayList list = null ;
	Token t1 = null ;
}
{
	( 
		t1=<ASCII_STRING_LITERAL> 
			{
				if( t1 != null ) {
					if( list == null )
						list = new ArrayList() ;
					list.add( t1.image.substring( 1, t1.image.length()-1 ) ) ;
					t1 = null ;
				}
			}

	)+
	{
		if( list.size() > 0 ) {
			StringBuffer buffer = new StringBuffer();
			ListIterator it = list.listIterator() ;
			while( it.hasNext() ) {
				buffer.append( (String)it.next() ) ;	
			}
			at = AtomType.Factory.newInstance() ;
			StringType st = StringType.Factory.newInstance() ;
			st.setValue( buffer.toString() ) ;
			at.setLiteral( st ) ;			
		}
		return at ;
	} 
	
}

ScalarExpressionType characterValueExpression() : 
{
	ScalarExpressionType seType = null ;
}
{
	//   <concatenation>
    // | <character_factor>
    
	// Foreshortened
	seType=characterFactor()
	{ return seType ; }	
}

void collateClause() : {}
{
	// refactored
	<COLLATE> qualifiedName()	
}

String columnName() : 
{
	String name = null ;
}
{
	name=identifier()
	{ return name ; }
}

void columnNameList()  : {}
{
	 columnName() ( <COMMA> columnName() )*	
}

ColumnReferenceType columnReference() : 
{
	ColumnReferenceType crType = null ;
	String q = null ;
	String n = null ;
}
{
	( [ LOOKAHEAD(2) q=qualifier() <DOT> ] n=columnName() )
	{ 
		if( n != null ) {
			crType = ColumnReferenceType.Factory.newInstance() ;
			crType.setName( n ) ;
			if( q != null ) {
				crType.setTable( q ) ;	
			}
		}		
		return crType ; 	
	}
}

ScalarExpressionType commonPrimary() : 
{
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	(
		// Foreshortened 
		seType=unsignedValueSpecification()
		|
		seType=columnReference()
		|
		seType=setFunctionSpecification()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()	//	|
		( <LPAREN> seType=valueExpression() <RPAREN> ) 
		{
			if( seType != null ) {
				ClosedExprType ceType = ClosedExprType.Factory.newInstance() ;
				ceType.setArg( seType ) ;	
				seType = ceType ;			
			}
		}
	// JBL: cast ommitted in initial version	//	|	//	castSpecification()
	)
	{ return seType ; }
}

ComparisonType comparisonOperator() : 
{
	ComparisonType c = null ;
	Token t = null ;
}
{
	(
		t=<EQUALS_OPERATOR> 
		|
		t=<NOT_EQUALS_OPERATOR> 
		|
		t=<LESS_THAN_OPERATOR> 
		| 
		t=<GREATER_THEN_OPERATOR> 
		| 
		t=<LESS_THAN_OR_EQUALS_OPERATOR> 
		| 
		t=<GREATER_THAN_OR_EQUALS_OPERATOR>	
	)
	{
		if( t != null )	{
			c = ComparisonType.Factory.newInstance() ;
			c.set( ComparisonType.Enum.forString( t.image.toUpperCase() ) ) ;	
		}
		return c ;
	}
}

ComparisonPredType comparisonPredicate() : 
{
	ComparisonPredType cpType = null ;
	ScalarExpressionType seType1 = null ;
	ScalarExpressionType seType2 = null ;
	ScalarExpressionType[] args = null ;
	ComparisonType compType = null ;
}
{
	//  <row_value_constructor> <comp_op> <row_value_constructor>
	( seType1=rowValueConstructor() compType=comparisonOperator() seType2=rowValueConstructor() )
	{ 
		if( seType2 != null ) {
			cpType = ComparisonPredType.Factory.newInstance() ;
			args = new ScalarExpressionType[2] ;
			args[0] = seType1 ;
			args[1] = seType2 ;
			cpType.setArgArray( args ) ;
			cpType.xsetComparison( compType ) ;	
			
		}
		return cpType ; }
}

ComparisonPredType comparisonPredicate_AG() : 
{
	ComparisonPredType cpType = null ;
	ScalarExpressionType seType1 = null ;
	ScalarExpressionType seType2 = null ;
	ScalarExpressionType[] args = null ;
	ComparisonType compType = null ;
}
{
	( seType1=valueExpression() compType=comparisonOperator() seType2=valueExpression() )
	{ 
		if( seType2 != null ) {
			cpType = ComparisonPredType.Factory.newInstance() ;
			args = new ScalarExpressionType[2] ;
			args[0] = seType1 ;
			args[1] = seType2 ;
			cpType.setArgArray( args ) ;
			cpType.xsetComparison( compType ) ;	
			
		}
		return cpType ; }
}


String correlationName() : 
{
	String name = null ;
}
{
	name=identifier()
	{ return name ; }
}

void dateTimeFactor() : {}
{
	dateTimePrimary() [  LOOKAHEAD(2) timeZone() ]
}

void dateTimePrimary() : {}
{
	commonPrimary()
    | 
    dateTimeValueFunction()
}

void dateTimeTerm() : {}
{
    dateTimeFactor()
}

void dateTimeValueExpression() : {}
{
	// refactored
	LOOKAHEAD(3)
    ( dateTimeTerm() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) dateTimeValueExpression() )* )
    |
    ( intervalValueExpression() <PLUS> dateTimeTerm() )
}

void dateTimeValueFunction() : {}
{
	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LPAREN> timePrecision() <RPAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LPAREN> timeStampPrecision() <RPAREN> ]
}

void derivedColumnList() : {}
{
   columnNameList()	
}

void derivedTable() : {}
{
   tableSubQuery()
}

void endField() : {}
{
	<NON_SECOND_DATETIME_FIELD> | <SECOND> [ <LPAREN> intervalFractionalSecondsPrecision() <RPAREN> ]
}

void escapeCharacter() : {}
{
	characterValueExpression()	
}

AtomType exactNumericLiteral() : 
{
	AtomType atomType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{ 
	(
		LOOKAHEAD(3) 
		( t1=<UNSIGNED_INTEGER> [ <DOT> [ t2=<UNSIGNED_INTEGER> ] ] ) 
		| 
		( <DOT> t2=<UNSIGNED_INTEGER> )
	)
	{ 
		if( t1 != null || t2 != null ) {
			atomType = AtomType.Factory.newInstance() ;	
		}
		if( t1 != null && t2 == null ) {
			IntegerType intType = IntegerType.Factory.newInstance() ;
			intType.setValue( new Long( t1.image ).longValue() ) ;
			atomType.setLiteral( intType ) ;
		}
		else if( t1 != null && t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( t1.image + '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}		
		else if( t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}
		return atomType ;
	}
}

SearchType existsPredicate() : 
{
	SearchType st = null ;
}
{
	<EXISTS> st=tableSubQuery()
	{ 
		if( st != null ) {
		}
		
		return st ;	
	}	
}

void explicitTable() : {}
{
	<TABLE> tableName()
}

ScalarExpressionType factor() : 
{
	ScalarExpressionType retType = null ;
	ScalarExpressionType seType = null ;
	UnaryExprType ueType = null ;
}
{
	// ( [ <PLUS> | <MINUS> ] numericPrimary() )
	( ueType=factor_Unary() seType=numericPrimary() )
	{ 
	   if( ueType != null ) {
	   	  ueType.setArg( seType ) ;
	   	  retType = ueType ;
	   }
	   else {
	   	  retType = seType ;
	   }
	   return retType ;
	}
}

UnaryExprType factor_Unary() : 
{
	UnaryExprType ueType = null ;
	Token t = null ;
}
{
	( [ t=<PLUS> | t=<MINUS> ] )
	{ 
	   if( t != null ) {
	   		ueType = UnaryExprType.Factory.newInstance() ;
	   		ueType.setOper( UnaryOperatorType.Enum.forString( t.image ) ) ;	   	
	   }
	   return ueType ;
	}
}

FromType fromClause() : 
{
	FromType fromType = null ;
	FromTableType ftType = null ;
	ArrayList list = new ArrayList() ;
}
{
	( 
		<FROM> ftType=tableReference() { list.add( ftType ) ; } 
		( <COMMA> ftType=tableReference() { list.add( ftType ) ; } )* 
	)
	{
		if( list.size() > 0 ) {
		   fromType = FromType.Factory.newInstance() ;
		   FromTableType[] tableRefArray = new FromTableType[ list.size() ] ;
		   fromType.setTableArray( (FromTableType[])list.toArray(tableRefArray) ) ;				
		}
		return fromType ;
	}
}

AtomType generalLiteral() :
{
	AtomType atomType = null ;	
}
{
//	 <character_string_literal>//   | <national_character_string_literal>//   | <bit_string_literal>//   | <hex_string_literal>//   | <datetime_literal>//   | <interval_literal>

	atomType=characterStringLiteral_AG()
	{ return atomType ; }	
}

AggregateFunctionType generalSetFunction() : 
{
	AggregateFunctionType afType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	// JL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> [ setQuantifier() ] seType=valueExpression() <RPAREN>	
	( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> seType=valueExpression() <RPAREN>
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			argArray[0] = seType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }	
}

ScalarExpressionType generalValueSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	// Foreshortened
	seType=variableSpecification()
	{ return seType ; }	
}

GroupByType groupByClause() : 
{
	GroupByType gbType = null ;
	ArrayList crList = null ;
}
{
	<GROUPBY> crList=groupingColumnReferenceList()
	{
		if(	crList != null ) {
			gbType = GroupByType.Factory.newInstance() ;
			ColumnReferenceType[] colRefArray = new ColumnReferenceType[ crList.size() ] ;
			gbType.setColumnArray( (ColumnReferenceType[])crList.toArray(colRefArray) ) ;	
		}
		return gbType ;
	}
}

ArrayList groupingColumnReferenceList() : 
{
	ArrayList list = null ;
	ColumnReferenceType cr = null ;
}
{
	(
		cr=groupingColumnReference_AG() 
		{ 
			if( list == null )
				list = new ArrayList() ;
			list.add( cr ) ; 
		}
		( <COMMA> cr=groupingColumnReference_AG() { list.add( cr ) ; } )* 
	)
	{ return list ; }
}

ColumnReferenceType groupingColumnReference_AG() : 
{
	ColumnReferenceType cr = null ;
}
{
//  Should be...
//	columnReference() [ collateClause() ]	
	cr=columnReference()	
	{ return cr ; }
}

HavingType havingClause() :
{
	HavingType hType = null ;
	SearchType sType = null ;
	Token t = null ;
}
{	
	( t=<HAVING> sType=searchCondition() )
	{
		if( t != null ) {
			hType = HavingType.Factory.newInstance() ;	
			if( sType != null )
				hType.setCondition( sType ) ;
		}
		return hType ;
	}
}

String identifier() : 
{ String retValue ; }
{
	// Foreshortened
	retValue=actualIdentifier()
	{ return retValue ; }
} 

void inPredicate() : {}
{
	// refactored
	LOOKAHEAD(3)
	rowValueConstructor() [ <NOT> ] <IN> tableSubQuery() | ( <LPAREN> inValueList() <RPAREN> )  
}

void intervalFactor() : {}
{
    [ <PLUS> | <MINUS> ] intervalPrimary()
}

void intervalFractionalSecondsPrecision() : {}
{
	<UNSIGNED_INTEGER>	
}

void intervalLeadingFieldPrecision() : {}
{
	<UNSIGNED_INTEGER>	
}

void intervalPrimary() : {}
{
      commonPrimary() [ LOOKAHEAD(2) intervalQualifier() ]
}

void intervalQualifier() : {}
{
	LOOKAHEAD(3)
    startField() <TO> endField()
    | 
    singleDateTimeField()
}

void intervalTerm() : {}
{
	// refactored
	LOOKAHEAD(3)
	intervalFactor() 
    |
	LOOKAHEAD(3)    
    factor() (<STAR> | <DIVIDE>) intervalTerm()
    | 
    term() <STAR> intervalFactor()
}

void intervalValueExpression() : {}
{
	// refactored
	LOOKAHEAD(3)
	intervalTerm() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) intervalTerm() )*
    | 
    <LPAREN> dateTimeValueExpression() <MINUS> dateTimeTerm() <RPAREN> intervalQualifier()
}

void inValueList() : {}
{
    valueExpression() ( <COMMA> valueExpression() )*		
}

void joinSpecification() : {}
{
	(
		// refactored
		<ON> searchCondition()	    |	    <USING> <LPAREN> columnNameList() <RPAREN>
    )
}

ComparisonPredType joinSpecification_AG() : 
{
	ComparisonPredType cpType = null ;
}
{
	(
		<ON> cpType=comparisonPredicate_AG()
    )
    { return cpType ; }
}

JoinTableType joinedTable() : 
{
	JoinTableType jtType = null ;
	Token t = null ;
}
{
	(
		LOOKAHEAD(3)
		jtType=crossJoin()
		|
		LOOKAHEAD(3)
		jtType=qualifiedJoin()
		|
		( t=<LPAREN> jtType=joinedTable() <RPAREN> )
	)
	{ return jtType ; }
}

JointTableQualifierType joinType() : 
{
	JointTableQualifierType jType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	(
		// refactored
		t1=<INNER>
	    | 
	    ( t1=<LEFT> | t1=<RIGHT> | t1=<FULL> ) [ t2=<OUTER> ] 
// JL. Adql does not appear to support UNION
//	    | //	    t1=<UNION>
    )
    {
    	if( t1 != null ) {
    		jType = JointTableQualifierType.Factory.newInstance() ;
    		 switch ( t1.kind ) {
    			case AdqlStoXConstants.INNER :
      				jType.set( JointTableQualifierType.INNER );
      				break;
      			case AdqlStoXConstants.LEFT :
      				jType.set( JointTableQualifierType.LEFT_OUTER );
      				break;
      			case AdqlStoXConstants.RIGHT :
      				jType.set( JointTableQualifierType.RIGHT_OUTER );
      				break;
      			case AdqlStoXConstants.FULL :
      				jType.set( JointTableQualifierType.FULL_OUTER );
      				break;
//      			case AdqlStoXConstants.UNION ://      				jType.set( JointTableQualifierType.??? );//      				break;
    		}   		
    	}
    	return jType ;
    }
}


void match() : {}
{
	characterValueExpression()	
}

void matchPredicate() : {}
{
	rowValueConstructor() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] tableSubQuery() 
}

MathFunctionType mathFunctions() : 
{
	MathFunctionType mfType = null ; 
	ScalarExpressionType arg1 = null ;
	Token t = null ;
	Token t2 = null ;
}
{
	(
		( t=<CEILING> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<DEGREES> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<EXP> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<FLOOR> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<PI> <LPAREN><RPAREN> )
		|
		( t=<POWER> <LPAREN> arg1=numericValueExpression() <COMMA> t2=<UNSIGNED_INTEGER> <RPAREN> )
		|
		( t=<RADIANS> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<SQRT> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG10> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<RAND> <LPAREN> [ arg1=numericValueExpression() ] <RPAREN> )
		|
		( t=<ROUND> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<TRUNCATE> <LPAREN> arg1=numericValueExpression() <RPAREN> )
	)
	{
	   if( t != null ) {
	   	  mfType = MathFunctionType.Factory.newInstance() ;
	   	  mfType.setName( MathFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
	   	  if( arg1 != null ) {
	   	  	 SelectionItemType[] argArray ;
	   	  	 if( t.kind != AdqlStoXConstants.POWER ) {
	   	        argArray = new SelectionItemType[1] ;
	   	        argArray[0] = arg1 ;
	   	  	 }
	   	  	 else {
	   	  	 	argArray = new SelectionItemType[2] ;
	   	  	 	argArray[0] = arg1 ;
	   	  	 	AtomType atomType = AtomType.Factory.newInstance() ;
	   	  	 	IntegerType intType = IntegerType.Factory.newInstance() ;
	   	  	 	intType.setValue( new Long( t2.image ).longValue() ) ;
	   	  	 	atomType.setLiteral( intType ) ;
	   	  	 	argArray[1] = atomType ;
	   	  	 }
	   	     mfType.setArgArray( argArray ) ;
	   	  }
	   }
	   return mfType ;
	}
}

void nullPredicate() : {}
{
	rowValueConstructor() <IS> [ <NOT> ] <NULL>	
}

ScalarExpressionType numericPrimary() : 
{
	ScalarExpressionType seType = null ;
}
{
	( 
	  seType=numericValueFunction()	
	  |	  seType=commonPrimary()
	)
	{ return seType ; } 
	
}

ScalarExpressionType numericValueExpression() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// term() ( LOOKAHEAD(2) ( <PLUS> | <MINUS> ) numericValueExpression() )*
	seType=term() exprPairs=numericValueExpression_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] numericValueExpression_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;
	Token t = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=numericValueExpression_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] numericValueExpression_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<PLUS> | t=<MINUS> ) seType=numericValueExpression()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;					beType = BinaryExprType.Factory.newInstance() ;			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}

ScalarExpressionType numericValueFunction() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		// JBL ADQL adaptation
		seType=trigFunctions()
		|
		seType=mathFunctions()	
	)
	{ return seType ; }
}

OrderExpressionType orderBy_AG() : 
{
	OrderExpressionType oeType = null ;
	OrderType orderType = null ;
	OrderType[] orderArray = null ;
	ArrayList orderList = null ;
} 
{
	// This seems inadequate. Ie: the use of ScalarExpression in the Xml Schema, and hence valueExpression()
	//<ORDERBY> valueExpression() ( <ASC> | <DESC> ) ( <COMMA> valueExpression() ( <ASC> | <DESC> ) )*
	( <ORDERBY> orderType=orderBy_Singleton() orderList=orderBy_List() )
	{
		if( orderType != null ) {
			oeType = OrderExpressionType.Factory.newInstance() ;
			if( orderList != null ) {
				orderList.add( 0, orderType ) ;	
				orderArray = new OrderType[ orderList.size() ] ;
				orderArray = (OrderType[])orderList.toArray( orderArray ) ;
			}
			else {
				orderArray = new OrderType[1] ;
				orderArray[0] = orderType ;			
			}	
			oeType.setItemArray( orderArray ) ;
		}
		return oeType ;
	}
}

OrderType orderBy_Singleton() : 
{
	OrderType orderType = null ;
	ScalarExpressionType se = null ;
	Token t = null ;
	OrderOptionType optionType = null ;
}
{
	( se=valueExpression() ( t=<ASC> | t=<DESC> ) )
	{
		if( se!=null && t!= null ) {
			optionType = OrderOptionType.Factory.newInstance() ;
			optionType.setDirection( OrderDirectionType.Enum.forString( t.image.toUpperCase() ) ) ;	
			orderType = OrderType.Factory.newInstance() ;
			orderType.setExpression( se ) ;
			orderType.setOrder( optionType ) ;
		}
		return orderType ;
	}
}

ArrayList orderBy_List() : 
{
	ArrayList list = null ;
	OrderType orderType = null ;
}
{
	( 
		<COMMA> 
		orderType=orderBy_Singleton() 
		{
			if( orderType != null ) {
				if( list == null ) {
					list = new ArrayList() ;
				}
				list.add( orderType ) ;	
			}	
		}
	)*
	{ return list ; }
}

void overlapsPredicate() : {}
{
	rowValueConstructor() <OVERLAPS> rowValueConstructor()	
}

void pattern() : {}
{
	characterValueExpression()	
}

SearchType predicate() : 
{
	SearchType searchType = null ;
}
{
	(

 		LOOKAHEAD(4)
		searchType=comparisonPredicate_AG()
	    | 
	    LOOKAHEAD(3)
	    searchType=betweenPredicate_AG()
//	    |//	    inPredicate()//	    |//	    searchType=likePredicate()//	    | 
// adql does not support the null predicate!
//	    LOOKAHEAD(3)//	    nullPredicate()//	    | 
// adql does not support quantified comparisons
//	    LOOKAHEAD(3)//		quantifiedComparisonPredicate()//	    |
// adql does not support EXISTS //	    existsPredicate()//	    | 
// adql does not support UNIQUE//	    uniquePredicate()//	    | 
// adql does not support match
//	    LOOKAHEAD(3)//	    matchPredicate()//	    | 
// adql does not support overlap//	    overlapsPredicate()
    )
    { return searchType ; }
}

JoinTableType qualifiedJoin() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
	JointTableQualifierType jtqType = null ;
	ComparisonPredType cpType = null ;
}
{
	(
		fType1=tableReferenceBarJoinedTable() 
		[ <NATURAL> ] 
		jtqType=joinType() 
		<JOIN> 
		fType2=tableReference() 
		[ LOOKAHEAD(3) cpType=joinSpecification_AG() ]
	)
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	      jtType.xsetQualifier( jtqType ) ;
	      if( cpType != null ) {
	      		jtType.setCondition( cpType ) ;
	      }
	   }
	   return jtType ;	
	}
}

String qualifiedName() : 
{
	String retValue ;
} 
{
	retValue = identifier()
	{ return retValue ; }	
}

String qualifier() : 
{	
	String retValue ;
}
{
	// Foreshortened
	retValue=tableName()
	{ return retValue ; }
}

SelectType query_specification_A() : 
{
	SelectType st = null ;
	ArrayList tableList = null ;
	SelectionListType listType = null ;
	SelectionLimitType limitType = null ;
	SelectionOptionType optionType = null ;
	Token t = null ;
}
{ 
	(
	//S:
	// SELECT [ <set_quantifier> ] <select_list> <table_expression>
	//
		t=<SELECT> 
		[ optionType=set_quantifier_S() ] 
		[ limitType=setLimit() ] 
		listType=selectList() 
		tableList=tableExpression()
	)
	{ 
		if( t != null ) {
			st = SelectType.Factory.newInstance() ;
			if( optionType != null ) {
				st.setAllow( optionType ) ;	
			}
			if( limitType != null ) {
				st.setRestrict( limitType ) ;	
			}
			if( listType != null ) {
				st.setSelectionList( listType ) ;	
			}
			ListIterator iterator = tableList.listIterator() ;
			while( iterator.hasNext() ) {
				Object obj = iterator.next() ;
				if( obj instanceof FromType ) {
					st.setFrom( (FromType)obj ) ;	
				}
				else if( obj instanceof WhereType ) {
					st.setWhere( (WhereType)obj ) ;
				}
				else if( obj instanceof GroupByType ) {
					st.setGroupBy( (GroupByType)obj ) ;
				}
				else if( obj instanceof HavingType ) {
					st.setHaving( (HavingType)obj ) ;	
				}
				else if( obj instanceof OrderExpressionType ) {
					st.setOrderBy( (OrderExpressionType)obj ) ;
				}			
			}			
		}
		return st  ; 
	}
}

void rowSubquery() : {}
{
	subQuery()	
}

ScalarExpressionType rowValueConstructor() : 
{
	ScalarExpressionType seType = null ;
}
{
	// <row_value_constructor_element> 
	// | <left_paren> <row_value_constructor_list> <right_paren>
    // | <row_subquery>
	(
		LOOKAHEAD(3)
		rowValueConstructorElement()
	    | 
	    LOOKAHEAD(2)
	    <LPAREN> rowValueConstructorList() <RPAREN>
	    | 
	    rowSubquery()
	 )
	 { return seType ; }
}

ScalarExpressionType rowValueConstructorElement() : 
{
	ScalarExpressionType seType = null ;
} 
{
	// <value_expression> | <null_specification> | <default_specification>
	// foreshortened...
	seType=valueExpression()
// adql has nothing to support the embedding of keywords...
//    | //    <NULL>//    | //    <SQL_DEFAULT>

	{ return seType ; }
}

void rowValueConstructorList() : {}
{
	rowValueConstructorElement() ( <COMMA> rowValueConstructorElement() ) *
}

void scalarSubquery() : {}
{
	subQuery()
}

SearchType searchCondition() : 
{
	SearchType st=null ;
	SearchType[] stPairs = null ;

}
{
	// refactored
	// ( booleanTerm() ( <OR> booleanTerm() )* )
	( st=booleanTerm() stPairs=booleanTerm_List() )
	{
		if( stPairs == null ) {
		   return st ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st ;
		   conditionArray[1] = stPairs[1] ;
		   UnionSearchType usType = (UnionSearchType)stPairs[0] ;
		   usType.setConditionArray( conditionArray ) ;
		   return usType ;
		}	
	}
}

SearchType[] booleanTerm_List() : 
{
	ArrayList list = null ;
	SearchType[] stPairs1 = null ;
	SearchType[] stPairs2 = null ;
	SearchType[] retPairs = null ;	
}
{
	( stPairs1=booleanTerm_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( stPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retPairs = stPairs1 = (SearchType[])iterator.next() ;
			SearchType[] conditions = new SearchType[2] ;
			UnionSearchType usType = null ;
			while( iterator.hasNext() ) {
				stPairs2 = (SearchType[])iterator.next() ;
				conditions[0] = stPairs1[1] ;
				conditions[1] = stPairs2[1] ;
				usType = (UnionSearchType)stPairs2[0] ;
				usType.setConditionArray( conditions ) ;
				stPairs1 = stPairs2 ;
			}
		}		
		return retPairs ;
	}
}

SearchType[] booleanTerm_Singleton() :
{
	SearchType[] retPairs = null ;
	UnionSearchType us = null ;
	SearchType st = null ;
}
{
	( <OR> st=booleanTerm() )
	{
		if( st != null ) {
			retPairs = new SearchType[2] ;		
			us = UnionSearchType.Factory.newInstance() ;
			retPairs[0] = us ;
			retPairs[1] = st ;
		}
		return retPairs ;
	}
}

SelectionListType selectList() : 
{
	ArrayList itemList = new ArrayList() ;
	SelectionListType slType = SelectionListType.Factory.newInstance() ;
}
{
	(
		allSelectionItem( itemList ) 
		| 
		( selectSublist( itemList ) ( <COMMA> selectSublist( itemList ) )* )
	)
	{
		if( itemList.size() > 0 ) {
			SelectionItemType[] itemArray = new SelectionItemType[ itemList.size() ] ;	
			slType.setItemArray( (SelectionItemType[])itemList.toArray(itemArray) ) ;
		}
		return slType ;	
	}
}

void allSelectionItem( ArrayList itemList ) : {}
{
	<STAR>
	{ itemList.add( AllSelectionItemType.Factory.newInstance() ) ; }
}

void selectSublist( ArrayList itemList ) : 
{ 
	SelectionItemType siType = null ;
}
{   
	LOOKAHEAD(3)
	selectSublist_Qualifier() 
	|
	siType=selectSublist_ValueExpression()
	{ itemList.add( siType ) ; }		
}

String selectSublist_Qualifier() : 
{
	String retValue ;
}
{
	// NOTE. someTable.* is not currently within the adql/x schema!
	retValue=qualifier() <DOT> <STAR> 
	{ return retValue + ".*" ;}
}


SelectionItemType selectSublist_ValueExpression() : 
{
	ScalarExpressionType seType = null ;
	String aliasName = null ;
}
{
	( seType=valueExpression() [ [<AS>] aliasName=columnName() ] )	
	{ 
		if( aliasName != null ) {
			AliasSelectionItemType asiType = AliasSelectionItemType.Factory.newInstance() ;
			asiType.setAs( aliasName ) ;
			asiType.setExpression( seType ) ;
			return asiType ;	
		}
		return seType ; 
	}	
}

AggregateFunctionType setFunctionSpecification() : 
{
	AggregateFunctionType afType = null ;
	Token t = null ;
}
{
	(
		LOOKAHEAD(3)
		( t=<COUNT> <LPAREN> <STAR> <RPAREN> ) 
		|
		afType=generalSetFunction()
	)
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.COUNT ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			AtomType atomType = AtomType.Factory.newInstance() ;
			StringType star = StringType.Factory.newInstance() ;
			star.setValue( "*" ) ;
			atomType.setLiteral( star ) ;
			argArray[0] = atomType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }
}

SelectionLimitType setLimit() : 
{ 
	SelectionLimitType sl = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	<TOP> <LPAREN> t1=<UNSIGNED_INTEGER> t2=<RPAREN>
	{ 
		if( t2 != null ) {
			sl = SelectionLimitType.Factory.newInstance() ;
			sl.setTop( ( new Integer( t1.image )).intValue() ) ;
		}
	return sl ;	
	}
}

SelectionOptionType set_quantifier_S() : 
{
	SelectionOptionType selectionOption = null ;
	Token t ;
}
{
	//S:
	// DISTINCT | ALL
	//
	t=<ALL> | t=<DISTINCT>
	{ 	
		if( t != null ) {
			selectionOption = SelectionOptionType.Factory.newInstance() ;
			if( t.kind == AdqlStoXConstants.ALL ) {
				selectionOption.setOption( AllOrDistinctType.ALL ) ;
			}
			else {
				selectionOption.setOption( AllOrDistinctType.DISTINCT ) ;
			}
		}
		return selectionOption ;
	}
}

void singleDateTimeField() : {}
{
	<NON_SECOND_DATETIME_FIELD> [ <LPAREN> intervalLeadingFieldPrecision() <RPAREN> ]
    | 
    <SECOND> [ <LPAREN> intervalLeadingFieldPrecision() [ <COMMA> intervalFractionalSecondsPrecision() ] <RPAREN> ]
}

void startField() : {}
{
    <NON_SECOND_DATETIME_FIELD> [ <LPAREN> intervalLeadingFieldPrecision() <RPAREN> ]
}

ScalarExpressionType stringValueExpression() :
{
	ScalarExpressionType seType = null ;
}
{
	// <character_value_expression>
    // | <bit_value_expression>
    
	// Foreshortened
	seType=characterValueExpression()
	{ return seType ; }
}

SearchType subQuery() : 
{
	SearchType st = null ;
}
{
	<LPAREN> queryExpression() <RPAREN>
	{ return st ; }		
}

SearchType subQuery_AG() : 
{
	SearchType st = null ;
}
{
	<LPAREN> queryExpression() <RPAREN>
	{ return st ; }		
}

void quantifiedComparisonPredicate() : {}
{
	rowValueConstructor() comparisonOperator() quantifier() tableSubQuery()	
}

void quantifier() : {}
{
	<ALL> | ( <SOME> | <ANY> )	
}

void queryExpression() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryExpression()
	|
	joinedTable()
}

void queryPrimary() : {}
{
    LOOKAHEAD(3)
 	nonJoinQueryPrimary()
    | 
    joinedTable()
}


void queryTerm() : {}
{
	LOOKAHEAD(2)
	nonJoinQueryTerm()
	|
	joinedTable()	
}

void correspondingSpec() : {}
{
	<CORRESPONDING> [ <BY> <LPAREN> correspondingColumnList() <RPAREN> ] 
}
    
void correspondingColumnList() : {}
{
	columnNameList()	
}

JoinTableType crossJoin() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	( fType1=tableReferenceBarJoinedTable() <CROSS_JOIN> fType2=tableReference() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JointTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   return jtType ;	
	}
}


void nonJoinQueryExpression() : {}
{
// Originally ...
//	nonJoinQueryTerm()//	|//	queryExpression() <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm()//	|//	queryExpression() <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm()

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	
//	LOOKAHEAD(3)//	queryTerm() ( <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	LOOKAHEAD(3)//	queryTerm() ( <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	nonJoinQueryTerm()

	LOOKAHEAD(4)
	queryTerm() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ correspondingSpec() ] queryTerm() )*
	|
	nonJoinQueryTerm()
}

void nonJoinQueryTerm() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryPrimary()
	|
	queryPrimary() <INTERSECT> [ <ALL> ] [ correspondingSpec() ] queryPrimary()	
}

void nonJoinQueryPrimary() : {}
{
	simpleTable()
	|
	<LPAREN> nonJoinQueryExpression() <RPAREN>
}

void simpleTable() : {}
{
	query_specification_A()
	|
	tableValueConstructor()
	|
	explicitTable()	
}

ArrayList tableExpression() : 
{
	ArrayList list = new ArrayList() ;
	Object obj = null ;
} 
{
	(
		obj=fromClause() { if( obj!=null ) list.add(obj) ; } 
		[ obj=whereClause() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=groupByClause() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=havingClause() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=orderBy_AG() { if( obj!=null ) list.add(obj) ; } ]	
	)
	{ return list ;	}
}

String tableName() : 
{
	String retValue = null ;
}
{
	// Forshortened
	retValue=qualifiedName()
	{ return retValue ; }
}

FromTableType tableReference() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
} 
{
	(
		// refactored... 
		// 1. derivedTable() moved to first choice point
		// 2. joinedTable() moved to second choice point
//	    LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName() [ <LPAREN> derivedColumnList() <RPAREN> ]//	    |	//		LOOKAHEAD(4)//	    joinedTable()//	    |//		tableName() [ [ <AS> ] correlationName() [ <LPAREN> derivedColumnList() <RPAREN> ] ]    

		// Foreshortened. 
		// derivedColumnList not supported in adql
		// derivedTable not supported in adql
//		LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName()//	    |	
		LOOKAHEAD(4)
	    ftType=joinedTable()
	    |
		( tName=tableName() [ [ <AS> ] cName=correlationName() ] )
		{
			if( tName != null ) {	
				TableType tableType = TableType.Factory.newInstance() ;
				tableType.setName( tName ) ;
				if( cName != null )
					tableType.setAlias( cName ) ;
				ftType = tableType ;
			}
		} 
	)
	{ return ftType ; } 
}

// Adaptation of tableReference()
FromTableType tableReferenceBarJoinedTable() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
}
{
	( tName=tableName() [ [ <AS> ] cName=correlationName() ] )
	{
		if( tName != null ) {	
			TableType tableType = TableType.Factory.newInstance() ;
			tableType.setName( tName ) ;
			if( cName != null )
				tableType.setAlias( cName ) ;
			ftType = tableType ;
		}
	}
	{ return ftType ; }
}

SearchType tableSubQuery() : 
{
	SearchType st = null ;
}
{
	st=subQuery()	
	{ return st ; }
}

void tableValueConstructor() : {}
{
	<VALUES> tableValueConstructorList()
}

void tableValueConstructorList() : {}
{
	rowValueConstructor() ( <COMMA> rowValueConstructor() )*	
}

//ScalarExpressionType term() : //{//	ScalarExpressionType seType = null ;//}//{//	// refactored//	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*//	factor() term_List() //	{ return seType ; }//}

ScalarExpressionType term() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*
	seType=factor() exprPairs=term_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] term_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=term_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] term_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<STAR> | t=<DIVIDE> ) seType=term()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;		
			beType = BinaryExprType.Factory.newInstance() ;
			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}




void timeFractionalSecondsPrecision() : {}
{
	<UNSIGNED_INTEGER> 	
}

void timePrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeStampPrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeZone() : {}
{
	// refactored
    <AT> ( <LOCAL> | (<TIME_ZONE> intervalValueExpression() ) ) 
}

TrigonometricFunctionType trigFunctions() : 
{
	TrigonometricFunctionType tfType = null ; 
	ScalarExpressionType arg1 = null ;
	ScalarExpressionType arg2 = null ;
	Token t = null ;
}
{
	(
		t=<ACOS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ASIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN2> <LPAREN> arg1=numericValueExpression() <COMMA> arg2=numericValueExpression() <RPAREN>
		|
		t=<COS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<COT> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<SIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<TAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
	)
	{
		if( t != null ) {
			ScalarExpressionType[] argArray = null ;
			tfType = TrigonometricFunctionType.Factory.newInstance() ;
			tfType.setName( TrigonometricFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			if( arg2 != null ) {
				argArray = new ScalarExpressionType[2] ;
				argArray[0] = arg1 ;
				argArray[1] = arg2 ;
			}
			else {
				argArray = new ScalarExpressionType[1] ;
				argArray[0] = arg1 ;
			}
			tfType.setArgArray( argArray ) ;
		}
		return tfType ;
	}
}

void uniquePredicate() : {}
{
	<UNIQUE> tableSubQuery()	
}

AtomType unsignedLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
		// foreshortened
	    atomType=unsignedNumericLiteral()
		| 		atomType=generalLiteral()
	)
	{ return atomType ; }
}

AtomType unsignedNumericLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
// JL. Note the adql/x schema does not possess an approximateNumericLiteral
//		LOOKAHEAD(3)//		exactNumericLiteral()//	    | //	    approximateNumericLiteral()

		atomType=exactNumericLiteral()
    )
    { return atomType ; }
}


ScalarExpressionType unsignedValueSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		seType=unsignedLiteral()
		|
		generalValueSpecification()
	)
	{ return seType ;  }
}

ScalarExpressionType valueExpression() : 
{
	ScalarExpressionType retValue = null ;
} 
{
	// <numeric_value_expression>
    // | <string_value_expression>
    // | <datetime_value_expression>
    // | <interval_value_expression>
	(
	LOOKAHEAD(3) 
	retValue=numericValueExpression() 
	|
	LOOKAHEAD(3) 	
	retValue=stringValueExpression() 
	// JL. foreshortened. At present there seems no accommodation for
	// datetime and interval expressions in adql
//	|//	LOOKAHEAD(3) //	dateTimeValueExpression() //	|//	intervalValueExpression()
	)
	{ return retValue ; }
	
}

ScalarExpressionType variableSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	// JBL ADQL adaptation to accommodate scripting variables.
	// Details still to be worked out.
	<DOLLAR> <LBRACE> <REGULAR_IDENTIFIER> <RBRACE>
	{ return seType ; }
}

WhereType whereClause()        : 
{/*@bgen(jjtree) Where */
        ASTWhere jjtn000 = new ASTWhere(this, JJTWHERE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	WhereType whereType = null ;
	SearchType s = null ;
	Token t = null ;
}
{/*@bgen(jjtree) Where */
        try {
/*@egen*/
	t=<WHERE>	s=searchCondition()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ 
		if( t != null )
			whereType = WhereType.Factory.newInstance() ;
		if( s != null ) {
			whereType.setCondition( s ) ;
		}
		jjtn000.searchType = s ; 
	  	return whereType ;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



