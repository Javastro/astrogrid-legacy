/*@bgen(jjtree) Generated By: AdqlStoX.jjt,v 1.32.2.3 2006/11/27 16&JJTree: Do not edit this line. ./AdqlStoX.jj */
/*@egen*//*$Id: AdqlStoX.jj,v 1.22 2006/11/27 18:05:47 jl99 Exp $*/
/**
 * AdqlStoX JavaCC file          
 *
 * This version, with file extension of .jjt, produces a syntax tree.
 * At present the syntax tree is not used, but will be.
 *
 * AdqlStoX takes text in the form of Adql/s and compiles it to xml Adql/x format.
 * Adql/s is based upon SQL/92 with astronomical extensions.
 *
 * There is a naming convention for methods, which is aimed at making the structure
 * as clear as possible...
 *
 * (1) All methods which are quoted bnf statements follow the bnf format, 
 *     with any embedded dashes (-) removed from the name.
 *     Thus the the statment <comparison_predicate> from the SQL/92 standard
 *     will have a corresponding method with a name similar to comparison_predicate().
 *     However, such methods are decorated in a particular way, for which see
 *     points (2) and (3) below. All methods which are tantamount to quoted
 *     bnf will have the standard syntax as a comment embedded within them.
 *     Thus:
 *     //S: 
 *     // <row_value_constructor> <comp_op> <row_value_constructor>
 * (2) Methods which follow exactly the SQL/92 syntax at a shallow level are suffixed _S.
 *     Thus comparison_predicate_S() represents the SQL/92 standard syntax. Shallow implies
 *     that the syntax can still vary from the standard within statements quoted
 *     within the given construct. This is usually pretty obvious from the quoted statements
 *     (eg: quoted statement some_statement_A() means an ADQL variation, see next point), 
 *     but beware that it is possible for variations to be deeply embedded.
 *     NB: A statement that is just a synonym for another statement will take
 *         the quoted statement's decoration. This is the one exception.
 * (3) Methods which are varied for some reason within ADQL, or are simply
 *     specific to ADQL, are suffixed _A.
 *     Thus comparison_predicate_A() represents an ADQL deviation.
 * (4) Some methods are introduced as implementations of part of a syntax.
 *     This is just to make for a neater structure. These methods follow
 *     the standard Java OO naming convention and are not decorated, 
 *     eg: numericValueExpressionList().
 *
 * There is built-in documentation to help in supporting BNF syntax diagrams. This built-in
 * documentation consists of special comments throughout the code. It is separate from the
 * above four conventions and must be maintained by the developer to correspond to the working
 * of the compiler. Thus the resulting BNF documentation represents what the compiler does. 
 * This seems a little back-to-front but is reasonably thorough in its results. There are two 
 * sorts of comments: singletons and multiples, depending on whether the BNF definition is on 
 * one or more lines. Two examples are given below:
 *
 *     bnf-single <boolean_factor> ::= [ NOT ] <boolean_test>
 *     bnf-start
 *        <between_predicate> ::=
 *          <value_expression> [ NOT ] BETWEEN
 *          <value_expression> AND <value_expression>
 *     bnf-end
 *
 * (Real ones have to be positioned at the beginning of a line with each line prefixed by
 * the string " * " exactly. )
 * 
 * A utility programme BnfExtractor extracts these from the source and places them in 
 * suitable files (or to standard out). BnfExtractor produces output in two formats:
 * plain text and html. 
 *
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Sep 2006
 */
 
options {
  JDK_VERSION = "1.4";
  STATIC=false;                                                                                  
  IGNORE_CASE=true;
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;
import java.util.* ;
import org.apache.xmlbeans.XmlOptions ;
import org.astrogrid.adql.v1_0.beans.* ;
import org.astrogrid.stc.region.v1_10.beans.* ;
import org.astrogrid.stc.coords.v1_10.beans.* ;
import org.w3c.dom.Node ;
import org.apache.xmlbeans.SchemaProperty;
import org.apache.xmlbeans.SchemaType;
import org.apache.xmlbeans.SimpleValue;
import org.apache.xmlbeans.XmlAnySimpleType;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.XmlString;
import org.apache.xmlbeans.XmlCursor;

public class AdqlStoX/*@bgen(jjtree)*/implements AdqlStoXTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTAdqlStoXState jjtree = new JJTAdqlStoXState();

/*@egen*/
	
	private static Log log = LogFactory.getLog( AdqlStoX.class ) ;
	
	private static final boolean TRACE_ENABLED = true ;
	private static final boolean DEBUG_ENABLED = true ;
	private static StringBuffer logIndent ;
	static {
		if( DEBUG_ENABLED | TRACE_ENABLED ) {
			logIndent = new StringBuffer() ;
		}
	}	
	
	private static final int CHANGE_SIGN = -1 ;
	private static final int DONT_CHANGE_SIGN = 1 ;
	public static final String TABLE_TYPE = "tableType" ;
	public static final String COLUMN_REFERENCE_TYPE = "columnReferenceType" ;
	public static final String ALIAS_SELECTION_ITEM_TYPE = "aliasSelectionItemType" ;	
	public static final String DUPLICATE_TABLE_ALIAS =
	     "Query contains at least one duplicated table alias: " ;
	public static final String TABLE_ALIAS_CLASH =
	     "Query contains alias with same name as a table: " ;
	public static final String NONEXISTENT_ALIAS =
	     "Query contains a column reference with unknown table or table alias: " ;
	public static final String DUPLICATE_EXPRESSION_ALIAS =
	     "Query contains at least one duplicated expression alias: " ;
	public static final String UNRECOGNIZED_FRAGMENT =
	     "Unrecognized fragment of ADQL." ;
	private SelectDocument selectDoc ;
	private String lastMessage ;

	public SelectDocument exec() throws ParseException {
		try {
			return select_document_A() ;
		}
		catch ( ParseException pex ) {
			lastMessage = pex.getLocalizedMessage() ;
			if( logIndent.length() > 0 )
		    	logIndent.delete( 0, logIndent.length()-1 ) ;
		    throw pex ;	
		}
	}
	
	public SelectDocument compileToXmlBeans() throws ParseException {
		return exec() ;
	}
	
	public String compileToXmlText( boolean prettyPrint ) throws ParseException {
		XmlOptions opts = new XmlOptions();
		opts.setSaveOuter() ;
		if( prettyPrint ) {		
		   opts.setSaveAggressiveNamespaces() ;
		   opts.setSavePrettyPrint() ;
		   opts.setSavePrettyPrintIndent(4) ;
		}
		return exec().xmlText(opts) ; 
	}
	
	public String compileToXmlText() throws ParseException {
		return compileToXmlText( true ) ;
	}
	
	public Node compileToXmlDom() throws ParseException {
		return exec().getDomNode() ;
	}
	
	public String compileFragmentToXmlText( String path, boolean prettyPrint ) throws ParseException {
		XmlOptions opts = new XmlOptions();
	    opts.setSaveOuter() ;
		if( prettyPrint ) {
		   opts.setSaveAggressiveNamespaces() ;
		   opts.setSavePrettyPrint() ;
		   opts.setSavePrettyPrintIndent(4) ;
		}
		return execFragment( path ).xmlText(opts) ; 
	}
	
	public String compileFragmentToXmlText( String path ) throws ParseException {
		return compileFragmentToXmlText( path, true ) ; 
	}
	
	public XmlObject compileFragmentToXmlBean( String path ) throws ParseException {
		return execFragment( path ) ;
	}
	
	public XmlObject execFragment( String path ) throws ParseException {
		String[] segs = path.toUpperCase().split( "/" ) ;
		String child = segs[ segs.length-1 ] ;
		String parent = null ;
		if( segs.length > 2 ) {
			parent = segs[ segs.length-2 ] ;	
		}
		XmlObject xmlObject = null ;
		if( child.equals( "SELECT" ) ) {
			xmlObject = query_specification_fragment() ;
		}
		else if( child.equals( "ALLOW" ) ) {
			xmlObject = set_quantifier_fragment() ;
		}
		else if( child.equals( "RESTRICT" ) ) {
			xmlObject = set_limit_fragment() ;
		}
		else if( child.equals( "SELECTIONLIST" ) ) {
			xmlObject = select_list_fragment() ;
		}
		else if( child.equals( "FROM" ) ) {
			xmlObject = from_clause_fragment() ;
		}
		else if( child.equals( "WHERE" ) ) {
			xmlObject = where_clause_fragment() ;
		}
		else if( child.equals( "GROUPBY" ) ) {
			xmlObject = group_by_clause_fragment() ;
		}
		else if( child.equals( "HAVING" ) ) {
			xmlObject = having_clause_fragment() ;
		}
		else if( child.equals( "ORDERBY" ) ) {
			xmlObject = order_by_clause_fragment() ;
		}
		else {
		    throw new ParseException( UNRECOGNIZED_FRAGMENT ) ;
		}
		return xmlObject ;
	}
	
	public String getLongLastMessage() {
		return lastMessage ;	
	}
	
	public String getShortLastMessage() {
		int i = lastMessage.indexOf( '\n' ) ;
		if( i == -1 )
		  return lastMessage ;
		return lastMessage.substring( 0, i ) ;	
	}
	
    /**
     * Crude check of table aliases and column references
     */
	private void checkTableAliases() throws ParseException {
		HashSet tRefs = getTableReferences() ;
        XmlObject element ;
        XmlCursor cursor = selectDoc.newCursor() ;
        cursor.toFirstChild() ; // There has to be a first child!
        do {
           if( cursor.isStart() ) {
              element = cursor.getObject() ;
              if( element.schemaType().getName().getLocalPart().equals( COLUMN_REFERENCE_TYPE ) ) {
              	  ColumnReferenceType col = (ColumnReferenceType)element ;
                  if( !tRefs.contains( col.getTable() ) ) {
                  	 String message = NONEXISTENT_ALIAS + col.getTable() + '.' + col.getName() ;
                  	 throw new ParseException( message ) ;
                  }
              }                       
           }                 
        } while( cursor.toNextToken() != XmlCursor.TokenType.NONE ) ;
        cursor.dispose() ;
	}
	
	private HashSet getTableReferences() throws ParseException {
		HashSet tables = new HashSet() ;
		HashSet aliases = new HashSet() ;
        TableType tType = null ;
        String alias = null ;
        //
        // Loop through the whole of the query looking for basic table refs....
        XmlCursor cursor = selectDoc.newCursor() ;
        while( !cursor.toNextToken().isNone() ) {
            if( cursor.isStart()  
                && 
                ( cursor.getObject().schemaType().getName().getLocalPart().equals( TABLE_TYPE ) )
            ) {
            	tType = (TableType)cursor.getObject() ;
            	tables.add( tType.getName() ) ;               
                alias = tType.getAlias() ;
                if( alias != null ) {
                    if( !aliases.add( alias ) ) {
                	    String message = DUPLICATE_TABLE_ALIAS 
                	                   + tType.getAlias() ;
                	    throw new ParseException( message ) ;
                    }
                }
            }
        } // end while
        cursor.dispose();
        //
        // Check for aliases with the same name as a table...
        Iterator it = aliases.iterator() ;
        while( it.hasNext() ) {
        	String aName = (String)it.next() ;
        	if( tables.contains( aName ) ) {
        		String message = TABLE_ALIAS_CLASH + aName  ;
                throw new ParseException( message ) ;
        	}
        }
        tables.addAll( aliases ) ;
        return tables ;
	}
	
    /**
     * Crude check of expression aliases.
     * In the absence of metadata for columns, the best that can be accomplished
     * is to check for duplicates. 
     */
	private void checkExpressionAliases() throws ParseException {
		HashSet aliases = new HashSet() ;
        AliasSelectionItemType aType = null ;
        String alias = null ;
        //
        // Loop through the whole of the query looking for AliasSelectionItemTypes....
        XmlCursor cursor = selectDoc.newCursor() ;
        while( !cursor.toNextToken().isNone() ) {
            if( cursor.isStart()  
                && 
                ( cursor.getObject().schemaType().getName().getLocalPart().equals( ALIAS_SELECTION_ITEM_TYPE ) )
            ) {
            	aType = (AliasSelectionItemType)cursor.getObject() ;
            	alias = aType.getAs() ;
                if( alias != null ) {
                    if( !aliases.add( alias ) ) {
                	    String message = DUPLICATE_EXPRESSION_ALIAS 
                	                   + alias ;
                	    throw new ParseException( message ) ;
                    }
                }
            }
        } // end while
        cursor.dispose();	
	}
	
	private void enterTrace( String entry ) {
		log.debug( logIndent.toString() + "enter: " + entry ) ;
		indentPlus() ;
	}

    private void exitTrace( String entry ) {
    	indentMinus() ;
		log.debug( logIndent.toString() + "exit : " + entry ) ;
	}
	
	private static void indentPlus() {
		logIndent.append( ' ' ) ;
	}
	
	private static void indentMinus() {
		logIndent.deleteCharAt( logIndent.length()-1 ) ;
	}
	
}
PARSER_END(AdqlStoX)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

/**
 * TOKEN <SQL_special_character> 
 *
 * bnf-start
 *  <SQL_special_character> ::=
 *     <space>
 *   | <double_quote>
 *   | <percent>
 *   | <ampersand>
 *   | <quote>
 *   | <left_paren>
 *   | <right_paren>
 *   | <asterisk>
 *   | <plus_sign>
 *   | <comma>
 *   | <minus_sign>
 *   | <period>
 *   | <solidus>
 *   | <colon>
 *   | <semicolon>
 *   | <less_than_operator>
 *   | <equals_operator>
 *   | <greater_than_operator>
 *   | <question_mark>
 *   | <underscore>
 *   | <vertical_bar>
 * bnf-end
 * bnf-start
 *  <space> ::=
 *  !! Imagine there is a space character here
 * bnf-end
 * bnf-single <double_quote> ::= "
 * bnf-single <percent> ::= %
 * bnf-single <ampersand> ::= &
 * bnf-single <quote> ::= '
 * bnf-single <left_paren> ::= (
 * bnf-single <right_paren> ::= )
 * bnf-single <asterisk> ::= *
 * bnf-single <plus_sign> ::= +
 * bnf-single <comma> ::= ,
 * bnf-single <minus_sign> ::= -
 * bnf-single <period> ::= .
 * bnf-single <solidus> ::= /
 * bnf-single <colon> ::= :
 * bnf-single <semicolon> ::= ;
 * bnf-single <less_than_operator> ::= <
 * bnf-single <equals_operator> ::= =
 * bnf-single <greater_than_operator> ::= >
 * bnf-single <question_mark> ::= ?
 * bnf-single <underscore> ::= _
 * bnf-single <vertical_bar> ::= |
 */
TOKEN : // <SQL_special_character> 
{
  < DOUBLE_QUOTE: "\"\"" >
| < PERCENT: "%" >
| < AMPERSAND: "&" >
| < QUOTE: "'" >
| < LEFT_PAREN: "(" >
| < RIGHT_PAREN: ")" >
| < ASTERISK: "*" >
| < PLUS_SIGN: "+" >
| < COMMA: "," >
| < MINUS_SIGN: "-" >
| < PERIOD: "." >
| < SOLIDUS: "/" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < LESS_THAN_OPERATOR : "<" >
| < EQUALS_OPERATOR : "=" >
| < GREATER_THEN_OPERATOR : ">" >
| < QUESTION_MARK: "?" >
| < UNDERSCORE: "_" >
| < VERTICAL_BAR: "|" >
}

/**
 * TOKEN <SQL_embedded_language_character>
 *
 * bnf-start
 *  <SQL_embedded_language_character> ::=
 *      <left_bracket>
 *    | <right_bracket>
 * bnf-end
 * bnf-single <left_bracket> ::= [
 * bnf-single <right_bracket> ::= ]
 *
 */
TOKEN : // <SQL_embedded_language_character>
{
  < LEFT_BRACKET: "[" >
| < RIGHT_BRACKET: "]" >	
}

/**
 * TOKEN <reserved_word>
 *
 * bnf-start
 *  <reserved_word> ::=
 *     ABSOLUTE | ACTION | ADD | ALL
 *   | ALLOCATE | ALTER | AND
 *   | ANY | ARE
 *   | AS | ASC
 *   | ASSERTION | AT
 *   | AUTHORIZATION | AVG
 *   | BEGIN | BETWEEN | BIT | BIT_LENGTH
 *   | BOTH | BY
 *   | CASCADE | CASCADED | CASE | CAST
 *   | CATALOG
 *   | CHAR | CHARACTER | CHAR_LENGTH
 *   | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE
 *   | COLLATE | COLLATION
 *   | COLUMN | COMMIT
 *   | CONNECT
 *   | CONNECTION | CONSTRAINT
 *   | CONSTRAINTS | CONTINUE
 *   | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS
 *   | CURRENT
 *   | CURRENT_DATE | CURRENT_TIME
 *   | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
 *   | DATE | DAY | DEALLOCATE | DEC
 *   | DECIMAL | DECLARE | DEFAULT | DEFERRABLE
 *   | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR
 *   | DIAGNOSTICS
 *   | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
 *   | ELSE | END | END-EXEC | ESCAPE
 *   | EXCEPT | EXCEPTION
 *   | EXEC | EXECUTE | EXISTS
 *   | EXTERNAL | EXTRACT
 *   | FALSE | FETCH | FIRST | FLOAT | FOR
 *   | FOREIGN | FOUND | FROM | FULL
 *   | GET | GLOBAL | GO | GOTO
 *   | GRANT | GROUP
 *   | HAVING | HOUR
 *   | IDENTITY | IMMEDIATE | IN | INDICATOR
 *   | INITIALLY | INNER | INPUT
 *   | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT
 *   | INTERVAL | INTO | IS
 *   | ISOLATION
 *   | JOIN
 *   | KEY
 *   | LANGUAGE | LAST | LEADING | LEFT
 *   | LEVEL | LIKE | LOCAL | LOWER
 *   | MATCH | MAX | MIN | MINUTE | MODULE
 *   | MONTH
 *   | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO
 *   | NOT | NULL
 *   | NULLIF | NUMERIC
 *   | OCTET_LENGTH | OF
 *   | ON | ONLY | OPEN | OPTION | OR
 *   | ORDER | OUTER
 *   | OUTPUT | OVERLAPS
 *   | PAD | PARTIAL | POSITION | PRECISION | PREPARE
 *   | PRESERVE | PRIMARY
 *   | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
 *   | READ | REAL | REFERENCES | RELATIVE | RESTRICT
 *   | REVOKE | RIGHT
 *   | ROLLBACK | ROWS
 *   | SCHEMA | SCROLL | SECOND | SECTION
 *   | SELECT
 *   | SESSION | SESSION_USER | SET
 *   | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE
 *   | SQLERROR | SQLSTATE
 *   | SUBSTRING | SUM | SYSTEM_USER
 *   | TABLE | TEMPORARY
 *   | THEN | TIME | TIMESTAMP
 *   | TIMEZONE_HOUR | TIMEZONE_MINUTE
 *   | TO | TRAILING | TRANSACTION
 *   | TRANSLATE | TRANSLATION | TRIM | TRUE
 *   | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE
 *   | USER | USING
 *   | VALUE | VALUES | VARCHAR | VARYING | VIEW
 *   | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
 *   | YEAR
 *   | ZONE
 * bnf-end
 */
TOKEN : // <reserved_word>
{
  < ABSOLUTE : "absolute" >
| < ACTION : "action" >
| < ADD : "add" >
| < ALL : "all" >
| < ALLOCATE : "allocate" >
| < ALTER : "alter" >
| < AND : "and" >
| < ANY : "any" >
| < ARE : "are" >
| < AS : "as" >
| < ASC : "asc" >
| < ASSERTION : "assertion" >
| < AT : "at" >
| < AUTHORIZATION : "authorization" >
| < AVG : "avg" >
| < BEGIN : "begin" >
| < BETWEEN : "between" >
| < BIT : "bit" >
| < BIT_LENGTH : "bit_length" >
| < BOTH : "both" >
| < BY : "by" >
| < CASCADE : "cascade" >
| < CASCADED : "cascaded" >
| < CASE : "case" >
| < CAST : "cast" >
| < CATALOG : "catalog" >
| < CHAR : "char" >
| < CHARACTER : "character" >
| < CHAR_LENGTH : "char_length" >
| < CHARACTER_LENGTH : "character_length" >
| < CHECK : "check" >
| < CLOSE : "close" >
| < COALESCE : "coalesce" >
| < COLLATE : "collate" >
| < COLLATION : "collation" >
| < COLUMN : "column" >
| < COMMIT : "commit" >
| < CONNECT : "connect" >
| < CONNECTION : "connection" >
| < CONSTRAINT : "constraint" >
| < CONSTRAINTS : "constraints" >
| < CONTINUE : "continue" >
| < CONVERT : "convert" >
| < CORRESPONDING : "corresponding" >
| < COUNT : "count" >
| < CREATE : "create" >
| < CROSS : "cross" >
| < CURRENT : "current" >
| < CURRENT_DATE : "current_date" >
| < CURRENT_TIME : "current_time" >
| < CURRENT_TIMESTAMP : "current_timestamp" >
| < CURRENT_USER : "current_user" >
| < CURSOR : "cursor" >
| < DATE : "date" >
| < DAY : "day" >
| < DEALLOCATE : "deallocate" >
| < DEC : "dec" >
| < DECIMAL : "decimal" >
| < DECLARE : "declare" >
| < SQL_DEFAULT : "default" >
| < DEFERRABLE : "deferrable" >
| < DEFERRED : "deferred" >
| < DELETE : "delete" >
| < DESC : "desc" >
| < DESCRIBE : "describe" >
| < DESCRIPTOR : "descriptor" >
| < DIAGNOSTICS : "diagnostics" >
| < DISCONNECT : "disconnect" >
| < DISTINCT : "distinct" >
| < DOMAIN : "domain" >
| < DOUBLE : "double" >
| < DROP : "drop" >
| < ELSE : "else" >
| < END : "end" >
| < ENDEXEC : "end-exec" >
| < ESCAPE : "escape" >
| < EXCEPT : "except" >
| < EXCEPTION : "exception" >
| < EXEC : "exec" >
| < EXECUTE : "execute" >
| < EXISTS : "exists" >
| < EXTERNAL : "external" >
| < EXTRACT : "extract" >
| < FALSE : "false" >
| < FETCH : "fetch" >
| < FIRST : "first" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FOREIGN : "foreign" >
| < FOUND : "found" >
| < FROM : "from" >
| < FULL : "full" >
| < GET : "get" >
| < GLOBAL : "global" >
| < GO : "go" >
| < GOTO : "goto" >
| < GRANT : "grant" >
| < GROUP : "group" >
| < HAVING : "having" >
| < HOUR : "hour" >
| < IDENTITY : "identity" >
| < IMMEDIATE : "immediate" >
| < IN : "in" >
| < INDICATOR : "indicator" >
| < INITIALLY : "initially" >
| < INNER : "inner" >
| < INPUT : "input" >
| < INSENSITIVE : "insensitive" >
| < INSERT : "insert" >
| < INT : "int" >
| < INTEGER : "integer" >
| < INTERSECT : "instersect" >
| < INTERVAL : "interval" >
| < INTO : "into" >
| < IS : "is" >
| < ISOLATION : "isolation" >
| < JOIN : "join" >
| < KEY : "key" >
| < LANGUAGE : "language" >
| < LAST : "last" >
| < LEADING : "leading" >
| < LEFT : "left" >
| < LEVEL : "level" >
| < LIKE : "like" >
| < LOCAL : "local" >
| < LOWER : "lower" >
| < MATCH : "match" >
| < MAX : "max" >
| < MIN : "min" >
| < MINUTE : "minute" >
| < MODULE : "module" >
| < MONTH : "month" >
| < NAMES : "names" >
| < NATIONAL : "national" >
| < NATURAL : "natural" >
| < NCHAR : "nchar" >
| < NEXT : "next" >
| < NO : "no" >
| < NOT : "not" >
| < NULL : "null" >
| < NULLIF : "nullif" >
| < NUMERIC : "numeric" >
| < OCTET_LENGTH : "octet_length" >
| < OF : "of" >
| < ON : "on" >
| < ONLY : "only" >
| < OPEN : "open" >
| < OPTION : "option" >
| < OR : "or" >
| < ORDER : "order" >
| < OUTER : "outer" >
| < OUTPUT : "output" >
| < OVERLAPS : "overlaps" >
| < PAD : "pad" >
| < PARTIAL : "partial" >
| < POSITION : "position" >
| < PRECISION : "precision" >
| < PREPARE : "prepare" >
| < PRESERVE : "preserve" >
| < PRIMARY : "primary" >
| < PRIOR : "prior" >
| < PRIVILEGES : "privileges" >
| < PROCEDURE : "procedure" >
| < PUBLIC : "public" >
| < READ : "read" >
| < REAL : "real" >
| < REFERENCES : "references" >
| < RELATIVE : "relative" >
| < RESTRICT : "restrict" >
| < REVOKE : "revoke" >
| < RIGHT : "right" >
| < ROLLBACK : "rollback" >
| < ROWS : "rows" >
| < SCHEMA : "schema" >
| < SCROLL : "scroll" >
| < SECOND : "second" >
| < SECTION : "section" >
| < SELECT : "select" >
| < SESSION : "session" >
| < SESSION_USER : "session_user" >
| < SET : "set" >
| < SIZE : "size" >
| < SMALLINT : "smallint" >
| < SOME : "some" >
| < SPACE : "space" >
| < SQL : "sql" >
| < SQLCODE : "sqlcode" >
| < SQLERROR : "sqlerror" >
| < SQLSTATE : "sqlstate" >
| < SUBSTRING : "substring" >
| < SUM : "sum" >
| < SYSTEM_USER : "system_user" >
| < TABLE : "table" >
| < TEMPORARY : "temporary" >
| < THEN : "then" >
| < TIME : "time" >
| < TIMESTAMP : "timestamp" >
| < TIMEZONE_HOUR : "timezone_hour" >
| < TIMEZONE_MINUTE : "timezone_minute" >
| < TO : "to" >
| < TRAILING : "trailing" >
| < TRANSACTION : "transaction" >
| < TRANSLATE : "translate" >
| < TRANSLATION : "translation" >
| < TRIM : "trim" >
| < TRUE : "true" >
| < UNION : "union" >
| < UNIQUE : "unique" >
| < UNKNOWN : "unknown" >
| < UPDATE : "update" >
| < UPPER : "upper" >
| < USAGE : "usage" >
| < USER : "user" >
| < USING : "using" >
| < VALUE : "value" >
| < VALUES : "values" >
| < VARCHAR : "varchar" >
| < VARYING : "varying" >
| < VIEW : "view" >
| < WHEN : "when" >
| < WHENEVER : "whenever" >
| < WHERE : "where" >
| < WITH : "with" >
| < WORK : "work" >
| < WRITE : "write" >
| < YEAR : "year" >
| < ZONE : "zone" >
}

// <non-reserved_word> 
//
// Cannot be certain what to make of these yet
//{ //  < ADA : "ada" >//| < C: "c" >//| < CATALOG_NAME: "catalog_name" >//| < CHARACTER_SET_CATALOG: "character_set_catalog" >//| < CHARACTER_SET_NAME: "character_set_name" >//| < CHARACTER_SET_SCHEMA: "character_set_schema" >//| < CLASS_ORIGIN: "class_origin" >//| < COBOL: "cobol" >//| < COLLATION_CATALOG: "collation_catalog" >//| < COLLATION_NAME: "collation_name" >//| < COLLATION_SCHEMA: "collation_schema" >//| < COLUMN_NAME: "column_name" >//| < COMMAND_FUNCTION: "command_function" >//| < COMMITTED: "committed" >//| < CONDITION_NUMBER: "condition_number" >//| < CONNECTION_NAME: "connection_name" >//| < CONSTRAINT_CATALOG: "constraint_catalog" >//| < CONSTRAINT_NAME: "constraint_name" >//| < CONSTRAINT_SCHEMA: "constraint_schema" >//| < CURSOR_NAME: "cursor_name" >//| < DATA: "data" >//| < DATETIME_INTERVAL_CODE: "datetime_interval_code" >//| < DATETIME_INTERVAL_PRECISION: "datetime_interval_precision" >//| < DYNAMIC_FUNCTION: "dynamic_function" >//| < FORTRAN: "fortran" >//| < LENGTH: "length" >//| < MESSAGE_LENGTH: "message_length" >//| < MESSAGE_OCTET_LENGTH: "message_octet_length" >//| < MESSAGE_TEXT: "message_text" >//| < SQL_MORE: "more" >//| < MUMPS: "mumps" >//| < NAME: "name" >//| < NULLABLE: "nullable" >//| < NUMBER: "number" >//| < PASCAL: "pascal" >//| < PLI: "pli" >//| < REPEATABLE: "repeatable" >//| < RETURNED_LENGTH: "returned_length" >//| < RETURNED_OCTET_LENGTH: "returned_octet_length" >//| < RETURNED_SQLSTATE: "returned_sqlstate" >//| < ROW_COUNT: "row_count" >//| < SCALE: "scale" >//| < SCHEMA_NAME: "schema_name" >//| < SERIALIZABLE: "serializable" >//| < SERVER_NAME: "server_name" >//| < SUBCLASS_ORIGIN: "subclass_origin" >//| < TABLE_NAME: "table_name" >//| < TYPE: "type" >//| < UNCOMMITTED: "uncommitted" >//| < UNNAMED: "unnamed" >//}

/**
 * TOKEN <ADQL-reserved-word>
 * 
 * bnf-start
 *  <ADQL-reserved-word> ::=
 *        TOP
 *      | ABS 
 *      | CEILING 
 *      | DEGREES 
 *      | EXP 
 *      | FLOOR 
 *      | LOG 
 *      | PI 
 *      | POWER 
 *      | RADIANS 
 *      | SQRT 
 *      | SQUARE 
 *      | LOG10 
 *      | RAND 
 *      | ROUND 
 *      | TRUNCATE 
 *      | SIN 
 *      | COS 
 *      | TAN 
 *      | COT 
 *      | ASIN 
 *      | ACOS 
 *      | ATAN 
 *      | ATAN2
 * bnf-end
 
 */
TOKEN : // <ADQL-reserved-word>
{

	< TOP: "top" >

|	< XMATCH: "xmatch" >

	//region
|	< REGION: "region" >
|	< CIRCLE : "circle" >
|   < ELLIPSE : "ellipse" >	
|   < POLYGON : "polygon" >
|   < SECTOR : "sector" >
|   < CONVEX : "convex" >
|   < CONVEX_HULL : "convex hull" >
|   < INTERSECTION : "intersection" >
|   < FILL_FACTOR : "fill factor" >
|   < UNIT : "unit" >
|   < COORD_SYSTEM : "coordsystem" | "cs" >   
|   < CENTER : "center" >
|   < RADIUS : "radius" >
|   < RADII : "radii" >
|   < POS_ANGLE : "angle" >

|   < DEG : "deg" >
|   < DEG_DEG_M : "deg deg m" >
|   < RAD : "rad" >
|   < H : "h" >
|   < ARCMIN : "arcmin" > 
|   < ARCSEC : "arcsec" >
|   < M : "m" >
|   < KM : "km" >
|   < MM : "mm" >
|   < AU : "au" >
|   < PC : "pc" >
|   < KPC : "kpc" >
|   < MPC : "Mpc" >
|   < LYR : "lyr" >   
	
	//math
|   < ABS: "abs" >
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >

|	< ASCII_STRING_LITERAL : "\'" (~["\'"])* "\'" >

//| 	< ASCIIStringLiteral : "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >
//|	< UnicodeStringLiteral : "n" "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >

}

/**
 * TOKEN <ADQL-special-character>
 *
 * bnf-start
 *  <ADQL-special-character> ::=
 *      <left_brace>
 *    | <right_brace>
 *    | <dollar>
 * bnf-end
 * bnf-single <left_brace> ::= {
 * bnf-single <right_brace> ::= }
 * bnf-single <dollar> ::= $
 */
TOKEN : // <ADQL-special-character>
{ 
	< LBRACE : "{" >
|	< RBRACE : "}" >
|	< DOLLAR : "$" >		
}

/**
 * TOKEN miscellaneous SQL92 
 *
 * bnf-single <not_equals_operator1> ::= <>
 * bnf-single <not_equals_operator2> ::= !=
 * bnf-single <not_equals_operator> ::= <not_equals_operator1> | <not_equals_operator2>
 * bnf-single <less_than_or_equals_operator> ::= <=
 * bnf-single <greater_than_or_equals_operator> ::= >=
 * bnf-single <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 * bnf-start
 *  <simple_Latin_letter> ::=
 *      <simple_Latin_upper_case_letter>
 *    | <simple_Latin_lower_case_letter>
 * bnf-end
 * bnf-start
 *  <simple_Latin_upper_case_letter> ::=
 *      A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
 *    | P | Q | R | S | T | U | V | W | X | Y | Z
 * bnf-end
 * bnf-start
 *  <simple_Latin_lower_case_letter> ::=
 *      a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
 *    | p | q | r | s | t | u | v | w | x | y | z
 * bnf-end
 * bnf-start
 *  <regular_identifier> ::=
 *      <simple_Latin_letter>... 
 *      [ { <digit> | <simple_Latin_letter> | <dollar> | <underscore> }... ]
 * bnf-end
 * bnf-start
 *  <delimited_identifier> ::=
 *  !! Begins and ends with a double quote as delimiters
 *     but contains no double quotes or white space
 * bnf-end
 * bnf-single <unsigned_integer> ::= <digit>...
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 *
 */
TOKEN : // miscellaneous SQL92 
{
	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< CROSS_JOIN : "cross join">
|	< GROUPBY: "group by" >
|	< ORDERBY : "order by" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TRUTH_VALUE : "true" | "false" | "unknown" >
| < REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">

|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] >   
|   < EXACT_NUMERIC_LITERAL : 
        ( <UNSIGNED_INTEGER> ( <PERIOD> ( <UNSIGNED_INTEGER> )? )? )
        | 
        ( <PERIOD> <UNSIGNED_INTEGER> ) >
|   < APPROXIMATE_NUMERIC_LITERAL : <MANTISSA> <E> <EXPONENT> > 
|   < #MANTISSA : <EXACT_NUMERIC_LITERAL> >
|   < #EXPONENT : <SIGNED_INTEGER> >        
|	< #SIGNED_INTEGER : <SIGN> <UNSIGNED_INTEGER> >
|   < #E : ["E", "e"] >
|   < #SIGN : <PLUS_SIGN> | <MINUS_SIGN> >

}

/**
 * TOKEN The remainder men.
 *
 *
 */
TOKEN : // The remainder
{
 	< OTHER : ~[] >
}

SelectDocument select_document_A() : 
{ 	
	SelectType st = null ;	
}
{
	// There is no equivalent construct in the SQL/92 standard.
	st=query_specification_fragment()
	{  
		if( st != null ) {
			selectDoc = SelectDocument.Factory.newInstance() ;
			selectDoc.setSelect( st ) ;
			checkTableAliases() ;
			checkExpressionAliases() ;
		}
		return selectDoc ; 
	}
}

//=================================

/**
 * actual_identifier_S
 *
 * bnf-single <actual_identifier> ::= <regular_identifier> | <delimited_identifier>
 *
 */
String actual_identifier_S() : 
{
	String idntfr = null ;	Token t = null ;
}
{
    //S:
    // <regular_identifier> | <delimited_identifier>
	( t=<REGULAR_IDENTIFIER> | t=<DELIMITED_IDENTIFIER> )
	{ 
		if( t != null ) {
			idntfr = t.image ; 
			if( idntfr.startsWith( "\"" ) ) {
				idntfr = idntfr.substring( 1, idntfr.lastIndexOf( "\"" ) ) ;
			}
		} 			  return idntfr ;        	}
}

// JL. The adql/x schema does not have such a beast!
//void approximate_numeric_literal_S() : {}//{//	//S://	// <approximate_numeric_literal> ::= <mantissa> E <exponent>//	// <mantissa> ::= <exact_numeric_literal>//	// <exponent> ::= <signed_integer>//	mantissa_S() // exponent_S()//}////void exponent_S() : {}//{//	// ["e" | "E"] signed_integer_S() //	signed_integer_S() //}

AtomType signed_integer_S() : 
{
    AtomType at = null ;
    Token t1 = null ;
    Token t2 = null ;
}
{
	(t1=<PLUS_SIGN> |t1=<MINUS_SIGN>) t2=<UNSIGNED_INTEGER> 
	{
	   if( t2 != null ) {
	   	   
	   	
	   }
	   return at ;	
	}
}

/**
 * between_predicate_A
 *
 * bnf-start
 * <between_predicate> ::=
 *     <value_expression> [ NOT ] BETWEEN
 *     <value_expression> AND <value_expression>
 * bnf-end
 *
 */
SearchType between_predicate_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "between_predicate_A()" ) ;
	ScalarExpressionType se1 = null ;
	ScalarExpressionType se2 = null ;
	ScalarExpressionType se3 = null ;
	SearchType st = null ;
	Token t = null ;
}
{
	//S:
	// <row_value_constructor> [ NOT ] BETWEEN
    // <row_value_constructor> AND <row_value_constructor>
    
    // Note the absence of row_value_constructor...	
	( se1=value_expression_A() [ t=<NOT> ] <BETWEEN> se2=value_expression_A() <AND> se3=value_expression_A()	)
	{
		if( se3!=null ) {
			ScalarExpressionType[] args = new ScalarExpressionType[3] ;
			args[0] = se1 ;
			args[1] = se2 ;
			args[2] = se3 ;
			if( t==null ) {
				BetweenPredType bp = BetweenPredType.Factory.newInstance() ;
				bp.setArgArray( args ) ;
				st = bp ;			
			}
			else {
				NotBetweenPredType nbp = NotBetweenPredType.Factory.newInstance() ;
				nbp.setArgArray( args ) ;
				st = nbp ;		
			}
		}
		if( TRACE_ENABLED ) exitTrace ( "between_predicate_A()" ) ;
		return st ;
	}
}

SearchType between_predicate_fragment() :
{
	SearchType st = null ;
}
{
	st=between_predicate_A() <SEMICOLON>
	{ return st ; }
} 

/**
 * boolean_primary_S
 *
 * bnf-start
 *  <boolean_primary> ::= 
 *       <predicate> 
 *     | <left_paren> <search_condition> <right_paren>
 * bnf-end
 *
 */
SearchType boolean_primary_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "boolean_primary_S()" ) ;
	SearchType st = null ;
	Token t = null ;
} 
{
	//S:
	// <boolean_primary> ::=
    //    <predicate>
    //  | <left_paren> <search_condition> <right_paren>
	(
		LOOKAHEAD(6)
		st=predicate_A()
	    |
	    ( <LEFT_PAREN> st=search_condition_S() t=<RIGHT_PAREN> )
    )
    {
    	if( t != null ) {
    		ClosedSearchType cs = ClosedSearchType.Factory.newInstance() ;
    		cs.setCondition( st ) ;
    		st = cs ;	
    	}
    	if( TRACE_ENABLED ) exitTrace ( "boolean_primary_S()" ) ;
    	return st ;
    }
}

/**
 * boolean_term_S
 *
 * bnf-start
 *  <boolean_term> ::=
 *      <boolean_factor>
 *    | <boolean_term> AND <boolean_factor>
 * bnf-end
 *
 */
SearchType boolean_term_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "boolean_term_S()" ) ;
	SearchType st1 = null ;
	SearchType st2 = null ;
	SearchType retval = null ;
}
{
	//S:
	// <boolean_term> ::=
    //    <boolean_factor>
    //  | <boolean_term> AND <boolean_factor>

	// Refactored to
	// boolean_factor_S() ( <AND> boolean_factor_S() )*
	// which I believe is equivalent to the above
	st1=boolean_factor_S() st2=booleanFactorList()
	{
		if( st2 == null ) {
		   retval = st1 ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st1 ;
		   conditionArray[1] = st2 ;
		   IntersectionSearchType andType = IntersectionSearchType.Factory.newInstance() ;
		   andType.setConditionArray( conditionArray ) ;
		   retval = andType ;
		}	
		if( TRACE_ENABLED ) exitTrace ( "boolean_term_S()" ) ;
		return retval ;
	}
}

/**
 * boolean_factor_S
 *
 * bnf-single <boolean_factor> ::= [ NOT ] <boolean_test>
 *
 */
SearchType boolean_factor_S() :
{
	if( TRACE_ENABLED ) enterTrace ( "boolean_factor_S()" ) ;
	SearchType sc = null ;
	Token t = null ;
}
{
	[ t=<NOT> ] sc=boolean_test_A()
	{
		if( t != null ) {
			InverseSearchType is = InverseSearchType.Factory.newInstance() ;
			is.setCondition( sc ) ;
			sc = is ;		
		}
		if( TRACE_ENABLED ) exitTrace ( "boolean_factor_S()" ) ;
		return sc ;
	}
}

SearchType booleanFactorList() :
{
	if( TRACE_ENABLED ) enterTrace ( "booleanFactorList()" ) ;
	Stack stack = null ;
	SearchType st = null ;
}
{
	( 
	    LOOKAHEAD(3)
		st=booleanFactorSingleton() 
		{ if( stack == null )
	  	     stack = new Stack() ;
	  	  stack.push( st ) ;
	  	} 	
	)*
	{
		if( stack != null ) {
			IntersectionSearchType heldAnd = null ;
			SearchType[] conditions = new SearchType[2] ;
			while( stack.empty() == false ) {
				st = (SearchType)stack.pop() ;
				if( heldAnd != null ) {
					conditions[0] = st ;
					conditions[1] = heldAnd ;
					IntersectionSearchType andType = IntersectionSearchType.Factory.newInstance() ;
					andType.setConditionArray( conditions ) ;
					heldAnd = andType ;
				}
				else if( stack.empty() == false  ) {
					conditions[0] = (SearchType)stack.pop() ;
					conditions[1] = st ;
					IntersectionSearchType andType = IntersectionSearchType.Factory.newInstance() ;
					andType.setConditionArray( conditions ) ;
					heldAnd = andType ;
				}
			}
			if( heldAnd != null )
				st = heldAnd ; 
		}		
		if( TRACE_ENABLED ) exitTrace ( "booleanFactorList()" ) ;
		return st ;
	}
}

SearchType booleanFactorSingleton() :
{
	if( TRACE_ENABLED ) enterTrace ( "booleanFactorSingleton()" ) ;
	SearchType st = null ;
}
{
	<AND> st=boolean_factor_S()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "booleanFactorSingleton()" ) ;
		return st ; 
	}
}


/**
 * boolean_test_A
 *
 * bnf-start
 *  <boolean_test> ::= <boolean_primary>
 *  !! There is no accommodation for <truth_value> in ADQL
 * bnf-end
 *
 */
SearchType boolean_test_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "boolean_test_A()" ) ;
	SearchType st = null ;
}
{
	//S:
	// <boolean_test> ::=
    //  <boolean_primary> [ IS [ NOT ] <truth_value> ]
	
	// NB: There is no accommodation of truth value in ADQL
	st=boolean_primary_S() 
	{ 
		if( TRACE_ENABLED ) exitTrace ( "boolean_test_A()" ) ;
		return st ; 
	}
}

/**
 * like_predicate_A
 *
 * bnf-start
 *  <like_predicate> ::=
 *      <match_value> [ NOT ] LIKE <pattern>
 *  !! There is no accommodation for <escape_character> in ADQL
 * bnf-end
 *
 */
SearchType like_predicate_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "like_predicate_A()" ) ;
	SearchType st = null ;
	Token t = null ;
	AtomType p = null ;
	ScalarExpressionType se = null ;
}
{
	//S:
	// <like_predicate> ::=
	//   <match_value> [ NOT ] LIKE <pattern> [ ESCAPE <escape_character> ]
      
	( se=match_value_S() [ t=<NOT> ] <LIKE> p=pattern_A() )
	{
		if( p != null ) {
			
			if( t == null ) {
				LikePredType lpt = LikePredType.Factory.newInstance() ;
				lpt.setArg( se ) ;
				lpt.setPattern( p ) ;
				st = lpt ;
			}
			else {
				NotLikePredType nlpt = NotLikePredType.Factory.newInstance() ;
				nlpt.setArg( se ) ;
				nlpt.setPattern( p ) ;
				st = nlpt ;
			}
			
		} 
		if( TRACE_ENABLED ) exitTrace ( "like_predicate_A()" ) ;
		return st ;	
	}
}

SearchType like_predicate_fragment() : 
{
	SearchType st = null ;
}
{
	st=like_predicate_A() <SEMICOLON>
	{ return st ; }
}

void caseExpression_S() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification_S() : {}
{
	"6-TBD castSpecification"
}

/**
 * character_factor_A
 *
 * bnf-start
 *  <character_factor> ::= <character_primary>
 *  !! There is no accommodation for <collate_clause> in ADQL
 * bnf-end
 *
 */
ScalarExpressionType character_factor_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <character_factor> ::= <character_primary> [ <collate_clause> ]

	seType=character_primary_A()
	{ return seType ; }
}

/**
 * character_primary_A
 *
 * bnf-start
 *  <character_primary> ::= <value_expression_primary>
 *  !! There is no accommodation for <string_value_function> in ADQL
 * bnf-end
 *
 */
ScalarExpressionType character_primary_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	//  <character_primary> ::=
    //    <value_expression_primary> | <string_value_function>

	seType=value_expression_primary_A()
	{ return seType ; }
}

/**
 * character_string_literal_A
 *
 * bnf-start
 *  <character_string_literal> ::=
 *     <quote> [ <character_representation>... ] <quote>
 *     [ { <quote> [ <character_representation>... ] <quote> }... ]
 *  !! There is no accommodation for <character_set_specification> in ADQL
 * bnf-end
 *
 * bnf-start
 *  <character_representation> ::=
 *  !! At present this is one ASCII character (but not a single quote).
 * bnf-end
 *
 */
AtomType character_string_literal_A() : 
{
	AtomType atomType = null ;
}
{
	//S:
	// <character_string_literal> ::=
    //    [ <introducer><character_set_specification> ]
    //    <quote> [ <character_representation>... ] <quote>
    //    [ { <separator>... <quote> [ <character_representation>... ] <quote> }... ]

	atomType=ASCIIStringLiteral()
	{ 
		return atomType ; 		
	} 
}

AtomType ASCIIStringLiteral() : 
{
	if( TRACE_ENABLED ) enterTrace ( "ASCIIStringLiteral()" ) ;
	AtomType at = null ;
	ArrayList list = null ;
	Token t1 = null ;
}
{
	( 
		t1=<ASCII_STRING_LITERAL> 
			{
				if( t1 != null ) {
					if( list == null )
						list = new ArrayList() ;
					list.add( t1.image.substring( 1, t1.image.length()-1 ) ) ;
					t1 = null ;
				}
			}

	)+
	{
		if( list.size() > 0 ) {
			StringBuffer buffer = new StringBuffer();
			ListIterator it = list.listIterator() ;
			while( it.hasNext() ) {
				buffer.append( (String)it.next() ) ;	
			}
			at = AtomType.Factory.newInstance() ;
			StringType st = StringType.Factory.newInstance() ;
			st.setValue( buffer.toString() ) ;
			at.setLiteral( st ) ;			
		}
		if( TRACE_ENABLED ) exitTrace ( "ASCIIStringLiteral()" ) ;
		return at ;
	} 
	
}

/**
 * character_value_expression_A
 *
 * bnf-start
 *  <character_value_expression> ::= <character_factor>
 *  !! There is no accommodation for <concatenation> in ADQL
 * bnf-end
 *
 */
ScalarExpressionType character_value_expression_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "character_value_expression_A()" ) ;
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <character_value_expression> ::=
    //     <concatenation>
    //   | <character_factor>

	seType=character_factor_A()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "character_value_expression_A()" ) ;
		return seType ; 
	}	
}

void collate_clause_S() : {}
{
	//S:
	// <collate_clause> ::= COLLATE <collation_name>
    // <collation_name> ::= <qualified_name>
	
	// refactored to
	<COLLATE> qualified_name_A()	
}

/**
 * column_name_S
 *
 * bnf-single <column_name> ::= <identifier>
 *
 */
String column_name_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "column_name_S()" ) ;
	String name = null ;
}
{
	//S:
	// <column_name> ::= <identifier>

	name=identifier_A()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "column_name_S()" ) ;
		return name ; 
	}
}

/**
 * column_name_list_S
 *
 * bnf-single <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
 *
 */
void column_name_list_S()  : {}
{
	//S:
	// <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
	 column_name_S() ( <COMMA> column_name_S() )*	
}

/**
 * column_reference_A
 *
 * bnf-start
 *  <column_reference> ::= 
 *      <qualifier> <period> <column_name>         
 *  !! ADQL enforces qualified column names.
 * bnf-end
 *
 */
ColumnReferenceType column_reference_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "column_reference_A()" ) ;
	ColumnReferenceType crType = null ;
	String q = null ;
	String n = null ;
//	AliasSelectionItemType asiType = null ;
//	SelectionItemType retVal = null ;
}
{
	//S:
	// <column_reference> ::= [ <qualifier> <period> ] <column_name>

	  q=qualifier_A() <PERIOD> n=column_name_S() 
	  { 
		 if( n != null ) {
		 	crType = ColumnReferenceType.Factory.newInstance() ;
			crType.setName( n ) ;
			if( q != null ) {
				crType.setTable( q ) ;	
			}
//		    retVal = crType ; 	
		 } 
	  }	
//	)//	|//	( //	  asiType=aliased_expression_reference_A() //	  { //		 if( asiType != null ) {//		    retVal = asiType ;//		 } //	  }		//	)
	{
		if( TRACE_ENABLED ) exitTrace ( "column_reference_A()" ) ;		
		return crType ; 			
	}
}

///**// * aliased_expression_reference_A// *// *-bnf-start// *- <aliased_expression_reference> ::= <identifier>// *- !! ADQL specific. // *- NB. This is simply a reference to an aliased expression.// *-bnf-end// *// *///AliasSelectionItemType aliased_expression_reference_A() ://{//	if( TRACE_ENABLED ) enterTrace ( "aliased_expression_reference_A()" ) ;//	AliasSelectionItemType asiType = null ;//	String name = null ;//}//{//	////	// Note especially that this is simply a reference to an//	// aliased expression defined elsewhere. At this point we//	// only have the name of the alias, not the content, so we//	// can only construct an empty AliasSelectionItemType.//	// Filling in these must wait until the whole query has//	// been assembled and is thought to be syntactically correct!!!//	name=identifier_A()//	{//		if( name != null ) {//		    asiType = AliasSelectionItemType.Factory.newInstance() ;//			asiType.setAs( name ) ;//		}//	    if( TRACE_ENABLED ) exitTrace ( "aliased_expression_reference_A()" ) ;		//	    return asiType ;	//	}//}

/**
 * value_expression_primary_A
 *
 * NB: Referred in some sources as <common_primary>
 *
 * bnf-start
 *  <value_expression_primary> ::=
 *      <unsigned_value_specification>
 *    | <column_reference>
 *    | <set_function_specification>
 *    | <left_paren> <value_expression> <right_paren>
 *  !! There is no accommodation for <scalar_subquery>,
 *     <case_expression> or <cast_specification> in ADQL
 * bnf-end
 *
 */
ScalarExpressionType value_expression_primary_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "value_expression_primary_A()" ) ;
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	//S:
	//	<value_expression_primary> ::=
	//      <unsigned_value_specification>
	//    | <column_reference>
	//    | <set_function_specification>
	//    | <scalar_subquery>
	//    | <case_expression>
	//    | <left_paren> <value_expression> <right_paren>
	//    | <cast_specification>

	(
		// Foreshortened 
		seType=unsigned_value_specification_S()
		|
		seType=column_reference_A()
		|
		seType=set_function_specification_S()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)
	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()
	//	|
		( <LEFT_PAREN> seType=value_expression_A() <RIGHT_PAREN> ) 
		{
			if( seType != null ) {
				ClosedExprType ceType = ClosedExprType.Factory.newInstance() ;
				ceType.setArg( seType ) ;	
				seType = ceType ;			
			}
		}
	// JBL: cast ommitted in initial version
	//	|
	//	castSpecification()
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "value_expression_primary_A()" ) ;
		return seType ; 
	}
}

/**
 * comp_op_S
 *
 * bnf-start
 *  <comp_op> ::=
 *      <equals_operator>
 *    | <not_equals_operator>
 *    | <less_than_operator>
 *    | <greater_than_operator>
 *    | <less_than_or_equals_operator>
 *    | <greater_than_or_equals_operator>
 * bnf-end
 *
 */
ComparisonType comp_op_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "comp_op_S()" ) ;
	ComparisonType c = null ;
	Token t = null ;
}
{
	//S:
	// <comp_op> ::=
    //    <equals_operator>
    //  | <not_equals_operator>
    //  | <less_than_operator>
    //  | <greater_than_operator>
    //  | <less_than_or_equals_operator>
    //  | <greater_than_or_equals_operator>
	(
		t=<EQUALS_OPERATOR> 
		|
		t=<NOT_EQUALS_OPERATOR> 
		|
		t=<LESS_THAN_OPERATOR> 
		| 
		t=<GREATER_THEN_OPERATOR> 
		| 
		t=<LESS_THAN_OR_EQUALS_OPERATOR> 
		| 
		t=<GREATER_THAN_OR_EQUALS_OPERATOR>	
	)
	{
		if( t != null )	{
			c = ComparisonType.Factory.newInstance() ;
			String image = null ;
			//  
			// The != comparison is a convenience. It is not a valid enum within
			// the schema. So we substitute the official value instead...
			if( t.kind == AdqlStoXConstants.NOT_EQUALS_OPERATOR ) {
				image = "<>" ;
			}
			else {
				image = t.image.toUpperCase() ;
			}
			c.set( ComparisonType.Enum.forString( image ) ) ;	
		}
		if( TRACE_ENABLED ) exitTrace ( "comp_op_S()" ) ;
		return c ;
	}
}

/**
 * comparison_predicate_A
 *
 * bnf-start
 *  <comparison_predicate> ::=
 *      <value_expression> <comp_op> <value_expression>
 *  !! There is no accommodation for <row_value_constructor> in ADQL
 * bnf-end
 *
 */
ComparisonPredType comparison_predicate_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "comparison_predicate_A()" ) ;
	ComparisonPredType cpType = null ;
	ScalarExpressionType seType1 = null ;
	ScalarExpressionType seType2 = null ;
	ScalarExpressionType[] args = null ;
	ComparisonType compType = null ;
}
{
	//S:
	//  <row_value_constructor> <comp_op> <row_value_constructor>
	( seType1=value_expression_A() compType=comp_op_S() seType2=value_expression_A() )
	{ 
		try {
		
			if( seType2 != null ) {
				cpType = ComparisonPredType.Factory.newInstance() ;
				args = new ScalarExpressionType[2] ;
				args[0] = seType1 ;
				args[1] = seType2 ;
				cpType.setArgArray( args ) ;
				cpType.xsetComparison( compType ) ;	
				
			}
			return cpType ;
		}
		finally {
			if( TRACE_ENABLED ) exitTrace( "comparison_predicate_A()" ) ;	
		}	
	}
}

ComparisonPredType comparison_predicate_fragment() : 
{
	ComparisonPredType cp = null ;
}
{
	cp=comparison_predicate_A() <SEMICOLON>
	{ return cp ; }
}

/**
 * correlation_name_S
 *
 * bnf-single <correlation_name> ::= <identifier>
 *
 */
String correlation_name_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "correlation_name_S()" ) ;
	String name = null ;
}
{
	//S:
	// <correlation_name> ::= <identifier>
	name=identifier_A()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "correlation_name_S()" ) ;
		return name ; 
	}
}

void datetime_factor_S() : {}
{
	//S:
	//  <datetime_factor> ::=
    //     <datetime_primary> [ <time_zone> ]
    
	datetime_primary_S() [  LOOKAHEAD(2) time_zone_S() ]
}

void datetime_primary_S() : {}
{
	//S:
	// <datetime_primary> ::=
    //    <value_expression_primary>
    //  | <datetime_value_function>

	value_expression_primary_A()
    | 
    datetime_value_function_S()
}

void datetime_term_S() : {}
{
	//S:
	// <datetime_term> ::= <datetime_factor>
    datetime_factor_S()
}

void datetime_value_expression_S() : {}
{
	//S:
	// <datetime_value_expression> ::=
    //    <datetime_term>
    //  | <interval_value_expression> <plus_sign> <datetime_term>
    //  | <datetime_value_expression> <plus_sign> <interval_term>
    //  | <datetime_value_expression> <minus_sign> <interval_term>

	// refactored to
	LOOKAHEAD(3)
    ( datetime_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) datetime_value_expression_S() )* )
    |
    ( interval_value_expression_S() <PLUS_SIGN> datetime_term_S() )
}

void datetime_value_function_S() : {}
{
	//S:
	// <datetime_value_function> ::=
    //    <current_date_value_function>
    //  | <current_time_value_function>
    //  | <current_timestamp_value_function>

	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LEFT_PAREN> time_precision_S() <RIGHT_PAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LEFT_PAREN> timestamp_precision_S() <RIGHT_PAREN> ]
}

/**
 * derived_column_list_S
 *
 * bnf-single <derived_column_list> ::= <column_name_list>
 *
 */
void derived_column_list_S() : {}
{
	//S:
	// <derived_column_list> ::= <column_name_list>
   column_name_list_S()	
}

void derived_table_S() : {}
{
	//S:
	// <derived_table> ::= <table_subquery>
   	table_subquery_S()
}

void end_field_S() : {}
{
	//S:
	// <end_field> ::=
    //    <non-second_datetime_field>
    //  | SECOND [ <left_paren> <interval_fractional_seconds_precision> <right_paren> ]
	nonsecond_datetime_field_S() | <SECOND> [ <LEFT_PAREN> interval_fractional_seconds_precision_S() <RIGHT_PAREN> ]
}

void escape_character_A() : {}
{
	//S:
	// <escape_character> ::= <character_value_expression>
	character_value_expression_A()	
}

/**
 * exact_numeric_literal_S
 *
 * bnf-start
 *  <exact_numeric_literal> ::=
 *      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]
 *    | <period> <unsigned_integer>
 * bnf-end
 *
 */
AtomType exact_numeric_literal_S( int possibleSignChange ) :
{
	AtomType atomType = null ;
	Token t = null ;
}
{
	//S:
	//  <exact_numeric_literal> ::=    //      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]    //    | <period> <unsigned_integer>
    
    // NB: The repeat check below for <UNSIGNED_INTEGER>!
    // Not sure whether there is a better way of doing this...
    // <EXACT_NUMERIC_LITERAL> and <UNSIGNED_INTEGER> compete
    // with each other as tokens. Where only an unsigned integer
    // is used, they both represent the same thing (!), and the token
    // manager chooses unsigned integer (probably because it happens
    // to be before exact numeric literal in the token list)!
    //
    // This is probably worthy of study to see whether a more
    // stable way of doing this is possible.
	( t=<EXACT_NUMERIC_LITERAL> | t=<UNSIGNED_INTEGER>)
	{ 
		if( t != null ) {
			atomType = AtomType.Factory.newInstance() ;	
		    if( t.image.indexOf( '.' ) == -1 ) {
		    	IntegerType intType = IntegerType.Factory.newInstance() ;
			    intType.setValue( new Long( t.image ).longValue() * possibleSignChange ) ;
			    atomType.setLiteral( intType ) ;
		    }
		    else {
		    	RealType realType = RealType.Factory.newInstance() ;
			    realType.setValue( new Double( t.image ).doubleValue() * possibleSignChange ) ;
			    atomType.setLiteral( realType ) ;
		    }
		}
		return atomType ;
	} 
}

SearchType exists_predicate_S() : 
{
	SearchType st = null ;
}
{
	//S: 
	// <exists_predicate> ::= EXISTS <table_subquery>
	<EXISTS> st=table_subquery_S()
	{ 
		if( st != null ) {
		}
		
		return st ;	
	}	
}

void explicit_table_S() : {}
{
	//S:
	// <explicit_table> ::= TABLE <table_name>
	<TABLE> table_name_A()
}

/**
 * factor_S
 *
 * bnf-single <factor> ::= [ <sign> ] <numeric_primary> 
 *
 */
ScalarExpressionType factor_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "factor_S()" ) ;
	ScalarExpressionType retType = null ;
	ScalarExpressionType seType = null ;
	UnaryExprType ueType = null ;
}
{
	//S:
	// <factor> ::= [ <sign> ] <numeric_primary>   
	( ueType=factorUnary() seType=numeric_primary_S() )
	{ 
	   if( ueType != null ) {
	   	  ueType.setArg( seType ) ;
	   	  retType = ueType ;
	   }
	   else {
	   	  retType = seType ;
	   }
	   if( TRACE_ENABLED ) exitTrace ( "factor_S()" ) ;
	   return retType ;
	}
}

UnaryExprType factorUnary() : 
{
	UnaryExprType ueType = null ;
	Token t = null ;
}
{
	( [ t=<PLUS_SIGN> | t=<MINUS_SIGN> ] )
	{ 
	   if( t != null ) {
	   		ueType = UnaryExprType.Factory.newInstance() ;
	   		ueType.setOper( UnaryOperatorType.Enum.forString( t.image ) ) ;	   	
	   }
	   return ueType ;
	}
}

FromType from_clause_fragment() :
{ 
	FromType ft = null ; 
}
{
	( ft=from_clause_S() <SEMICOLON> )
	{
	  return ft ;	
	}
}

/**
 * from_clause_S
 *
 * bnf-start
 *  <from_clause> ::= FROM <table_reference>
 *     [ { <comma> <table_reference> }... ]
 * bnf-end
 *
 */
FromType from_clause_S() : 
{
    if( TRACE_ENABLED ) enterTrace ( "from_clause_S()" ) ;
	FromType fromType = null ;
	FromTableType ftType = null ;
	ArrayList list = new ArrayList() ;
}
{
	( 
	//S:
	// FROM <table_reference>
    // [ { <comma> <table_reference> }... ]
	
		<FROM> ftType=table_reference_A() { list.add( ftType ) ; } 
		( <COMMA> ftType=table_reference_A() { list.add( ftType ) ; } )* 
	)
	{
		if( list.size() > 0 ) {
		   fromType = FromType.Factory.newInstance() ;
		   FromTableType[] tableRefArray = new FromTableType[ list.size() ] ;
		   fromType.setTableArray( (FromTableType[])list.toArray(tableRefArray) ) ;		
		}
	    if( TRACE_ENABLED ) exitTrace ( "from_clause_S()" ) ;
		return fromType ;
	}
}

/**
 * general_literal_A
 *
 * bnf-start
 *  <general_literal> ::= <character_string_literal>
 *  !! There is no accommodation for <national_character_string_literal>,
 *     <bit_string_literal>, <hex_string_literal>, <datetime_literal>
 *     and <interval_literal> in ADQL
 * bnf-end
 *
 */
AtomType general_literal_A() :
{
	AtomType atomType = null ;	
}
{
	//S:
	//  <general_literal> ::=
    //    <character_string_literal>
    //  | <national_character_string_literal>
    //  | <bit_string_literal>
    //  | <hex_string_literal>
    //  | <datetime_literal>
    //  | <interval_literal>

	atomType=character_string_literal_A()
	{ return atomType ; }	
}

/**
 * general_set_function_A
 *
 * bnf-start
 *  <general_set_function> ::=
 *     <set_function_type>
 *         <left_paren> <value_expression> <right_paren>
    !! There is no accommodation for <set_quantifier> in ADQL
 * bnf-end
 *
 * bnf-single <set_function_type> ::= AVG | MAX | MIN | SUM | COUNT
 *
 */
AggregateFunctionType general_set_function_A() : 
{
	AggregateFunctionType afType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	//S:
	// <general_set_function> ::=
    //   <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>

	// JL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LEFT_PAREN> [ setQuantifier() ] seType=value_expression_A() <RIGHT_PAREN>	
	( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LEFT_PAREN> seType=value_expression_A() <RIGHT_PAREN>
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			argArray[0] = seType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }	
}

/**
 * general_value_specification_A
 *
 * bnf-start
 *  <general_value_specification> ::= <variable_specification>
 *  !! There is no accommodation for <parameter_specification>, <dynamic_parameter_specification>,
       USER, CURRENT_USER, SESSION_USER, SYSTEM_USER and VALUE
 * bnf-end
 *
 */
ScalarExpressionType general_value_specification_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	//<general_value_specification> ::=
    //   <parameter_specification>
    // | <dynamic_parameter_specification>
    // | <variable_specification>
    // | USER
    // | CURRENT_USER
    // | SESSION_USER
    // | SYSTEM_USER
    // | VALUE
	
	// Foreshortened
	seType=variable_specification_A()
	{ return seType ; }	
}

/**
 * group_by_clause_S
 *
 * bnf-start
 *  <group_by_clause> ::= GROUP BY <grouping_column_reference_list>
 * bnf-end
 *
 */
GroupByType group_by_clause_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "group_by_clause_S()" ) ;
	GroupByType gbType = null ;
	ArrayList crList = null ;
}
{
	//S:
	// GROUP BY <grouping_column_reference_list>
	<GROUPBY> crList=grouping_column_reference_list_S()
	{
		if(	crList != null ) {
			gbType = GroupByType.Factory.newInstance() ;
			ColumnReferenceType[] colRefArray = new ColumnReferenceType[ crList.size() ] ;
			gbType.setColumnArray( (ColumnReferenceType[])crList.toArray(colRefArray) ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "group_by_clause_S()" ) ;
		return gbType ;
	}
}

GroupByType group_by_clause_fragment() : 
{
	GroupByType gbt = null ;
}
{
	gbt=group_by_clause_S() <SEMICOLON>
	{ return gbt ; }
}

/**
 * grouping_column_reference_list_S
 *
 * bnf-start
 *  <grouping_column_reference_list> ::=
 *      <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
 * bnf-end
 *
 */
ArrayList grouping_column_reference_list_S() : 
{
	ArrayList list = null ;
	ColumnReferenceType cr = null ;
}
{
	//S:
	// <grouping_column_reference_list> ::=
    //   <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]

	(
		cr=grouping_column_reference_A()  
		{ 
			if( list == null )
				list = new ArrayList() ;
			list.add( cr ) ; 
		}
		( <COMMA> cr=grouping_column_reference_A() { list.add( cr ) ; } )* 
	)
	{ return list ; }
}

/**
 * grouping_column_reference_A
 *
 * bnf-start
 *  <grouping_column_reference> ::= <column_reference> 
 *  !! There is no accommodation for <collate_clause>
 * bnf-end
 *
 */
ColumnReferenceType grouping_column_reference_A() : 
{
	ColumnReferenceType cr = null ;
}
{
    //S:
    // <grouping_column_reference> ::=
    //      <column_reference> [ <collate_clause> ]

	cr=column_reference_A()	
	{ return cr ; }
}

/**
 * having_clause_S
 *
 * bnf-single <having_clause> ::= HAVING <search_condition>	
 *
 */
HavingType having_clause_S() :
{
	if( TRACE_ENABLED ) enterTrace ( "having_clause_S()" ) ;
	HavingType hType = null ;
	SearchType sType = null ;
	Token t = null ;
}
{	
	//S:
	//  HAVING <search_condition>	
	( t=<HAVING> sType=search_condition_S() )
	{
		if( sType != null ) {
			hType = HavingType.Factory.newInstance() ;	
			hType.setCondition( sType ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "having_clause_S()" ) ;
		return hType ;
		
	}
}

HavingType having_clause_fragment() :
{
	HavingType ht = null ;
}
{	
	ht=having_clause_S() <SEMICOLON>
	{ return ht ; }
}

/**
 * identifier_A
 *
 * bnf-start
 *  <identifier> ::= <actual_identifier>
 *  !! There is no accommodation for <character_set_specification> 
 * bnf-end
 *
 */
String identifier_A() : 
{ String retValue ; }
{
	//S:
	// <identifier> ::=
    //   [ <introducer><character_set_specification> ] <actual_identifier>

	retValue=actual_identifier_S()
	{ return retValue ; }
} 

/**
 * in_predicate_A
 *
 * bnf-start
 *  <in_predicate> ::=
 *      <value_expression> [ NOT ] IN <in_predicate_value>
 * bnf-end
 *
 */
SearchType in_predicate_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "in_predicate_A()" ) ;
	Token t1 = null ;
	Token t2 = null ;
	ScalarExpressionType seType = null ;
	InclusionSetType isType = null ;
	SearchType retVal = null ;
}
{
	//S:
	// <in_predicate> ::=
    //   <row_value_constructor> [ NOT ] IN <in_predicate_value>
    
	// refactored to
	( 
	  seType=value_expression_A() [ t1=<NOT> ] <IN> isType=in_predicate_value_S()
	)
    {
       if( isType != null ) {
       	  if( t1 == null ) {
       	     InclusiveSearchType iSearch = InclusiveSearchType.Factory.newInstance()  ;
       	     iSearch.setExpression( seType ) ;
       	     iSearch.setSet( isType ) ;
       	     retVal = iSearch ;
       	  }
       	  else {
       	  	 ExclusiveSearchType xSearch = ExclusiveSearchType.Factory.newInstance()  ;
       	     xSearch.setExpression( seType ) ;
       	     xSearch.setSet( isType ) ; 
       	     retVal = xSearch ;     	  	
       	  }
       }
       if( TRACE_ENABLED ) exitTrace ( "in_predicate_A()" ) ;
	   return retVal ;	
	}
}

SearchType in_predicate_fragment() : 
{
	SearchType st = null ;
}
{
	st=in_predicate_A() <SEMICOLON>
	{ return st ; }
}

/**
 * in_predicate_value_S
 *
 * bnf-start
 *  <in_predicate_value> ::=
 *     <table_subquery> | <left_paren> <in_value_list> <right_paren>
 * bnf-end
 *
 */
InclusionSetType in_predicate_value_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "in_predicate_value_S()" ) ;
	InclusionSetType isType = null ;
	Token t = null ;
}
{
	//S:
    // <in_predicate_value> ::= <table_subquery>  | <left_paren> <in_value_list> <right_paren>
	
	( LOOKAHEAD(2) isType=table_subquery_A() | ( <LEFT_PAREN> isType=in_value_list_A() t=<RIGHT_PAREN> ) )
	{ 
		if( TRACE_ENABLED ) exitTrace ( "in_predicate_value_S()" ) ;
		return isType ; 
	} 	
}

void interval_factor_S() : {}
{
	//S:
	// <interval_factor> ::=
    //   [ <sign> ] <interval_primary>

    [ <PLUS_SIGN> | <MINUS_SIGN> ] interval_primary_S()
}

void interval_fractional_seconds_precision_S() : {}
{
	//S:
	// <interval_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_leading_field_precision_S() : {}
{
	//S:
	// <interval_leading_field_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_primary_S() : {}
{
	//S:
	// <interval_primary> ::=
    //    <value_expression_primary> [ <interval_qualifier> ]

      value_expression_primary_A() [ LOOKAHEAD(2) interval_qualifier_S() ]
}

void interval_qualifier_S() : {}
{
	//S:
	// <interval_qualifier> ::=
    //    <start_field> TO <end_field> | <single_datetime_field>

	LOOKAHEAD(3)
    start_field_S() <TO> end_field_S()
    | 
    single_datetime_field_S()
}

void interval_term_S() : {}
{
	//S:
	// <interval_term> ::=
    //    <interval_factor>
    //  | <interval_term_2> <asterisk> <factor>
    //  | <interval_term_2> <solidus> <factor>
    //  | <term> <asterisk> <interval_factor>

	// refactored...
	LOOKAHEAD(3)
	interval_factor_S() 
    |
	LOOKAHEAD(3)    
    factor_S() (<ASTERISK> | <SOLIDUS>) interval_term_S()
    | 
    term_S() <ASTERISK> interval_factor_S()
}

void interval_value_expression_S() : {}
{
	//S:
	// <interval_value_expression> ::=
    //    <interval_term>
    //  | <interval_value_expression_1> <plus_sign> <interval_term_1>
    //  | <interval_value_expression_1> <minus_sign> <interval_term_1>
    //  | <left_paren> <datetime_value_expression> <minus_sign>
    //      <datetime_term> <right_paren> <interval_qualifier>

	// refactored
	LOOKAHEAD(3)
	interval_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) interval_term_S() )*
    | 
    <LEFT_PAREN> datetime_value_expression_S() <MINUS_SIGN> datetime_term_S() <RIGHT_PAREN> interval_qualifier_S()
}

/**
 * in_value_list_A
 *
 * bnf-start
 *  <in_value_list> ::=
 *      <in_value_list_constant> { <comma> <in_value_list_constant> }...
 *  !! There is no accommodation for <value_expression>
 * bnf-end
 *
 */
ConstantListSet in_value_list_A() : 
{
	LiteralType lit1 = null ;
	LiteralType lit2 = null ;
	ArrayList list = null ;
	ConstantListSet constantListSet = null ;
}
{
	//S:
	// <in_value_list> ::=
    //   <value_expression> { <comma> <value_expression> }...
    
    lit1=in_value_list_constant_A() 
    {
       if( lit1 != null ) {
       	  list = new ArrayList() ;
       	  list.add( lit1 ) ;
       }
    }
    ( <COMMA> lit2=in_value_list_constant_A()
      {
      	  if( lit2 != null ) {
      	  	 list.add( lit2 ) ;
      	  }
      	  else {
      	  	 list = null ;
      	  }
      }
    )*	
    {
    	if( list != null ) {
    		constantListSet = ConstantListSet.Factory.newInstance() ;
    		LiteralType[] literalArray = new LiteralType[ list.size() ] ;
    		constantListSet.setItemArray( (LiteralType[])list.toArray(literalArray) ) ;
    	}
    	return constantListSet ;
    }	
}

/**
 * in_value_list_constant_A
 *
 * bnf-start
 *  <in_value_list_constant> ::=
 *	       [ <plus_sign> | <minus_sign> ] <exact_numeric_literal>
 *	    |  <character_string_literal> 
 * bnf-end
 *
 */
LiteralType in_value_list_constant_A() : 
{
	AtomType at = null ;
	LiteralType lt = null ;
	Token t1 = null ;
	int possibleSignChange = 1 ;
}
{
	//A:
	// <in_value_list_constant_A> ::=
	//      [ <plus> | <minus> ] <exact_numeric_literal_S>
	//      |
	//      <character_string_literal_A> 
	(
	   (
	       ([ <PLUS_SIGN> | t1=<MINUS_SIGN> ] )
	       {
		       if( t1 != null )
		          possibleSignChange = -1 ;
	       }
	       at=exact_numeric_literal_S( possibleSignChange ) 
	   )
	   |
	   at=character_string_literal_A()
	)
	{ 
		if( at != null ) {
			lt = at.getLiteral() ;
		}
		return lt ; 
	}
}

void join_specification_S() : {}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
	(
		// refactored to...
		<ON> search_condition_S()
	    |
	    <USING> <LEFT_PAREN> column_name_list_S() <RIGHT_PAREN>
    )
}

/**
 * join_specification_A
 *
 * bnf-start
 *  <join_specification> ::= <join_condition>
 *  !! There is no accommodation for <named_columns_join>	
 * bnf-end
 *
 * bnf-start
 *  <join_condition> ::= ON <comparison_predicate>
 *  !! There is no accommodation for <search_condition>
 * bnf-end
 *
 */
ComparisonPredType join_specification_A() : 
{
	ComparisonPredType cpType = null ;
}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
	(
		<ON> cpType=comparison_predicate_A()
    )
    { return cpType ; }
}

/**
 * joined_table_S
 *
 *-bnf-start
 *- <joined_table> ::=
 *-     <cross_join>
 *-   | <qualified_join>
 *-   | <left_paren> <joined_table> <right_paren>
 *-bnf-end
 
 * bnf-start
 *  <joined_table> ::=
 *      <qualified_join>
 *    | <left_paren> <joined_table> <right_paren>
 *  !! <cross_join> has been removed. The reason is the Adql/x schema has
 *     a mandatory join condition which is inapplicable to cross joins.
 *     Probably wise in any case. 
 * bnf-end
 *
 */
JoinTableType joined_table_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "joined_table_S()" ) ;
	JoinTableType jtType = null ;
	Token t = null ;
}
{
	//S:
	// <joined_table> ::=
    //    <cross_join>
    //  | <qualified_join>
    //  | <left_paren> <joined_table> <right_paren>
	(
// 
//		LOOKAHEAD(4)//		jtType=cross_join_S()//		|
		LOOKAHEAD(4)
		jtType=qualified_join_S()
		|
		( t=<LEFT_PAREN> jtType=joined_table_S() <RIGHT_PAREN> )
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "joined_table_S()" ) ;
		return jtType ; 
	}
}

/**
 * join_type_A
 *
 * bnf-start
 *  <join_type> ::=
 *     INNER
 *   | <outer_join_type> [ OUTER ]
 *  !! There is no accommodatin for UNION
 * bnf-end
 *
 * bnf-single <outer_join_type> ::= LEFT | RIGHT | FULL
 *
 */
JointTableQualifierType join_type_A() :  
{
	JointTableQualifierType jType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	//S:
	// <join_type> ::=
    //    INNER
    //  | <outer_join_type> [ OUTER ]
    //  | UNION
	(
		// refactored
		t1=<INNER>
	    | 
	    ( t1=<LEFT> | t1=<RIGHT> | t1=<FULL> ) [ t2=<OUTER> ] 
// JL. Adql does not appear to support UNION
//	    | 
//	    t1=<UNION>
    )
    {
    	if( t1 != null ) {
    		jType = JointTableQualifierType.Factory.newInstance() ;
    		 switch ( t1.kind ) {
    			case AdqlStoXConstants.INNER :
      				jType.set( JointTableQualifierType.INNER );
      				break;
      			case AdqlStoXConstants.LEFT :
      				jType.set( JointTableQualifierType.LEFT_OUTER );
      				break;
      			case AdqlStoXConstants.RIGHT :
      				jType.set( JointTableQualifierType.RIGHT_OUTER );
      				break;
      			case AdqlStoXConstants.FULL :
      				jType.set( JointTableQualifierType.FULL_OUTER );
      				break;
//      			case AdqlStoXConstants.UNION :
//      				jType.set( JointTableQualifierType.??? );
//      				break;
    		}   		
    	}
    	return jType ;
    }
}

/**
 * match_value_S
 *
 * bnf-single <match_value> ::= <character_value_expression>
 *
 */
ScalarExpressionType match_value_S() : 
{
    if( TRACE_ENABLED ) enterTrace ( "match_value_S()" ) ;
    ScalarExpressionType seType = null ;
}
{
	//S:
	// <match_value> ::= <character_value_expression>

	seType=character_value_expression_A()
	{
	   if( TRACE_ENABLED ) exitTrace ( "match_value_S()" ) ;	
	   return seType ;
	}	
}

void match_predicate_S() : {}
{
	//S:
	// <match_predicate> ::=
    //   <row_value_constructor> MATCH [ UNIQUE ] [ PARTIAL | FULL ] <table_subquery>

	row_value_constructor_S() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] table_subquery_S() 
}

/**
 * math_function_A
 *
 * bnf-start
 *  <math_function> ::=
 *      ABS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | CEILING <left_paren> <numeric_value_expression> <right_paren> 
 *	  | DEGREES <left_paren> <numeric_value_expression> <right_paren> 
 *	  | EXP <left_paren> <numeric_value_expression> <right_paren> 
 *	  | FLOOR <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG <left_paren> <numeric_value_expression> <right_paren> 
 *	  | PI <left_paren><right_paren> 
 *	  | POWER <left_paren> <numeric_value_expression> <comma> <unsigned_integer> <right_paren> 
 *	  | RADIANS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQUARE <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQRT <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG10 <left_paren> <numeric_value_expression> <right_paren> 
 *	  | RAND <left_paren> [ <numeric_value_expression> ] <right_paren> 
 *	  | ROUND <left_paren> <numeric_value_expression> <right_paren> 
 *	  | TRUNCATE <left_paren> <numeric_value_expression> <right_paren> 
 *  !! ADQL specific.
 * bnf-end
 *
 */
MathFunctionType math_function_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "math_function_A()" ) ;
	MathFunctionType mfType = null ; 
	ScalarExpressionType arg1 = null ;
	Token t = null ;
	Token t2 = null ;
}
{
	(
		( t=<ABS> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<CEILING> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<DEGREES> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<EXP> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<FLOOR> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<LOG> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<PI> <LEFT_PAREN><RIGHT_PAREN> )
		|
		( t=<POWER> <LEFT_PAREN> arg1=numeric_value_expression_S() <COMMA> t2=<UNSIGNED_INTEGER> <RIGHT_PAREN> )
		|
		( t=<RADIANS> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<SQUARE> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<SQRT> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<LOG10> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<RAND> <LEFT_PAREN> [ arg1=numeric_value_expression_S() ] <RIGHT_PAREN> )
		|
		( t=<ROUND> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
		|
		( t=<TRUNCATE> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN> )
	)
	{
	   if( t != null ) {
	   	  mfType = MathFunctionType.Factory.newInstance() ;
	   	  mfType.setName( MathFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
	   	  if( arg1 != null ) {
	   	  	 SelectionItemType[] argArray ;
	   	  	 if( t.kind != AdqlStoXConstants.POWER ) {
	   	        argArray = new SelectionItemType[1] ;
	   	        argArray[0] = arg1 ;
	   	  	 }
	   	  	 else {
	   	  	 	argArray = new SelectionItemType[2] ;
	   	  	 	argArray[0] = arg1 ;
	   	  	 	AtomType atomType = AtomType.Factory.newInstance() ;
	   	  	 	IntegerType intType = IntegerType.Factory.newInstance() ;
	   	  	 	intType.setValue( new Long( t2.image ).longValue() ) ;
	   	  	 	atomType.setLiteral( intType ) ;
	   	  	 	argArray[1] = atomType ;
	   	  	 }
	   	     mfType.setArgArray( argArray ) ;
	   	  }
	   }
	   if( TRACE_ENABLED ) exitTrace ( "math_function_A()" ) ;
	   return mfType ;
	}
}

void null_predicate_S() : {}
{
	//S:
	// <null_predicate> ::= 
	//   <row_value_constructor> IS [ NOT ] NULL

	row_value_constructor_S() <IS> [ <NOT> ] <NULL>	
}

/**
 * numeric_primary_S
 *
 * bnf-start
 *  <numeric_primary> ::=
 *      <value_expression_primary>
 *    | <numeric_value_function>
 * bnf-end
 *
 */
ScalarExpressionType numeric_primary_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "numeric_primary_S()" ) ;
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <numeric_primary> ::=
    //    <value_expression_primary>
    //  | <numeric_value_function>
    
    // Refactored to...
	( 
	  seType=numeric_value_function_A()	
	  |
	  seType=value_expression_primary_A()
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "numeric_primary_S()" ) ;
		return seType ; 
	} 
	
}

/**
 * numeric_value_expression_S
 *
 * bnf-start
 *  <numeric_value_expression> ::=
 *      <term>
 *    | <numeric_value_expression> <plus_sign> <term>
 *    | <numeric_value_expression> <minus_sign> <term>
 * bnf-end
 *
 */
ScalarExpressionType numeric_value_expression_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "numeric_value_expression_S()" ) ;
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	//S:
	// <numeric_value_expression> ::=
    //    <term>
    //  | <numeric_value_expression> <plus_sign> <term>
    //  | <numeric_value_expression> <minus_sign> <term>
	
	// refactored to...
	( seType=term_S() exprPairs=numericValueExpressionList() )
	{ 
		try {
			if( exprPairs == null ) {
		   	   return seType ; 
		    }
		    else {
		       ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		       args[0] = seType ;
		       args[1] = exprPairs[1] ;
		       BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		       beType.setArgArray( args ) ;
		       return beType ;
		    }
		}
		finally {
           if( TRACE_ENABLED ) exitTrace ( "numeric_value_expression_S()" ) ;		
		}		
	}
}

ScalarExpressionType[] numericValueExpressionList() : 
{
	if( TRACE_ENABLED ) enterTrace ( "numericValueExpressionList()" ) ;
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;
	Token t = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=numericValueExpressionSingleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}
		if( TRACE_ENABLED ) exitTrace ( "numericValueExpressionList()" ) ;		
		return retExprPairs ;
	}
}

ScalarExpressionType[] numericValueExpressionSingleton() :
{
	if( TRACE_ENABLED ) enterTrace ( "numericValueExpressionSingleton()" ) ;	
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<PLUS_SIGN> | t=<MINUS_SIGN> ) seType=numeric_value_expression_S()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;		
			beType = BinaryExprType.Factory.newInstance() ;
			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		if( TRACE_ENABLED ) exitTrace ( "numericValueExpressionSingleton()" ) ;	
		return retPairs ;
	}
}

/**
 * numeric_value_function_A
 *
 * bnf-start
 *  <numeric_value_function> ::= <trig_function> | <math_function>	
 *  !! There is no accommodation for <position_expression>,
 *     <extract_expression> or <length_expression>
 * bnf-end
 *
 */
ScalarExpressionType numeric_value_function_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "numeric_value_function_A()" ) ;
	ScalarExpressionType seType = null ;
}
{
	//S:
	//<numeric_value_function> ::=
    //   <position_expression>
    // | <extract_expression>
    // | <length_expression>

	(
		// JBL ADQL adaptation
		seType=trig_function_A()
		|
		seType=math_function_A()	
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "numeric_value_function_A()" ) ;
		return seType ; 
	}
}

ScalarExpressionType numeric_value_function_fragment() : 
{
	ScalarExpressionType set = null ;
}
{
	set=numeric_value_function_A() <SEMICOLON>
	{ return set ; }
}

/**
 * order_by_clause_A
 *
 * bnf-start
 *  <order_by_clause> ::= ORDER BY <sort_specification_list>
 * bnf-end
 *
 * bnf-start
 *  <sort_specification_list> ::=
 *      <sort_specification> [ { <comma> <sort_specification> }... ]
 * bnf-end 
 *
 * bnf-start
 *  <sort_specification> ::=
 *      <sort_key> [ <ordering_specification> ]
 *  !! There is no accommodation for <collate_clause>
 * bnf-end
 *
 * bnf-start
 *  <sort_key> ::= <value_expression>
 *  !! This is different from SQL92 which uses
 *     <column_name> | <unsigned_integer>
 * bnf-end 
 *
 * bnf-single <ordering_specification> ::= ASC | DESC
 */
OrderExpressionType order_by_clause_A() : 
{
	OrderExpressionType oeType = null ;
	OrderType orderType = null ;
	OrderType[] orderArray = null ;
	ArrayList orderList = null ;
} 
{
	//S:
	//	ORDER BY <sort_specification_list>
	//
	// !! with the following expansions
	//
	// <sort_specification_list> ::=
	//    <sort_specification> [ { <comma> <sort_specification> }... ]
	//
	// <sort_specification> ::=
	//    <sort_key> [ <collate_clause> ] [ <ordering_specification> ]
	//
	// <sort_key> ::=
	//      <column_name>
	//    | <unsigned_integer>
	//
	// <ordering_specification> ::= ASC | DESC
	
	// As opposed to the above, the following is implemented...
	// This seems inadequate. Ie: the use of ScalarExpression in the Xml Schema, and hence value_expression()
	//<ORDERBY> value_expression() ( <ASC> | <DESC> ) ( <COMMA> value_expression() ( <ASC> | <DESC> ) )*
	( <ORDERBY> orderType=orderBySingleton() orderList=orderByList() )
	{
		if( orderType != null ) {
			oeType = OrderExpressionType.Factory.newInstance() ;
			if( orderList != null ) {
				orderList.add( 0, orderType ) ;	
				orderArray = new OrderType[ orderList.size() ] ;
				orderArray = (OrderType[])orderList.toArray( orderArray ) ;
			}
			else {
				orderArray = new OrderType[1] ;
				orderArray[0] = orderType ;			
			}	
			oeType.setItemArray( orderArray ) ;
		}
		return oeType ;
	}
}

OrderExpressionType order_by_clause_fragment() : 
{
	OrderExpressionType oet = null ;
} 
{
	oet=order_by_clause_A() <SEMICOLON>
	{ return oet ; }
}

OrderType orderBySingleton() : 
{
	OrderType orderType = null ;
	ScalarExpressionType se = null ;
	Token t = null ;
	OrderOptionType optionType = null ;
	OrderDirectionType.Enum direction = null ;
}
{
	( se=value_expression_A() [ t=<ASC> | t=<DESC> ] )
	{
		if( se!=null ) {
			if( t == null ) {
				direction = OrderDirectionType.ASC ;
			}
			else {
				direction = OrderDirectionType.Enum.forString( t.image.toUpperCase() ) ;
			}
			optionType = OrderOptionType.Factory.newInstance() ;
			optionType.setDirection( direction ) ;	
			orderType = OrderType.Factory.newInstance() ;
			orderType.setExpression( se ) ;
			orderType.setOrder( optionType ) ;
		}
		return orderType ;
	}
}

ArrayList orderByList() : 
{
	ArrayList list = null ;
	OrderType orderType = null ;
}
{
	( 
		<COMMA> 
		orderType=orderBySingleton() 
		{
			if( orderType != null ) {
				if( list == null ) {
					list = new ArrayList() ;
				}
				list.add( orderType ) ;	
			}	
		}
	)*
	{ return list ; }
}

void overlaps_predicate_S() : {}
{
	//S:
	// <overlaps_predicate> ::=
    //   <row_value_constructor_1> OVERLAPS <row_value_constructor_2>
    //
    // <row_value_constructor_1> ::= <row_value_constructor>
    // <row_value_constructor_2> ::= <row_value_constructor>

	row_value_constructor_S() <OVERLAPS> row_value_constructor_S()	
}

/**
 * pattern_A
 *
 * bnf-start
 *  <pattern> ::= <character_string_literal>
 *  !! SQL92 uses <character_value_expression>
 * bnf-end
 *
 */
AtomType pattern_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "pattern_A()" ) ;
	AtomType at = null ;
}
{
	//S:
	//   <pattern> ::= <character_value_expression>

	at=character_string_literal_A()
	{
		if( TRACE_ENABLED ) exitTrace ( "pattern_A()" ) ;
		return at ;
	}	
}

SearchType predicate_fragment() :
{
   SearchType st = null ;
}
{
   ( st=predicate_A() <SEMICOLON> )
   { return st ; }
}

/**
 * predicate_A
 *
 * bnf-start
 *  <predicate> ::=
 *     <comparison_predicate>
 *   | <between_predicate>
 *   | <in_predicate>
 *   | <like_predicate>
 *  !! ADQL does not support the following:
 *     <null_predicate>, <quantified_comparison_predicate>,
 *     <exists_predicate>, <unique_predicate>,
 *     <match_predicate>, <overlaps_predicate>.
 *     Also, <region_predicate> has yet to be folded in.
 * bnf-end
 *
 */
SearchType predicate_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "predicate_A()" ) ;
	SearchType searchType = null ;
}
{
	//S:
	//    <comparison_predicate>
	//    | <between_predicate>
	//    | <in_predicate>
	//    | <like_predicate>
	//    | <null_predicate>
	//    | <quantified_comparison_predicate>
	//    | <exists_predicate>
	//    | <unique_predicate>
	//    | <match_predicate>
	//    | <overlaps_predicate>
	(
//		searchType = region_predicate_A()    
//		|
 		LOOKAHEAD(5)
		searchType=comparison_predicate_A()
	    | 
	    LOOKAHEAD(5)
	    searchType=between_predicate_A()
	    |
	    LOOKAHEAD(5)
	    searchType=in_predicate_A()
	    |
	    searchType=like_predicate_A()
//	    | 
// adql does not support the null predicate!
//	    LOOKAHEAD(3)
//	    nullPredicate()
//	    | 
// adql does not support quantified comparisons
//	    LOOKAHEAD(3)
//		quantifiedComparisonPredicate()
//	    |
// adql does not support EXISTS 
//	    existsPredicate()
//	    | 
// adql does not support UNIQUE
//	    uniquePredicate()
//	    | 
// adql does not support match
//	    LOOKAHEAD(3)
//	    matchPredicate()
//	    | 
// adql does not support overlap
//	    overlapsPredicate()
//    	
        
    )
    { 
    	if( TRACE_ENABLED ) exitTrace ( "predicate_A()" ) ;
    	return searchType ; 
    }
}

/**
 * qualified_join_S
 *
 * bnf-start
 *  <qualified_join> ::=
 *      <table_reference> [ NATURAL ] [ <join_type> ] JOIN
 *      <table_reference> [ <join_specification> ]
 * bnf-end
 *
 */
JoinTableType qualified_join_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "qualified_join_S()" ) ;
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
	JointTableQualifierType jtqType = null ;
	ComparisonPredType cpType = null ;
}
{
	//S:
	// <qualified_join> ::=
    //    <table_reference> [ NATURAL ] [ <join_type> ] JOIN
    //    <table_reference> [ <join_specification> ]
	
	(
		fType1=tableReferenceBarJoinedTable() 
		[ <NATURAL> ] 
		jtqType=join_type_A() 
		<JOIN> 
		fType2=table_reference_A() 
		[ LOOKAHEAD(3) cpType=join_specification_A() ]
	)
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	      jtType.xsetQualifier( jtqType ) ;
	      if( cpType != null ) {
	      		jtType.setCondition( cpType ) ;
	      }
	   }
	   if( TRACE_ENABLED ) exitTrace ( "qualified_join_S()" ) ;
	   return jtType ;	
	}
}

/**
 * qualified_name_A
 *
 * bnf-start
 *  <qualified_name> ::= <identifier>
 *  !! Not sure this is adequate
 *     SQL92 has [ <schema_name> <period> ] <qualified_identifier>
 * bnf-end
 *
 */
String qualified_name_A() : 
{
	String retValue ;
} 
{
	//S:
	// <qualified_name> ::=
    //   [ <schema_name> <period> ] <qualified_identifier>

	retValue = identifier_A()
	{ return retValue ; }	
}

/**
 * 
 *
 * bnf-start
 *  <qualifier> ::= <table_name> 
 *  !! SQL92 also has <correlation_name>
 * bnf-end
 *
 */
String qualifier_A() : 
{	
	String retValue ;
}
{
	//S:
	// <qualifier> ::=
    //    <table_name> 
    //  | <correlation_name>

	// Foreshortened
	retValue=table_name_A()
	{ return retValue ; }
}

/**
 * 
 *
 * bnf-start
 *  <query_specification> ::=
 *      SELECT [ <set_quantifier> ] [ <set_limit> ] <select_list> <table_expression>
 * bnf-end
 *
 * bnf-start
 *  <table_expression> ::=
 *      <from_clause>
 *      [ <where_clause> ]
 *      [ <group_by_clause> ]
 *      [ <having_clause> ]
 *      [ <order_by_clause> ]
 * !! ADQL adds <order_by_clause>
 * bnf-end 
 *
 */
SelectType query_specification_A() : 
{
    if( TRACE_ENABLED ) enterTrace ( "query_specification_A()" ) ;
	SelectType st = null ;
	SelectionListType listType = null ;
	SelectionLimitType limitType = null ;
	SelectionOptionType optionType = null ;
	FromType fromType = null ;
	WhereType whereType = null ;
	GroupByType gbType = null ;
	HavingType havingType = null ;
	OrderExpressionType oeType = null ;
	Token t = null ;
}
{ 
	(
	//S:
	// SELECT [ <set_quantifier> ] <select_list> <table_expression>
	//
	// <table_expression> ::=
	//    <from_clause>
    //    [ <where_clause> ]
    //    [ <group_by_clause> ]
    //    [ <having_clause> ]
	
	//A:
	// Refactored to include <set-limit> and to bring up <table_expression> 
	// into this method. <table_expression> also now includes <order_by_clause>
		(
		   t=<SELECT>
		   { 
		   	  if( t!= null ) {
		   	     st = SelectType.Factory.newInstance() ;
		   	  }
		   }
		)
		[ 
		   optionType=set_quantifier_S() 
		   {
		   	  if( optionType!= null ) {
		   	     st.setAllow( optionType ) ;	
		   	  }
		   }
		]
		[ 
		   limitType=set_limit_A() 
		   {
		   	  if( limitType != null ) {
				 st.setRestrict( limitType ) ;	
			  }	   	
		   }
		] 
		listType=select_list_S() 
		{
			if( listType != null ) {
				st.setSelectionList( listType ) ;	
			}						
		}
		fromType=from_clause_S() 
		{
			if( fromType != null ) {
				st.setFrom( fromType ) ;	
			}		
		}	
		[ 
		    LOOKAHEAD(3) 
		    whereType=where_clause_S()
		    {
		    	if( whereType != null ) {
		    		st.setWhere( whereType ) ;
		    	}
		    }
		] 		
		[ 
		    LOOKAHEAD(3) 
		    gbType=group_by_clause_S() 
		    {
		    	if( gbType != null ) {
		    		st.setGroupBy( gbType ) ;
		    	}
		    }
		] 		
		[ 
		    LOOKAHEAD(3) 
		    havingType=having_clause_S() 
		    {
		    	if( havingType != null ) {
		    		st.setHaving( havingType ) ;
		    	}
		    }
		] 		
		[ 
		    LOOKAHEAD(3) 
		    oeType=order_by_clause_A() 
		    {
		    	if( oeType != null ) {
		    		st.setOrderBy( oeType ) ;
		    	}
		    }
		]	
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "query_specification_A()" ) ;
		return st  ; 
	}
}

SelectType query_specification_fragment() : 
{
	SelectType st = null ;
}
{ 
	st=query_specification_A() <SEMICOLON>
	{ return st ; }
}

RegionSearchType region_predicate_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "region_predicate_A()" ) ;
	RegionSearchType st = null ;
	RegionType rt = null ;
	Token t = null ;
}
{
	//A:
	// <region> <left_paren> <region_specification_A> <right_paren>
	<REGION> <LEFT_PAREN> rt=region_specification_A() t=<RIGHT_PAREN>
	{ 
		if( t != null ) {
		   st = RegionSearchType.Factory.newInstance() ;	
		   st.setRegion( rt ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "region_predicate_A()" ) ;
		return st ; 
	}
	
}

RegionType region_specification_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "region_specification_A()" ) ;
    RegionType rt = null ;
}
{
	(
		rt=circle_region_A() 
		|
		rt=ellipse_region_A()
		|
		polygon_region_A()
		|
		sector_region_A()
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "region_specification_A()" ) ;
		return rt ; 
	}
}

CircleType circle_region_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "circle_region_A()" ) ;
	String coordSystem = null ;
	Object[] radiusParams = null ;
	List coords = null ;
	CircleType circleType = null ;
}
{
	(
	<CIRCLE> coordSystem=coord_system_A()
	<CENTER> <EQUALS_OPERATOR> coords=coords_2_A() 
	<RADIUS> <EQUALS_OPERATOR> radiusParams=circle_radius_A()
	)	
	{
		if( radiusParams != null ) {
			circleType = CircleType.Factory.newInstance() ;
			circleType.setCenter( coords ) ;
			circleType.setRadius( ((Double)radiusParams[0]).doubleValue() ) ;
			circleType.setCoordSystemId( coordSystem ) ;
			circleType.setUnit( (PosUnitType.Enum)radiusParams[1] ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "circle_region_A()" ) ;
		return circleType ;
	}
}

EllipseType ellipse_region_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "ellipse_region_A()" ) ;
	Double minorRadius = null ;
	Double majorRadius = null ;
	List coords = null ;
	EllipseType ellipseType = null ;
	Object[] radiusParams = null ;
	String coordSystem = null ;
	Object[] angleParams = null ;
}
{
	(
	<ELLIPSE> coordSystem=coord_system_A()
	<CENTER> <EQUALS_OPERATOR> coords=coords_2_A() 
	<RADII> <EQUALS_OPERATOR> radiusParams=ellipse_radius_A()
	<POS_ANGLE> <EQUALS_OPERATOR> angleParams=ellipse_angle_A()
	)
	{
		if( radiusParams != null ) {
			ellipseType = EllipseType.Factory.newInstance() ;
			ellipseType.setCenter( coords ) ;
			ellipseType.setMinorRadius( ((Double)radiusParams[0]).doubleValue() ) ;
			ellipseType.setRadius( ((Double)radiusParams[1]).doubleValue() ) ;
			ellipseType.setCoordSystemId( coordSystem ) ;
			ellipseType.setUnit( (PosUnitType.Enum)radiusParams[2] ) ;
			ellipseType.setPosAngle( ((Double)angleParams[0]).doubleValue() ) ;
			ellipseType.setPosAngleUnit( (AngleUnitType.Enum)angleParams[1] ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "ellipse_region_A()" ) ;
		return ellipseType ;
	}
}

void polygon_region_A() : 
{
}
{
	<POLYGON> 
}

void sector_region_A() : 
{
}
{
	<SECTOR>
}

void convex_region_A() : 
{
}
{
	<CONVEX>	
}
void convex_hull_region_A() : 
{
}
{
	<CONVEX_HULL> 	
}//|   < CONVEX_HULL : "convex hull" >//|   < UNION : "union" >//|   < INTERSECTION : "intersection" >

String coord_system_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "coord_system_A()" ) ;
	String cs = null ;
	Token t1 = null ;
}
{
	(
	   <COORD_SYSTEM> <EQUALS_OPERATOR> t1=<REGULAR_IDENTIFIER> 
    )
	{	
		if( t1 !=  null ) {
		   cs = t1.image ;
	    }	
	    if( TRACE_ENABLED ) exitTrace ( "coord_system_A()" ) ;
		return cs ;		
	}
}

void row_subquery_S() : {} 
{
	//S:
	// <row_subquery> ::= <subquery>
	subquery_S()	
}

Double double_numeric_literal_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "double_numeric_literal_A()" ) ;
	Token s = null ;
	Token t = null ;
	Double dnl = null ;
}
{
	( [ <PLUS_SIGN> | s=<MINUS_SIGN> ]  t=<EXACT_NUMERIC_LITERAL> | t=<UNSIGNED_INTEGER> )
	{
		if( t != null ) {
           dnl = new Double( (s!=null ? '-' : '+' ) + t.image ) ;		
		}
		if( TRACE_ENABLED ) exitTrace ( "double_numeric_literal_A()" ) ;
		return dnl ;
	}
}

List coords_2_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "coords_2_A" ) ;
	Double coord1 = null ;
	Double coord2 = null ;
	Token t = null ;
	ArrayList list = null ;
}
{
    ( <LEFT_PAREN> coord1=double_numeric_literal_A() <COMMA> coord2=double_numeric_literal_A() t=<RIGHT_PAREN> )
    {
    	if( t != null ) {
    		list = new ArrayList( 2 ) ;
    		list.add( coord1 ) ;
    		list.add( coord2 ) ;
    	}
    	if( TRACE_ENABLED ) exitTrace ( "coords_2_A" ) ;
    	return list ;
    }
}

Object[] circle_radius_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "circle_radius_A" ) ;
	Double rad = null ;
	String putString = null ;
	PosUnitType.Enum unitType ;
	Object[] radiusParams = null ;
}
{
	(
	    rad=double_numeric_literal_A() 
	    | 
	    ( <LEFT_PAREN> rad=double_numeric_literal_A() <COMMA> putString=pos_unit_type_A() <RIGHT_PAREN> )
	)
	{
	   if( rad !=  null ) {
		   radiusParams = new Object[2] ;
		   if( putString == null ) {
			   unitType = PosUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = PosUnitType.Enum.forString( putString ) ;
		   }
		   radiusParams[0] = rad ;
		   radiusParams[1] = unitType ;
	   }
	   if( TRACE_ENABLED ) exitTrace ( "circle_radius_A" ) ;
	   return radiusParams ;		
    }
}

Object[] ellipse_radius_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "ellipse_radius_A" ) ;
	Double minorRad = null ;
	Double majorRad = null ;
	PosUnitType.Enum unitType = null ;
	String putString = null ;
	Object[] ellipseParams = null ;
}
{
	( <LEFT_PAREN> 
	    minorRad=double_numeric_literal_A() <COMMA> majorRad=double_numeric_literal_A() 
	    ( <COMMA> putString=pos_unit_type_A() )?
	  <RIGHT_PAREN> 
	)
	{
	   if( majorRad !=  null ) {
		   ellipseParams = new Object[3] ;
		   if( putString == null ) {
			   unitType = PosUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = PosUnitType.Enum.forString( putString ) ;
		   }
		   ellipseParams[0] = minorRad ;
		   ellipseParams[1] = majorRad ;
		   ellipseParams[2] = unitType ;
	   }
	   if( TRACE_ENABLED ) exitTrace ( "ellipse_radius_A" ) ;
	   return ellipseParams ;		
    }
}

String pos_unit_type_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "pos_unit_type_A" ) ;
	String putString = null ;
	Token t = null ;
}
{
	( t=<DEG> | t=<DEG_DEG_M> | t=<RAD> | t=<H> | t=<ARCMIN> | t=<ARCSEC> |   
	t=<M> | t=<KM> | t=<MM> | t=<AU> | t=<PC> | t=<KPC> | t=<MPC> | t=<LYR> )
	{ 
		if( t != null ) {
			putString = t.image ;
		}
		if( TRACE_ENABLED ) exitTrace ( "pos_unit_type_A" ) ;
		return putString ;
	}	
}

String pos_angle_type_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "pos_angle_type_A" ) ;
	String patString = null ;
	Token t = null ;
}
{
	( t=<DEG> | t=<RAD> | t=<H> | t=<ARCMIN> | t=<ARCSEC> )
	{ 
		if( t != null ) {
			patString = t.image ;
		}
		if( TRACE_ENABLED ) exitTrace ( "pos_angle_type_A" ) ;
		return patString ;
	}	
}

Object[] ellipse_angle_A() :
{
	if( TRACE_ENABLED ) enterTrace ( "ellipse_angle_A" ) ;
	Double angle = null ;
	String patString = null ;
	AngleUnitType.Enum unitType ;
	Object[] angleParams = null ;
}
{
	(
	    angle=double_numeric_literal_A() 
	    | 
	    ( <LEFT_PAREN> angle=double_numeric_literal_A() <COMMA> patString=pos_angle_type_A() <RIGHT_PAREN> )
	)
	{
	   if( angle !=  null ) {
		   angleParams = new Object[2] ;
		   if( patString == null ) {
			   unitType = AngleUnitType.Enum.forString("") ;
		   }
		   else {
			   unitType = AngleUnitType.Enum.forString( patString ) ;
		   }
		   angleParams[0] = angle ;
		   angleParams[1] = unitType ;
	   }
	   if( TRACE_ENABLED ) exitTrace ( "ellipse_angle_A" ) ;
	   return angleParams ;		
    }
}

ScalarExpressionType row_value_constructor_S() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <row_value_constructor> ::=
    //     <row_value_constructor_element>
    //  | <left_paren> <row_value_constructor_list> <right_paren>
    //  | <row_subquery>

	(
		LOOKAHEAD(3)
		row_value_constructor_element_S()
	    | 
	    LOOKAHEAD(2)
	    <LEFT_PAREN> row_value_constructor_list_S() <RIGHT_PAREN>
	    | 
	    row_subquery_S()
	 )
	 { return seType ; }
}

ScalarExpressionType row_value_constructor_element_S() : 
{
	ScalarExpressionType seType = null ;
} 
{
	//S:
	//  <row_value_constructor_element> ::=
    //     <value_expression>
    //   | <null_specification>
    //   | <default_specification>

	seType=value_expression_A()
// adql has nothing to support the embedding of keywords...
//    | 
//    <NULL>
//    | 
//    <SQL_DEFAULT>

	{ return seType ; }
}

void row_value_constructor_list_S() : {}
{
	//S:
	//  <row_value_constructor_list> ::=
    //    <row_value_constructor_element> [ { <comma> <row_value_constructor_element> }... ]

	row_value_constructor_element_S() ( <COMMA> row_value_constructor_element_S() ) *
}

void scalar_subquery_S() : {}
{
	//S:
	// <scalar_subquery> ::= <subquery>
	subquery_S()
}

/**
 * 
 *
 * bnf-start
 *  <search_condition> ::=
 *      <boolean_term>
 *    | <search_condition> OR <boolean_term>
 * bnf-end
 *
 */
SearchType search_condition_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "search_condition_S" ) ;
	SearchType st1 = null ;
	SearchType st2 = null ;
	SearchType retval = null ;

}
{
	//S:
	// <search_condition> ::=
    //    <boolean_term>
    //  | <search_condition> OR <boolean_term>

	// refactored
	( st1=boolean_term_S() st2=booleanTermList() )
	{
		if( st2 == null ) {
		   retval = st1 ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st1 ;
		   conditionArray[1] = st2 ;
		   UnionSearchType usType = UnionSearchType.Factory.newInstance() ;
		   usType.setConditionArray( conditionArray ) ;
		   retval = usType ;
		}
		if( TRACE_ENABLED ) exitTrace ( "search_condition_S" ) ;	
		return retval ;
	}
}

SearchType booleanTermList() : 
{
	if( TRACE_ENABLED ) enterTrace ( "booleanTermList" ) ;
	Stack stack = null ;
	SearchType st = null ;
}
{
	( 
	  LOOKAHEAD(3)
	  st=booleanTermSingleton() 
	  { if( stack == null )
	  	   stack = new Stack() ;
	  	stack.push( st ) ;
	  } 
	)*
	{ 
		if( stack != null ) {
			UnionSearchType heldOr = null ;
			SearchType[] conditions = new SearchType[2] ;
			while( stack.empty() == false ) {
				st = (SearchType)stack.pop() ;
				if( heldOr != null ) {
					conditions[0] = st ;
					conditions[1] = heldOr ;
					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;
					orType.setConditionArray( conditions ) ;
					heldOr = orType ;
				}
				else if( stack.empty() == false  ) {
					conditions[0] = (SearchType)stack.pop() ;
					conditions[1] = st ;
					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;
					orType.setConditionArray( conditions ) ;
					heldOr = orType ;
				}
			}
			if( heldOr != null )
				st = heldOr ; 
		}	
		if( TRACE_ENABLED ) exitTrace ( "booleanTermList" ) ;	
		return st ;
	}
}

SearchType booleanTermSingleton() :
{
	if( TRACE_ENABLED ) enterTrace ( "booleanTermSingleton" ) ;
	SearchType st = null ;
}
{
	( <OR> st=boolean_term_S() )
	{ 
		if( TRACE_ENABLED ) exitTrace ( "booleanTermSingleton" ) ;
		return st ; 
	}
}

/**
 * select_list_S
 *
 * bnf-start
 *  <select_list> ::=
 *      <asterisk>
 *    | <select_sublist> [ { <comma> <select_sublist> }... ]
 * bnf-end
 *
 */
SelectionListType select_list_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "select_list_S()" ) ;
	ArrayList itemList = new ArrayList() ;
	SelectionListType slType = SelectionListType.Factory.newInstance() ;
}
{
	//S:
	// <select_list> ::=
	//   <asterisk>
    // | <select_sublist> [ { <comma> <select_sublist> }... ]
	(
		allSelectionItem( itemList ) 
		| 
		( select_sublist_A( itemList ) ( <COMMA> select_sublist_A( itemList ) )* )
	)
	{
		if( itemList.size() > 0 ) {
			SelectionItemType[] itemArray = new SelectionItemType[ itemList.size() ] ;	
			slType.setItemArray( (SelectionItemType[])itemList.toArray(itemArray) ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "select_list_S()" ) ;
		return slType ;	
	}
}

SelectionListType select_list_fragment() : 
{
	SelectionListType slt = null ;
}
{
	slt=select_list_S() <SEMICOLON>
	{ return slt ; }
}

void allSelectionItem( ArrayList itemList ) : {}
{
	<ASTERISK>
	{ itemList.add( AllSelectionItemType.Factory.newInstance() ) ; }
}

/**
 * 
 *
 * bnf-start
 *  <select_sublist> ::=
 *      <derived_column>
 *  !! SQL92 also has <qualifier> <period> <asterisk>
 * bnf-end
 *
 */
void select_sublist_A( ArrayList itemList ) : 
{ 
	if( TRACE_ENABLED ) enterTrace ( "select_sublist_A()" ) ;
	SelectionItemType siType = null ;
}
{   
	//S:
	// <select_sublist> ::= <derived_column> | <qualifier> <period> <asterisk>
    
	siType=derived_column_S()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "select_sublist_A()" ) ;
		itemList.add( siType ) ; 
	}			
}

/**
 * derived_column_S
 *
 * bnf-start
 *  <derived_column> ::= <value_expression> [ <as_clause> ]
 *  !! See footnote (1) about the <as_clause> within ADQL/x
 * bnf-end
 * bnf-start
 *  <as_clause> ::= [ AS ] <column_name>
 *  !! See footnote (1) about the <as_clause> within ADQL/x
 * bnf-end
 */
SelectionItemType derived_column_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "derived_column_S()" ) ;
	ScalarExpressionType seType = null ;
	SelectionItemType retVal = null ;
	String aliasName = null ;
}
{
	//S:
	// <derived_column> ::= <value_expression> [ <as_clause> ]
	// <as_clause> ::= [ AS ] <column_name>
	
	( seType=value_expression_A() [ [<AS>] aliasName=column_name_S() ] )	
	{ 
		if( aliasName != null ) {
			AliasSelectionItemType asiType = AliasSelectionItemType.Factory.newInstance() ;
			asiType.setAs( aliasName ) ;
			asiType.setExpression( seType ) ;
			retVal = asiType ;	
		}
		else {
		    retVal = seType ;	
		}
		if( TRACE_ENABLED ) exitTrace ( "derived_column_S()" ) ;
		return retVal ; 
	}	
}


SelectionItemType derived_column_fragment() : 
{
	SelectionItemType sit = null ;
}
{
    sit=derived_column_S() <SEMICOLON>
    { return sit ; }
}


/**
 * set_function_specification_S
 *
 * bnf-start
 *  <set_function_specification> ::=
 *      COUNT <left_paren> <asterisk> <right_paren>
 *    | <general_set_function>
 * bnf-end
 *
 */
AggregateFunctionType set_function_specification_S() : 
{
	AggregateFunctionType afType = null ;
	Token t = null ;
}
{
	//S:
	//  <set_function_specification> ::=
    //     COUNT <left_paren> <asterisk> <right_paren>
    //   | <general_set_function>

	(
		LOOKAHEAD(3)
		( t=<COUNT> <LEFT_PAREN> <ASTERISK> <RIGHT_PAREN> ) 
		|
		afType=general_set_function_A()
	)
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.COUNT ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			AtomType atomType = AtomType.Factory.newInstance() ;
			StringType star = StringType.Factory.newInstance() ;
			star.setValue( "*" ) ;
			atomType.setLiteral( star ) ;
			argArray[0] = atomType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }
}

AggregateFunctionType set_function_specification_fragment() : 
{
	AggregateFunctionType aft = null ;
}
{
	set_function_specification_S() <SEMICOLON>
	{ return aft ; }
}

/**
 * 
 *
 * bnf-start
 *  <set_limit> ::= TOP <unsigned_integer>
 *  !! SQL92 has no equivalent construct
 * bnf-end
 *
 */
SelectionLimitType set_limit_A() : 
{ 
	SelectionLimitType sl = null ;
	Token t1 = null ;
}
{
	// There is no equivalent in the SQL/92 standard
	//
	<TOP> t1=<UNSIGNED_INTEGER>
	{ 
		if( t1 != null ) {
			sl = SelectionLimitType.Factory.newInstance() ;
			sl.setTop( ( new Integer( t1.image )).intValue() ) ;
		}
	return sl ;	
	}
}

SelectionLimitType set_limit_fragment() : 
{ 
	SelectionLimitType slt = null ;
}
{
	slt=set_limit_A() <SEMICOLON>
	{ return slt ; }
}

/**
 * set_quantifier_S
 *
 * bnf-single <set_quantifier> ::= DISTINCT | ALL
 *
 */
SelectionOptionType set_quantifier_S() : 
{
	SelectionOptionType selectionOption = null ;
	Token t ;
}
{
	//S:
	// <set_quantifier> ::= DISTINCT | ALL
	//
	( t=<DISTINCT> | t=<ALL> )
	{ 	
		if( t != null ) {
			selectionOption = SelectionOptionType.Factory.newInstance() ;
			if( t.kind == AdqlStoXConstants.ALL ) {
				selectionOption.setOption( AllOrDistinctType.ALL ) ;
			}
			else {
				selectionOption.setOption( AllOrDistinctType.DISTINCT ) ;
			}
		}
		return selectionOption ;
	}
}

SelectionOptionType set_quantifier_fragment() : 
{
	SelectionOptionType sot = null ;
}
{
	sot=set_quantifier_S() <SEMICOLON>
	{ return sot ; }
}

void single_datetime_field_S() : {}
{
	//S:
	//  <single_datetime_field> ::=
    //     <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]
    //   | SECOND [ <left_paren> <interval_leading_field_precision> [ <comma> <interval_fractional_seconds_precision> ] <right_paren> ]

	nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
    | 
    <SECOND> [ <LEFT_PAREN> interval_leading_field_precision_S() [ <COMMA> interval_fractional_seconds_precision_S() ] <RIGHT_PAREN> ]
}

void start_field_S() : {}
{
	//S:
	//  <start_field> ::=
    //    <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]

    nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
}

/**
 * 
 *
 * bnf-start
 *  <string_value_expression> ::=
 *      <character_value_expression>
 *  !! SQL92 also supports <bit_value_expression>
 * bnf-end
 *
 */
ScalarExpressionType string_value_expression_A() :
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <string_value_expression> ::=
    //    <character_value_expression>
    //  | <bit_value_expression>

	seType=character_value_expression_A()
	{ return seType ; }
}

/**
 * subquery_S
 *
 */
SearchType subquery_S() : 
{
	SearchType st = null ;
}
{
	//S:
	//  <subquery> ::= <left_paren> <query_expression> <right_paren>
	<LEFT_PAREN> query_expression_S() <RIGHT_PAREN>
	{ return st ; }		
}


void quantified_comparison_predicate_S() : {}
{
	//S:
	// <quantified_comparison_predicate> ::=
    //    <row_value_constructor> <comp_op> <quantifier> <table_subquery>

	row_value_constructor_S() comp_op_S() quantifier_S() table_subquery_S()	
}

void quantifier_S() : {}
{
	//S:
	// <quantifier> ::= <all> | <some>
	//
	// <all> ::= ALL
	// <some> ::= SOME | ANY
	//
	<ALL> | ( <SOME> | <ANY> )	
}

void query_expression_S() : {}
{
	//S:
	// <query_expression> ::=
    //    <non-join_query_expression>
    //  | <joined_table>
	
	LOOKAHEAD(3)
	nonjoin_query_expression_S()
	|
	joined_table_S()
}

void query_primary_S() : {}
{
	//S:
	// <query_primary> ::=
    //    <non-join_query_primary>
    //  | <joined_table>

    LOOKAHEAD(3)
 	nonjoin_query_primary_S()
    | 
    joined_table_S()
}


void query_term_S() : {}
{
	//S:
	// <query_term> ::=
    //    <non-join_query_term>
    //  | <joined_table>

	LOOKAHEAD(2)
	nonjoin_query_term_S()
	|
	joined_table_S()	
}

void corresponding_spec_S() : {}
{
	//S:
	// <corresponding_spec> ::=
    //    CORRESPONDING [ BY <left_paren> <corresponding_column_list> <right_paren> ]
	<CORRESPONDING> [ <BY> <LEFT_PAREN> corrsponding_column_list_S() <RIGHT_PAREN> ] 
}
    
void corrsponding_column_list_S() : {}
{
	//S:
	// <corresponding_column_list> ::= <column_name_list>
	column_name_list_S()	
}

/**
 * cross_join_S
 *
 *-bnf-start
 *- <cross_join> ::=
 *-     <table_reference> CROSS JOIN <table_reference>
 *-bnf-end
 *
 */
JoinTableType cross_join_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "cross_join_S()" ) ;
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	//S:
	// <cross_join> ::=
    //    <table_reference> CROSS JOIN <table_reference>
	( fType1=tableReferenceBarJoinedTable() <CROSS_JOIN> fType2=table_reference_A() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JointTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   if( TRACE_ENABLED ) exitTrace ( "cross_join_S()" ) ;
	   return jtType ;	
	}
}


void nonjoin_query_expression_S() : {}
{
	//S:
	// <non-join_query_expression> ::=
    //    <non-join_query_term>
    //  | <query_expression> UNION  [ ALL ] [ <corresponding_spec> ] <query_term>
    //  | <query_expression> EXCEPT [ ALL ] [ <corresponding_spec> ] <query_term>

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	LOOKAHEAD(4)
	query_term_S() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ corresponding_spec_S() ] query_term_S() )*
	|
	nonjoin_query_term_S()
}

void nonjoin_query_term_S() : {}
{
	//S:
	// <non-join_query_term> ::=
    //    <non-join_query_primary>
    //  | <query_term> INTERSECT [ ALL ] [ <corresponding_spec> ] <query_primary>

	// Refactored to...
	LOOKAHEAD(3)
	nonjoin_query_primary_S()
	|
	query_primary_S() <INTERSECT> [ <ALL> ] [ corresponding_spec_S() ] query_primary_S()	
}

void nonjoin_query_primary_S() : {}
{
	//S:
	//  <non-join_query_primary> ::=
    //    <simple_table>
    //  | <left_paren> <non-join_query_expression> <right_paren>
    
	simple_table_S()
	|
	<LEFT_PAREN> nonjoin_query_expression_S() <RIGHT_PAREN>
}

void nonsecond_datetime_field_S() : {}
{
	//S:
	// <non-second_datetime_field> ::= YEAR | MONTH | DAY | HOUR | MINUTE
	<YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE>
}

void simple_table_S() : {}
{
	//S:
	// <simple_table> ::=
    //    <query_specification>
    //  | <table_value_constructor>
    //  | <explicit_table>

	query_specification_A()
	|
	table_value_constructor_S()
	|
	explicit_table_S()	
}

///**// * table_expression_A// *// *-bnf-start// *- <table_expression> ::=// *-     <from_clause>// *-     [ <where_clause> ]// *-     [ <group_by_clause> ]// *-     [ <having_clause> ]// *-     [ <order_by_clause> ]// *-!! ADQL adds <order_by_clause>// *-bnf-end// *// */
//void table_expression_A( SelectType st ) : //{//	if( TRACE_ENABLED ) enterTrace ( "table_expression_A" ) ;//} //{//	//S://	// <table_expression> ::=//	// <from_clause>//    // [ <where_clause> ]//    // [ <group_by_clause> ]//    // [ <having_clause> ]//	(//		from_clause_S( st ) 		//		[ LOOKAHEAD(3) where_clause_S( st ) ] //		//		[ LOOKAHEAD(3) group_by_clause_S( st ) ] //		//		[ LOOKAHEAD(3) having_clause_S( st ) ] //		//		[ LOOKAHEAD(3) order_by_clause_A( st ) ]	//	)//	{ //		if( TRACE_ENABLED ) exitTrace ( "table_expression_A" ) ;//	}//}

/**
 * table_name_A
 *
 * bnf-start
 *  <table_name> ::=
 *      <qualified_name>
 *  !! SQL92 also supports <qualified_local_table_name>
 * bnf-end
 *
 */
String table_name_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "table_name_A()" ) ;
	String retValue = null ;
}
{
	//S:
	// <table_name> ::=
    //  <qualified_name> | <qualified_local_table_name>

	// Forshortened
	retValue=qualified_name_A()
	{ 
		if( TRACE_ENABLED ) exitTrace ( "table_name_A()" ) ;
		return retValue ; 
	}
}

/**
 * table_reference_A
 *
 * bnf-start
 *  <table_reference> ::=
 *      <table_name> [ [ AS ] <correlation_name> ]
 *    | <joined_table> 
 *  !! SQL92 also supports <derived_table> and <derived_column_list>
 * bnf-end
 *
 */
FromTableType table_reference_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "table_reference_A()" ) ;
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
} 
{
	//S:
	//  <table_reference> ::=
    //     <table_name> [ [ AS ] <correlation_name> [ <left_paren> <derived_column_list> <right_paren> ] ]
    //   | <derived_table> [ AS ] <correlation_name> [ <left_paren> <derived_column_list> <right_paren> ]
    //   | <joined_table>

	(
		// refactored... 
		// 1. derivedTable() moved to first choice point
		// 2. joinedTable() moved to second choice point
//	    LOOKAHEAD(4)
//	    derivedTable() [ <AS> ] correlationName() [ <LEFT_PAREN> derived_column_list_S() <RIGHT_PAREN> ]
//	    |	
//		LOOKAHEAD(4)
//	    joinedTable()
//	    |
//		tableName() [ [ <AS> ] correlationName() [ <LEFT_PAREN> derived_column_list_S() <RIGHT_PAREN> ] ]    

		// Foreshortened. 
		// derivedColumnList not supported in adql
		// derivedTable not supported in adql
//		LOOKAHEAD(4)
//	    derivedTable() [ <AS> ] correlationName()
//	    |	
		LOOKAHEAD(4)
	    ftType=joined_table_S()
	    |
		( tName=table_name_A() [ [ <AS> ] cName=correlation_name_S() ] )
		{
			if( tName != null ) {	
				TableType tableType = TableType.Factory.newInstance() ;
				tableType.setName( tName ) ;
				if( cName != null )
					tableType.setAlias( cName ) ;
				ftType = tableType ;
			}
		} 
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "table_reference_A()" ) ;
		return ftType ; 
	} 
}

FromTableType table_reference_fragment() : 
{
	FromTableType ft = null ;
} 
{
	ft=table_reference_A() <SEMICOLON>
	{ return ft ; }
}

// Adaptation of <table_reference>
FromTableType tableReferenceBarJoinedTable() : 
{
	if( TRACE_ENABLED ) enterTrace ( "tableReferenceBarJoinedTable()" ) ;
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
}
{
	( tName=table_name_A() [ [ <AS> ] cName=correlation_name_S() ] )
	{
		if( tName != null ) {	
			TableType tableType = TableType.Factory.newInstance() ;
			tableType.setName( tName ) ;
			if( cName != null )
				tableType.setAlias( cName ) ;
			ftType = tableType ;
		}
	}
	{ 
		if( TRACE_ENABLED ) exitTrace ( "tableReferenceBarJoinedTable()" ) ;
		return ftType ; 	
	}
}

SearchType table_subquery_S() : 
{
	SearchType st = null ;
}
{
	//S:
	// <table_subquery> ::= <subquery>
	st=subquery_S()	
	{ return st ; }
}

/**
 * table_subquery_A
 *
 * bnf-start
 *  <table_subquery> ::= 
 *      <left_paren> <query_specification> <right_paren>
 *  !! SQL92 uses <subquery>
 * bnf-end
 *
 */
SubQuerySet table_subquery_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "table_subquery_A" ) ;
	SubQuerySet sqs = null ;
	SelectType st = null ;
	
}
{
	//S:
	// <table_subquery> ::= <subquery>
	<LEFT_PAREN> st=query_specification_A() <RIGHT_PAREN>	
	{ 
		if( st != null ) {
			sqs = SubQuerySet.Factory.newInstance() ;
			sqs.setSelection( st ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "table_subquery_A" ) ;
		return sqs ; 
	}
}

void table_value_constructor_S() : {}
{
	//S:
	//  <table_value_constructor> ::=
    //     VALUES <table_value_constructor_list>

	<VALUES> table_value_constructor_list_S()
}

void table_value_constructor_list_S() : {}
{
	//S:
	// <table_value_constructor_list> ::=
    //    <row_value_constructor> [ { <comma> <row_value_constructor> }... ]

	row_value_constructor_S() ( <COMMA> row_value_constructor_S() )*	
}

/**
 * term_S
 *
 * bnf-start
 *  <term> ::=
 *      <factor>
 *    | <term> <asterisk> <factor>
 *    | <term> <solidus> <factor>
 * bnf-end
 *
 */
ScalarExpressionType term_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "term_S()" ) ;
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	//S:
	//  <term> ::=
    //     <factor>
    //   | <term> <asterisk> <factor>
    //   | <term> <solidus> <factor>

	// refactored
	// factor() ( LOOKAHEAD(2) (<ASTERISK> | <SOLIDUS> ) term() )*
	seType=factor_S() exprPairs=termList()
	{ 
		if( exprPairs != null )  {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   seType = beType ;
		}	
		if( TRACE_ENABLED ) exitTrace ( "term_S()" ) ;
		return seType ;
	}
}

ScalarExpressionType[] termList() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=termSingleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] termSingleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<ASTERISK> | t=<SOLIDUS> ) seType=term_S()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;		
			beType = BinaryExprType.Factory.newInstance() ;
			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}

void time_fractional_seconds_precision_S() : {}
{
	//S:
	// <time_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER> 	
}

void time_precision_S() : {}
{
	//S:
	// <time_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void timestamp_precision_S() : {}
{
	//S:
	// <timestamp_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void time_zone_S() : {}
{
	//S:
	//  <time_zone> ::= AT <time_zone_specifier>
    //  <time_zone_specifier> ::= LOCAL | TIME ZONE <interval_value_expression>

	// refactored
    <AT> ( <LOCAL> | ( <TIME_ZONE> interval_value_expression_S() ) ) 
}

/**
 * 
 *
 * bnf-start
 *  <trig_function> ::=
 *      ACOS <left_paren> <numeric_value_expression> <right_paren>
 *    | ASIN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN2 <left_paren> <numeric_value_expression> <comma> <numeric_value_expression> <right_paren>
 *    | COS <left_paren> <numeric_value_expression> <right_paren>
 *    | COT <left_paren> <numeric_value_expression> <right_paren>
 *    | SIN <left_paren> <numeric_value_expression> <right_paren>
 *    | TAN <left_paren> <numeric_value_expression> <right_paren>
 *  !! Specific to ADQL
 * bnf-end
 *
 */
TrigonometricFunctionType trig_function_A() : 
{
	if( TRACE_ENABLED ) enterTrace ( "trig_function_A()" ) ;
	TrigonometricFunctionType tfType = null ; 
	ScalarExpressionType arg1 = null ;
	ScalarExpressionType arg2 = null ;
	Token t = null ;
}
{
	(
		t=<ACOS> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<ASIN> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
        t=<ATAN> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<ATAN2> <LEFT_PAREN> arg1=numeric_value_expression_S() <COMMA> arg2=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<COS> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<COT> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<SIN> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
		|
		t=<TAN> <LEFT_PAREN> arg1=numeric_value_expression_S() <RIGHT_PAREN>
	)
	{
		if( t != null ) {
			ScalarExpressionType[] argArray = null ;
			tfType = TrigonometricFunctionType.Factory.newInstance() ;
			tfType.setName( TrigonometricFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			if( arg2 != null ) {
				argArray = new ScalarExpressionType[2] ;
				argArray[0] = arg1 ;
				argArray[1] = arg2 ;
			}
			else {
				argArray = new ScalarExpressionType[1] ;
				argArray[0] = arg1 ;
			}
			tfType.setArgArray( argArray ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "trig_function_A()" ) ;
		return tfType ;
	}
}

void unique_predicate_S() : {}
{
	//S:
	// <unique_predicate> ::= UNIQUE <table_subquery>
	<UNIQUE> table_subquery_S()	
}

/**
 * unsigned_literal_S
 *
 * bnf-single <unsigned_literal> ::= <unsigned_numeric_literal> | <general_literal>
 *
 */
AtomType unsigned_literal_S() : 
{
	AtomType atomType = null ;
}
{
	//S: 
	// <unsigned_literal> ::=
    //    <unsigned_numeric_literal>
    //  | <general_literal>
	(
	    atomType=unsigned_numeric_literal_A()
		| 
		atomType=general_literal_A()
	)
	{ return atomType ; }
}

/**
 * unsigned_numeric_literal_A
 *
 * bnf-start
 *  <unsigned_numeric_literal> ::=
 *     <exact_numeric_literal>
 *  !! SQL92 also supports <approximate_numeric_literal>
 * bnf-end
 *
 */
AtomType unsigned_numeric_literal_A() : 
{
	AtomType atomType = null ;
}
{
	//S:
	//  <unsigned_numeric_literal> ::=
    //      <exact_numeric_literal>
    //    | <approximate_numeric_literal>
	(
// JL. Note the adql/x schema does not possess an approximateNumericLiteral
		atomType=exact_numeric_literal_S( DONT_CHANGE_SIGN )
    )
    { return atomType ; }
}

/**
 * unsigned_value_specification_S
 *
 * bnf-start
 *  <unsigned_value_specification> ::=
 *      <unsigned_literal>
 *    | <general_value_specification>
 * bnf-end
 *
 */
ScalarExpressionType unsigned_value_specification_S() : 
{
	if( TRACE_ENABLED ) enterTrace ( "unsigned_value_specification_S()" ) ;
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <unsigned_value_specification> ::=
    //     <unsigned_literal>
    //   | <general_value_specification>
	(
		seType=unsigned_literal_S()
		|
		general_value_specification_A()
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "unsigned_value_specification_S()" ) ;
		return seType ;  
	}
}

/**
 * value_expression_A
 *
 * bnf-start
 *  <value_expression> ::=
 *	    <numeric_value_expression>
 *    | <string_value_expression>
 *  !! SQL92 also supports <datetime_value_expression>
 *     and <interval_value_expression>
 * bnf-end
 *
 */
ScalarExpressionType value_expression_A() : 
{
    if( TRACE_ENABLED ) enterTrace ( "value_expression_A()" ) ;
	ScalarExpressionType retValue = null ;
} 
{
	//S:
	// <value_expression> ::=
	//    <numeric_value_expression>
    //  | <string_value_expression>
    //  | <datetime_value_expression>
    //  | <interval_value_expression>
	(
	LOOKAHEAD(3) 
	retValue=numeric_value_expression_S() 
	|
	LOOKAHEAD(3) 	
	retValue=string_value_expression_A() 
	// JL. foreshortened. At present there seems no accommodation for
	// datetime and interval expressions in adql
//	|
//	LOOKAHEAD(3) 
//	dateTimeValueExpression() 
//	|
//	intervalValueExpression()
	)
	{ 
		if( TRACE_ENABLED ) exitTrace ( "value_expression_A()" ) ;
		return retValue ; 
	}
	
}

/**
 * variable_specification_A
 *
 * bnf-start
 *  <variable_specification> ::=
 *  !! Yet to be worked out.
 * bnf-end
 *
 */
ScalarExpressionType variable_specification_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <variable_specification> ::=
    //    <embedded_variable_name> [ <indicator_variable> ]
    
	// JBL ADQL adaptation to accommodate scripting variables.
	// Details still to be worked out.
	<DOLLAR> <LBRACE> <REGULAR_IDENTIFIER> <RBRACE>
	{ return seType ; }
}

/**
 * where_clause_S
 *
 * bnf-single <where_clause> ::= WHERE <search_condition>
 *
 */
WhereType where_clause_S()        : 
{/*@bgen(jjtree) Where */
        ASTWhere jjtn000 = new ASTWhere(this, JJTWHERE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	if( TRACE_ENABLED ) enterTrace ( "where_clause_S" ) ;
	WhereType whereType = null ;
	SearchType s = null ;
	Token t = null ;
}
{/*@bgen(jjtree) Where */
        try {
/*@egen*/
	//S:
	// WHERE <search_condition>

	t=<WHERE> s=search_condition_S()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ 
			
		if( s != null ) {
			whereType = WhereType.Factory.newInstance() ;
			whereType.setCondition( s ) ;
		}
		if( TRACE_ENABLED ) exitTrace ( "where_clause_S" ) ;
	  	return whereType ;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

WhereType where_clause_fragment() : 
{
	WhereType wt = null ;
}
{
	wt=where_clause_S() <SEMICOLON>
	{ return wt ; }
}
/* 
$Log: AdqlStoX.jj,v $
Revision 1.22  2006/11/27 18:05:47  jl99
Merge of branch adql-jl-2020

Revision 1.32.2.3  2006/11/27 16:35:28  jl99
Adopted a more short term approach to Delimited Identifiers. In our terms these are quoted identifiers, eg: "2xmmp" as a table name. We now allow quoted identifiers (partially) in order to differentiate possible name clashes but do not format them into the xml (that's the partial bit). This is acceptable since the dsa still works on xml and does not need quotes to differentiate name clashes.

Revision 1.32.2.2  2006/11/17 13:45:45  jl99
More on compiling fragments of ADQL

Revision 1.32.2.1  2006/11/16 22:11:34  jl99
First experiment with compiling fragments

Revision 1.32  2006/11/13 21:02:18  jl99
Slight code rationalization

Revision 1.31  2006/11/12 20:06:00  jl99
Removed support for Cross Joins.
Difficult to support this with the current Adlq/x schema which has a join condition as mandatory.

Revision 1.30  2006/10/28 22:08:05  jl99
Rejig to enable more speedy adaptation to aliased expressions
when these become feasible. At present ADQL/x is broken in this area.

Revision 1.29  2006/10/27 14:29:56  jl99
Made alliases for tables compulsary. Not sure this is such a good idea,
but it obeys the adql/x 1.01 standard.

Revision 1.28  2006/10/25 13:22:15  jl99
Extra convenience methods to trigger compilations with differing output
(XmlBeans, XmlText, Xml Dom Node etc)

Revision 1.27  2006/10/23 22:39:10  jl99
Corrections to embedded BNF documentation

Revision 1.26  2006/10/22 20:47:10  jl99
More BNF Documentation

Revision 1.25  2006/10/20 13:02:10  jl99
More BNF Documentation

Revision 1.24  2006/10/20 08:53:25  jl99
BNF Documentation

Revision 1.23  2006/10/18 22:35:53  jl99
Some systematization of token definitions.

Revision 1.22  2006/10/16 15:35:49  jl99
Region: Circle and Ellipse at STCregion v1.10.
This is not the latest spec for region. But is appropriate as a prototype.

Revision 1.21  2006/10/16 11:37:46  jl99
First Attempt at Region.

Revision 1.20  2006/10/14 16:14:52  jl99
like_predicate complete (according to adql/x v1.01a).

Revision 1.19  2006/10/14 13:09:19  jl99
in_predicate complete (according to adql/x v1.01a).

Revision 1.18  2006/10/13 21:01:59  jl99
in_predicate begun.

Revision 1.17  2006/10/13 13:29:24  jl99
(1) Some logging added.
(2) Improved processing for unary values.

Revision 1.16  2006/10/11 20:36:25  jl99
(1) Change of signature to exec method. Now throws a ParserException.

Revision 1.15  2006/10/02 09:03:35  jl99
First attempt at mavenizing project

Revision 1.14  2006/09/28 15:08:55  jl99
Errors corrected.

Revision 1.13  2006/09/28 08:50:02  jl99
Reorg on method naming convention: complete.

Revision 1.12  2006/09/28 08:43:29  jl99
Reorg on method naming convention: 4.

Revision 1.11  2006/09/27 20:51:55  jl99
Reorg on method naming convention: 3.

Revision 1.10  2006/09/26 13:44:11  jl99
Reorg on method naming convention: 1.

*/


