/*@bgen(jjtree) Generated By: AdqlStoX.jjt,v 1.10 2006/09/26 13&JJTree: Do not edit this line. ./AdqlStoX.jj */
/*@egen*//*$Id: AdqlStoX.jj,v 1.8 2006/09/27 20:51:55 jl99 Exp $*/
/**
 * AdqlStoX JavaCC file
 *
 * This version, with file extension of .jjt, produces a syntax tree.
 * At present the syntax tree is not used, but will be.
 *
 * AdqlStoX takes text in the form of Adql/s and compiles it to xml Adql/x format.
 * Adql/s is based upon SQL/92 with astronomical extensions.
 * There is a naming convention for methods, which is aimed at making the structure
 * as clear as possible.
 *
 * (1) All methods which are quoted bnf statements follow the bnf format.
 *     Thus the the statment <comparison_predicate> from the SQL/92 standard
 *     will have a corresponding method with a name similar to comparison_predicate().
 *     However, such methods are decorated in a particular way, for which see
 *     points (2) and (3) below. All methods which are tantamount to quoted
 *     bnf will have the standard syntax as a comment embedded within them.
 *     Thus:
 *     //S: 
 *     // <row_value_constructor> <comp_op> <row_value_constructor>
 * (2) Methods which follow exactly the SQL/92 syntax at a shallow level are suffixed _S.
 *     Thus comparison_predicate_S() represents the SQL/92 standard syntax. Shallow implies
 *     that the syntax can still vary from the standard within statements quoted
 *     within the given construct. This is usually pretty obvious from the quoted statements
 *     (eg: quoted statement some_statement_A() means an ADQL variation, see next point), 
 *     but beware that it is possible for variations to be deeply embedded.
 *     NB: A statement that is just a synonym for another statement will take
 *         the quoted statement's decoration. This is the one exception.
 * (3) Methods which are varied for some reason within ADQL, or are simply
 *     specific to ADQL, are suffixed _A.
 *     Thus comparison_predicate_A() represents an ADQL deviation.
 * (4) Some methods are introduced as implementations of part of a syntax.
 *     This is just to make for a neater structure. These methods follow
 *     the standard Java OO naming convention and are not decorated, 
 *     eg: numericValueExpressionList().
 *
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Sep 2006
 */
 
options {
  JDK_VERSION = "1.4";
  STATIC=false;                                                                                      
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import java.util.* ;
import org.astrogrid.adql.v1_0.beans.* ;

public class AdqlStoX/*@bgen(jjtree)*/implements AdqlStoXTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTAdqlStoXState jjtree = new JJTAdqlStoXState();

/*@egen*/
	
	public SelectDocument exec() {
		SelectDocument selectDoc = null ;
		try {			
			selectDoc = select_document_A();
		}
		catch( ParseException pex ) {
			//pex.printStackTrace() ;
			System.out.println( pex.getMessage() ) ;
		}
		catch( Error err ) {
			err.printStackTrace() ;
			System.out.println( err.getMessage() ) ;
		}
		return selectDoc ;	
	}

}
PARSER_END(AdqlStoX)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}


TOKEN : 
{
	< LBRACE : "{" >
|	< RBRACE : "}" >
	
|	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< EQUALS_OPERATOR : "=" >
|	< LESS_THAN_OPERATOR : "<" >
|	< GREATER_THEN_OPERATOR : ">" >

|	< ADD: "add" >
|	< ALL: "all" >
|	< AND: "and" >
|	< ANY: "any" >
|	< AS: "as" >
|	< ASC: "asc" >
|	< AT : "at" >
|	< AUTHORIZATION: "authorization" >
|	< BASE64: "base64" >
|	< BEGIN: "begin" >
|	< BETWEEN: "between" >
|	< BINARY: "binary" >
|	< BREAK: "break" >
|	< BY: "by" >
|	< CASE: "case" >
|	< CAST: "cast" >
|	< CHECKPOINT: "checkpoint" >
|	< CLOSE: "close" >
|	< CLUSTERED: "clustered" >

|   < COALESCE: "coalesce" >
|	< COLLATE: "collate" >
|	< COLUMN: "column" >
|	< COMMIT: "commit" >
|	< COMPUTE: "compute" >
|	< CONCAT: "concat" >
|	< CONSTRAINT: "constraint" >
|	< CONTAINS: "contains" >
|	< CONTAINSTABLE: "containstable" >
|	< CONTINUE: "continue" >

|	< CORRESPONDING : "corresponding" >

	//| < CONVERT: "convert" >
|	< CREATE: "create" >
//|	< CROSS: "cross" >
|	< CROSS_JOIN : "cross join">
|	< CUBE: "cube" >
|	< CURRENT: "current" >
|	< CURRENT_DATE: "current_date" >
|	< CURRENT_TIME: "current_time" >
|	< CURRENT_TIMESTAMP: "current_timestamp" >
|	< CURRENT_USER: "current_user" >
|	< CURSOR: "cursor" >
|	< DATABASE: "database" >
|	< DBCC: "dbcc" >
|	< DEALLOCATE: "deallocate" >
|	< DECLARE: "declare" >
|	< SQL_DEFAULT: "default" >
|	< DELETE: "delete" >
|	< DENY: "deny" >
|	< DESC: "desc" >
|	< DISK: "disk" >
|	< DISTINCT: "distinct" >
|	< DISTRIBUTED: "distributed" >
|	< DOT: "." >
|	< DOUBLE: "double" >
|	< DROP: "drop" >
|	< DUMP: "dump" >
|	< ELEMENTS: "elements" >
|	< ELSE: "else" >
|	< END: "end" >
|	< ERRLVL: "errlvl" >
|	< ESCAPE: "escape" >
|	< EXCEPT: "except" >
|	< EXEC: "exec" >
|	< EXECUTE: "execute" >
|	< EXISTS: "exists" >
|	< EXIT: "exit" >
|	< EXPAND: "expand" >
|	< EXPLICIT: "explicit" >
|	< FAST: "fast" >
|	< FASTFIRSTROW: "fastfirstrow" >
|	< FETCH: "fetch" >
|	< FILE: "file" >
|	< FILLFACTOR: "fillfactor" >
|	< FOR: "for" >
|	< FORCE: "force" >
|	< FOREIGN: "foreign" >
|	< FREETEXT: "freetext" >
|	< FREETEXTTABLE: "freetexttable" >
|	< FROM: "from" >
|	< FULL: "full" >
|	< FUNCTION: "function" >
|	< GOTO: "goto" >
|	< GRANT: "grant" >
|	< GROUPBY: "group by" >
|	< HASH: "hash" >
|	< HAVING: "having" >
|	< HOLDLOCK: "holdlock" >
|	< IDENTITY: "identity" >
|	< IDENTITY_INSERT: "identity_insert" >
|	< IDENTITYCOL: "identitycol" >
|	< IF: "if" >
|	< IN: "in" >
|	< INDEX: "index" >
|	< INNER: "inner" >
|	< INSERT: "insert" >
|	< INTERSECT: "intersect" >
|	< INTO: "into" >
|	< IS: "is" >
|	< JOIN: "join" >
|	< KEEP: "keep" >
|	< KEEPFIXED: "keepfixed" >
|	< KEY: "key" >
|	< KILL: "kill" >
|	< LEFT: "left" >
|	< LIKE: "like" >
|	< LINENO: "lineno" >
|	< LOCAL: "local" >
|	< LOAD: "load" >
|	< LOOP: "loop" >
|	< MATCH : "match" >
|	< MAXDOP: "maxdop" >	
|	< MERGE: "merge" >
|	< NATIONAL: "national" >
|	< NATURAL: "natural" >
|	< NOCHECK: "nocheck" >
|	< NOLOCK: "nolock" >
|	< NONCLUSTERED: "nonclustered" >
|	< NOT: "not" >
|	< NULL: "null" >

	//| < NULLIF: "nullif" >
|	< OF: "of" >
|	< OFF: "off" >
|	< OFFSETS: "offsets" >
|	< ON: "on" >
|	< OPEN: "open" >
|	< OPENDATASOURCE: "opendatasource" >
|	< OPENQUERY: "openquery" >
|	< OPENROWSET: "openrowset" >
|	< OPENXML: "openxml" >
|	< OPTION: "option" >
|	< OR: "or" >
|	< ORDER: "order" >
|	< ORDERBY : "order by" >
|	< OUTER: "outer" >
|	< OVER: "over" >
|	< OVERLAPS : "overlaps" >
|	< PAGLOCK: "paglock" >
|	< PARTIAL : "partial" >
|	< PERCENT: "percent" >
|	< PLAN: "plan" >
|	< PRECISION: "precision" >
|	< PRIMARY: "primary" >
|	< PRINT: "print" >
|	< PROC: "proc" >
|	< PROCEDURE: "procedure" >
|	< PUBLIC: "public" >
//|	< QUOTE : "'" >
|	< RAISERROR: "raiserror" >
|	< RAW: "raw" >
|	< READ: "read" >
|	< READCOMMITED: "readcommited" >
|	< READPAST: "readpast" >
|	< READTEXT: "readtext" >
|	< READUNCOMMITED: "readuncommited" >
|	< RECONFIGURE: "reconfigure" >
|	< REFERENCES: "references" >
|	< REGION: "region" >
|	< REMOTE: "remote" >
|	< REPEATABLEREAD: "repeatableread" >
|	< REPLICATION: "replication" >
|	< RESTORE: "restore" >
|	< RESTRICT: "restrict" >
|	< RETURN: "return" >
|	< REVOKE: "revoke" >
|	< RIGHT: "right" >
|	< ROBUST: "robust" >
|	< ROLLBACK: "rollback" >
|	< ROLLUP: "rollup" >
|	< ROWCOUNT: "rowcount" >
|	< ROWGUIDCOL: "rowguidcol" >
|	< ROWLOCK: "rowlock" >
|	< RULE: "rule" >
|	< SAVE: "save" >
|	< SCHEMA: "schema" >
|	< SELECT: "select" >
|	< SERIALIZABLE: "serializable" >
|	< SESSION_USER: "session_user" >
|	< SET: "set" >
|	< SETUSER: "setuser" >
|	< SHUTDOWN: "shutdown" >
|	< SOME: "some" >
|	< STATISTICS: "statistics" >
|	< SYSTEM_USER: "system_user" >
|	< TABLE: "table" >
|	< TABLOCK: "tablock" >
|	< TABLOCKX: "tablockx" >
|	< TEXTSIZE: "textsize" >
|	< THEN: "then" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TIES: "ties" >
|	< TO: "to" >
|	< TOP: "top" >
|	< TRAN: "tran" >
|	< TRANSACTION: "transaction" >
|	< TRIGGER: "trigger" >
|	< TRUTH_VALUE : "true" | "falsed" | "unknown" >
|	< TSEQUAL: "tsequal" >
|	< UNION: "union" >
|	< UNIQUE: "unique" >
|	< UPDATE: "update" >
|	< UPDATETEXT: "updatetext" >
|	< UPDLOCK: "updlock" >
|	< USE: "use" >
|	< USER: "user" >
|	< USING : "using" >
|	< VALUES: "values" >
|	< VARYING: "varying" >
|	< VIEW: "view" >
|	< VIEWS: "views" >
|	< WAITFOR: "waitfor" >
|	< WHEN: "when" >
|	< WHERE: "where" >
|	< WHILE: "while" >
|	< WITH: "with" >
|	< WRITETEXT: "writetext" >
|	< XLOCK: "xlock" >
|	< XMATCH: "xmatch" >
|	< XML: "xml" >
|	< XMLDATA: "xmldata" >

	//math
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >
	
	//aggregate
|	< MAX: "max" >
|	< MIN: "min" >
|	< SUM: "sum" >
|	< AVG: "avg" >
|	< COUNT: "count" >


|	< COLON : ":" >
|	< COMMA : "," >
|	< SEMICOLON : ";" >
|	< LPAREN : "(" >
|	< RPAREN : ")" >
|	< LSQUARE : "[" >
|	< RSQUARE : "]" >

|	< DIVIDE : "/" >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< STAR : "*" >
|	< MOD : "%" >
|	< AMPERSAND : "&" >
|	< TILDE : "~" >
|	< BITWISEOR : "|" >
|	< BITWISEXOR : "^" >
|	< BANG : "!" >
|	< QUESTIONMARK : "?" >

|	< DOLLAR : "$" >
|	< SECOND: "second" >

|  	< REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >
|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">

|	< SIGN : <PLUS> | <MINUS> >
|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] > 
|	< SIGNED_INTEGER : (<PLUS> |<MINUS>) <UNSIGNED_INTEGER> >
|	< EXPONENT : ["e", "E"] <SIGNED_INTEGER> >

|	< NON_SECOND_DATETIME_FIELD: <YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE> >
|	< #YEAR: "year" >
|	< #MONTH: "month" >
|	< #DAY: "day" >
|	< #HOUR: "hour" >
|	< #MINUTE: "minute" >

|	< ASCII_STRING_LITERAL : "\'" (~["\'"])* "\'" >

//| 	< ASCIIStringLiteral : "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >//|	< UnicodeStringLiteral : "n" "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >

|	< OTHER : ~[] >
}
 

SelectDocument select_document_A() : 
{ 	
	SelectDocument selectDoc = null ; 	
	SelectType st = null ;	
}
{
	// There is no equivalent construct in the SQL/92 standard.
	st=query_specification_A() [ <SEMICOLON> ] 
	{  
		if( st != null ) {
			selectDoc =  SelectDocument.Factory.newInstance() ;
			selectDoc.setSelect( st ) ;
		}
		return selectDoc ; }
}

//=================================

String actual_identifier_S() : 
{
	Token t ;
}
{
	//S:
	// <regular_identifier> | <delimited_identifier
	( t=<REGULAR_IDENTIFIER> | t=<DELIMITED_IDENTIFIER> )
	{ return t.image ;}
}


// JL. The adql/x schema does not have such a beast!
void approximate_numeric_literal_S() : {}
{
	//S:
	// <approximate_numeric_literal> ::= <mantissa> E <exponent>
	// <mantissa> ::= <exact_numeric_literal>
	// <exponent> ::= <signed_integer>
	mantissa_S() <EXPONENT>
}

SearchType between_predicate_A() : 
{
	
	ScalarExpressionType se1 = null ;
	ScalarExpressionType se2 = null ;
	ScalarExpressionType se3 = null ;
	Token t = null ;
}
{
	//S:
	// <row_value_constructor> [ NOT ] BETWEEN
    // <row_value_constructor> AND <row_value_constructor>
    
    // Note the absence of row_value_constructor...	
	( se1=value_expression_A() [ t=<NOT> ] <BETWEEN> se2=value_expression_A() <AND> se3=value_expression_A()	)
	{
		if( se3!=null ) {
			ScalarExpressionType[] args = new ScalarExpressionType[3] ;
			args[0] = se1 ;
			args[1] = se2 ;
			args[2] = se3 ;
			if( t==null ) {
				BetweenPredType bp = BetweenPredType.Factory.newInstance() ;
				bp.setArgArray( args ) ;
				return bp ;			
			}
			else {
				NotBetweenPredType nbp = NotBetweenPredType.Factory.newInstance() ;
				nbp.setArgArray( args ) ;
				return nbp ;		
			}
		}
		return null ;
	}
}

SearchType boolean_primary_S() : 
{
	SearchType st = null ;
	Token t = null ;
} 
{
	//S:
	// <boolean_primary> ::=
    //    <predicate>
    //  | <left_paren> <search_condition> <right_paren>

	
	(
		LOOKAHEAD(3)
		st=predicate_A()
	    | 
	    <LPAREN> st=searchCondition() t=<RPAREN>
    )
    {
    	if( t != null ) {
    		ClosedSearchType cs = ClosedSearchType.Factory.newInstance() ;
    		cs.setCondition( st ) ;
    		return cs ;	
    	}
    	return st ;
    }
}

SearchType boolean_term_S() : 
{
	SearchType st=null ;
	SearchType[] stPair = null ;
}
{
	//S:
	// <boolean_term> ::=
    //    <boolean_factor>
    //  | <boolean_term> AND <boolean_factor>

	// Refactored to
	// boolean_factor_S() ( <AND> boolean_factor_S() )*
	// which I believe is equivalent to the above
	st=boolean_factor_S() stPair=booleanFactorList()
	{
		if( stPair == null ) {
		   return st ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st ;
		   conditionArray[1] = stPair[1] ;
		   IntersectionSearchType andType = (IntersectionSearchType)stPair[0] ;
		   andType.setConditionArray( conditionArray ) ;
		   return andType ;
		}	
	}
}

SearchType boolean_factor_S() :
{
	SearchType sc = null ;
	Token t = null ;
}
{
	[ t=<NOT> ] sc=boolean_test_A()
	{
		if( t != null ) {
			InverseSearchType is = InverseSearchType.Factory.newInstance() ;
			is.setCondition( sc ) ;
			return is ;		
		}
		return sc ;
	}
}

SearchType[] booleanFactorList() :
{
	ArrayList list = null ;
	SearchType[] stPair1 = null ;
	SearchType[] stPair2 = null ;
	SearchType[] retPair = null ;
}
{
	( 
		stPair1=booleanFactorSingleton() 
		{ if( list == null )
	  	     list = new ArrayList() ;
	  	  list.add( stPair1 ) ;
	  	} 	
	)*
	{
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retPair = stPair1 = (SearchType[])iterator.next() ;
			SearchType[] conditions = new SearchType[2] ;
			IntersectionSearchType andType = null ;
			while( iterator.hasNext() ) {
				stPair2 = (SearchType[])iterator.next() ;
				conditions[0] = stPair1[1] ;
				conditions[1] = stPair2[1] ;
				andType = (IntersectionSearchType)stPair2[0] ;
				andType.setConditionArray( conditions ) ;
				stPair1 = stPair2 ;
			}
		}		
		return retPair ;
	}
}

SearchType[] booleanFactorSingleton() :
{
	SearchType[] retPair = null ;
	IntersectionSearchType andType = null ;
	SearchType st = null ;
}
{
	<AND> st=boolean_factor_S()
	{
		if( st != null ) {
			retPair = new SearchType[2] ;		
			andType = IntersectionSearchType.Factory.newInstance() ;
			retPair[0] = andType ;
			retPair[1] = st ;
		}
		return retPair ;
	}
}

SearchType boolean_test_A() : {	SearchType st = null ;}{	//S:	// <boolean_test> ::=    //  <boolean_primary> [ IS [ NOT ] <truth_value> ]	
	// NB: There is no accommodation of truth value in ADQL	st=boolean_primary_S() 	{ return st ; }}

SearchType likePredicate_A() : 
{
	SearchType st = null ;
	Token t = null ;
	AtomType p = null ;
}
{
	//S:
	// <like_predicate> ::=	//   <match_value> [ NOT ] LIKE <pattern> [ ESCAPE <escape_character> ]
      
	( match_value_S() [ <NOT> ] <LIKE> pattern() )

	{
		return st ;	
	}
}

void mantissa_S() : {}
{
	//S:
	// <mantissa> ::= <exact_numeric_literal>
	
	exact_numeric_literal_S()
}

void caseExpression_S() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification_S() : {}
{
	"6-TBD castSpecification"
}

ScalarExpressionType character_factor_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <character_factor> ::= <character_primary> [ <collate_clause> ]

	seType=character_primary_A()
	{ return seType ; }
}

ScalarExpressionType character_primary_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	//  <character_primary> ::=
    //    <value_expression_primary> | <string_value_function>

	seType=value_expression_primary_A()
	{ return seType ; }
}


AtomType character_string_literal_A() : 
{
	AtomType atomType = null ;
}
{
	//S:
	// <character_string_literal> ::=
    //    [ <introducer><character_set_specification> ]
    //    <quote> [ <character_representation>... ] <quote>
    //    [ { <separator>... <quote> [ <character_representation>... ] <quote> }... ]

	atomType=ASCIIStringLiteral_AG()
	{ 
		return atomType ; 		
	} 
}

AtomType ASCIIStringLiteral_AG() : 
{
	AtomType at = null ;
	ArrayList list = null ;
	Token t1 = null ;
}
{
	( 
		t1=<ASCII_STRING_LITERAL> 
			{
				if( t1 != null ) {
					if( list == null )
						list = new ArrayList() ;
					list.add( t1.image.substring( 1, t1.image.length()-1 ) ) ;
					t1 = null ;
				}
			}

	)+
	{
		if( list.size() > 0 ) {
			StringBuffer buffer = new StringBuffer();
			ListIterator it = list.listIterator() ;
			while( it.hasNext() ) {
				buffer.append( (String)it.next() ) ;	
			}
			at = AtomType.Factory.newInstance() ;
			StringType st = StringType.Factory.newInstance() ;
			st.setValue( buffer.toString() ) ;
			at.setLiteral( st ) ;			
		}
		return at ;
	} 
	
}

ScalarExpressionType character_value_expression_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <character_value_expression> ::=
    //     <concatenation>
    //   | <character_factor>

	seType=character_factor_A()
	{ return seType ; }	
}

void collate_clause_S() : {}
{
	//S:
	// <collate_clause> ::= COLLATE <collation_name>
    // <collation_name> ::= <qualified_name>
	
	// refactored to
	<COLLATE> qualifiedName()	
}

String column_name_S() : 
{
	String name = null ;
}
{
	//S:
	// <column_name> ::= <identifier>

	name=identifier_A()
	{ return name ; }
}

void column_name_list_S()  : {}
{
	//S:
	// <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
	 column_name_S() ( <COMMA> column_name_S() )*	
}

ColumnReferenceType column_reference_S() : 
{
	ColumnReferenceType crType = null ;
	String q = null ;
	String n = null ;
}
{
	//S:
	// <column_reference> ::= [ <qualifier> <period> ] <column_name>

	( [ LOOKAHEAD(2) q=qualifier() <DOT> ] n=column_name_S() )
	{ 
		if( n != null ) {
			crType = ColumnReferenceType.Factory.newInstance() ;
			crType.setName( n ) ;
			if( q != null ) {
				crType.setTable( q ) ;	
			}
		}		
		return crType ; 	
	}
}

/*
 * NB: Referred in some sources as <common_primary>
 */
ScalarExpressionType value_expression_primary_A() : 
{
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	//S:
	//	<value_expression_primary> ::=	//      <unsigned_value_specification>	//    | <column_reference>	//    | <set_function_specification>	//    | <scalar_subquery>	//    | <case_expression>	//    | <left_paren> <value_expression> <right_paren>	//    | <cast_specification>

	(
		// Foreshortened 
		seType=unsignedValueSpecification()
		|
		seType=column_reference_S()
		|
		seType=setFunctionSpecification()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()	//	|
		( <LPAREN> seType=value_expression_A() <RPAREN> ) 
		{
			if( seType != null ) {
				ClosedExprType ceType = ClosedExprType.Factory.newInstance() ;
				ceType.setArg( seType ) ;	
				seType = ceType ;			
			}
		}
	// JBL: cast ommitted in initial version	//	|	//	castSpecification()
	)
	{ return seType ; }
}

ComparisonType comp_op_S() : 
{
	ComparisonType c = null ;
	Token t = null ;
}
{
	//S:
	// <comp_op> ::=
    //    <equals_operator>
    //  | <not_equals_operator>
    //  | <less_than_operator>
    //  | <greater_than_operator>
    //  | <less_than_or_equals_operator>
    //  | <greater_than_or_equals_operator>
	(
		t=<EQUALS_OPERATOR> 
		|
		t=<NOT_EQUALS_OPERATOR> 
		|
		t=<LESS_THAN_OPERATOR> 
		| 
		t=<GREATER_THEN_OPERATOR> 
		| 
		t=<LESS_THAN_OR_EQUALS_OPERATOR> 
		| 
		t=<GREATER_THAN_OR_EQUALS_OPERATOR>	
	)
	{
		if( t != null )	{
			c = ComparisonType.Factory.newInstance() ;
			c.set( ComparisonType.Enum.forString( t.image.toUpperCase() ) ) ;	
		}
		return c ;
	}
}

ComparisonPredType comparison_predicate_A() : 
{
	ComparisonPredType cpType = null ;
	ScalarExpressionType seType1 = null ;
	ScalarExpressionType seType2 = null ;
	ScalarExpressionType[] args = null ;
	ComparisonType compType = null ;
}
{
	//S:
	//  <row_value_constructor> <comp_op> <row_value_constructor
	( seType1=value_expression_A() compType=comp_op_S() seType2=value_expression_A() )
	{ 
		if( seType2 != null ) {
			cpType = ComparisonPredType.Factory.newInstance() ;
			args = new ScalarExpressionType[2] ;
			args[0] = seType1 ;
			args[1] = seType2 ;
			cpType.setArgArray( args ) ;
			cpType.xsetComparison( compType ) ;	
			
		}
		return cpType ; }
}


String correlation_name_S() : 
{
	String name = null ;
}
{
	//S:
	// <correlation_name> ::= <identifier>
	name=identifier_A()
	{ return name ; }
}

void datetime_factor_S() : {}
{
	//S:
	//  <datetime_factor> ::=
    //     <datetime_primary> [ <time_zone> ]
    
	datetime_primary_S() [  LOOKAHEAD(2) timeZone() ]
}

void datetime_primary_S() : {}
{
	//S:
	// <datetime_primary> ::=
    //    <value_expression_primary>
    //  | <datetime_value_function>

	value_expression_primary_A()
    | 
    datetime_value_function_S()
}

void datetime_term_S() : {}
{
	//S:
	// <datetime_term> ::= <datetime_factor>
    datetime_factor_S()
}

void datetime_value_expression_S() : {}
{
	//S:
	// <datetime_value_expression> ::=
    //    <datetime_term>
    //  | <interval_value_expression> <plus_sign> <datetime_term>
    //  | <datetime_value_expression> <plus_sign> <interval_term>
    //  | <datetime_value_expression> <minus_sign> <interval_term>

	// refactored to
	LOOKAHEAD(3)
    ( datetime_term_S() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) datetime_value_expression_S() )* )
    |
    ( interval_value_expression_S() <PLUS> datetime_term_S() )
}

void datetime_value_function_S() : {}
{
	//S:
	// <datetime_value_function> ::=
    //    <current_date_value_function>
    //  | <current_time_value_function>
    //  | <current_timestamp_value_function>

	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LPAREN> timePrecision() <RPAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LPAREN> timeStampPrecision() <RPAREN> ]
}

void derived_column_list_S() : {}
{
	//S:
	// <derived_column_list> ::= <column_name_list>
   column_name_list_S()	
}

void derived_table_S() : {}
{
	//S:
	// <derived_table> ::= <table_subquery>
   	tableSubQuery()
}

void end_field_S() : {}
{
	//S:
	// <end_field> ::=
    //    <non-second_datetime_field>
    //  | SECOND [ <left_paren> <interval_fractional_seconds_precision> <right_paren> ]
	<NON_SECOND_DATETIME_FIELD> | <SECOND> [ <LPAREN> interval_fractional_seconds_precision_S() <RPAREN> ]
}

void escape_character_A() : {}
{
	//S:
	// <escape_character> ::= <character_value_expression>
	character_value_expression_A()	
}

AtomType exact_numeric_literal_S() : 
{
	AtomType atomType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{ 
	//S:
	//  <exact_numeric_literal> ::=
    //     <unsigned_integer> [ <period> [ <unsigned_integer> ] ]
    //   | <period> <unsigned_integer>

	(
		LOOKAHEAD(3) 
		( t1=<UNSIGNED_INTEGER> [ <DOT> [ t2=<UNSIGNED_INTEGER> ] ] ) 
		| 
		( <DOT> t2=<UNSIGNED_INTEGER> )
	)
	{ 
		if( t1 != null || t2 != null ) {
			atomType = AtomType.Factory.newInstance() ;	
		}
		if( t1 != null && t2 == null ) {
			IntegerType intType = IntegerType.Factory.newInstance() ;
			intType.setValue( new Long( t1.image ).longValue() ) ;
			atomType.setLiteral( intType ) ;
		}
		else if( t1 != null && t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( t1.image + '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}		
		else if( t2 != null ) {
			RealType realType = RealType.Factory.newInstance() ;
			realType.setValue( new Double( '.' + t2.image ).doubleValue() ) ;
			atomType.setLiteral( realType ) ;
		}
		return atomType ;
	}
}

SearchType exists_predicate_S() : 
{
	SearchType st = null ;
}
{
	//S: 
	// <exists_predicate> ::= EXISTS <table_subquery>
	<EXISTS> st=tableSubQuery()
	{ 
		if( st != null ) {
		}
		
		return st ;	
	}	
}

void explicit_table_S() : {}
{
	//S:
	// <explicit_table> ::= TABLE <table_name>
	<TABLE> tableName()
}

ScalarExpressionType factor_S() : 
{
	ScalarExpressionType retType = null ;
	ScalarExpressionType seType = null ;
	UnaryExprType ueType = null ;
}
{
	//S:
	// <factor> ::= [ <sign> ] <numeric_primary>

	( ueType=factoryUnary() seType=numericPrimary() )
	{ 
	   if( ueType != null ) {
	   	  ueType.setArg( seType ) ;
	   	  retType = ueType ;
	   }
	   else {
	   	  retType = seType ;
	   }
	   return retType ;
	}
}

UnaryExprType factoryUnary() : 
{
	UnaryExprType ueType = null ;
	Token t = null ;
}
{
	( [ t=<PLUS> | t=<MINUS> ] )
	{ 
	   if( t != null ) {
	   		ueType = UnaryExprType.Factory.newInstance() ;
	   		ueType.setOper( UnaryOperatorType.Enum.forString( t.image ) ) ;	   	
	   }
	   return ueType ;
	}
}

FromType from_clause_S() : 
{
	FromType fromType = null ;
	FromTableType ftType = null ;
	ArrayList list = new ArrayList() ;
}
{
	( 
	//S:
	// FROM <table_reference>
    // [ { <comma> <table_reference> }... ]
	
		<FROM> ftType=tableReference() { list.add( ftType ) ; } 
		( <COMMA> ftType=tableReference() { list.add( ftType ) ; } )* 
	)
	{
		if( list.size() > 0 ) {
		   fromType = FromType.Factory.newInstance() ;
		   FromTableType[] tableRefArray = new FromTableType[ list.size() ] ;
		   fromType.setTableArray( (FromTableType[])list.toArray(tableRefArray) ) ;				
		}
		return fromType ;
	}
}

AtomType general_literal_A() :
{
	AtomType atomType = null ;	
}
{
	//S:
	//  <general_literal> ::=
    //    <character_string_literal>
    //  | <national_character_string_literal>
    //  | <bit_string_literal>
    //  | <hex_string_literal>
    //  | <datetime_literal>
    //  | <interval_literal>

	atomType=character_string_literal_A()
	{ return atomType ; }	
}

AggregateFunctionType general_set_function_A() : 
{
	AggregateFunctionType afType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ;
}
{
	//S:
	// <general_set_function> ::=
    //   <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>

	// JL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> [ setQuantifier() ] seType=value_expression_A() <RPAREN>	
	( t=<AVG> | t=<MAX> | t=<MIN> | t=<SUM> | t=<COUNT> ) <LPAREN> seType=value_expression_A() <RPAREN>
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			argArray[0] = seType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }	
}

ScalarExpressionType general_value_specification_A() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	//<general_value_specification> ::=
    //   <parameter_specification>
    // | <dynamic_parameter_specification>
    // | <variable_specification>
    // | USER
    // | CURRENT_USER
    // | SESSION_USER
    // | SYSTEM_USER
    // | VALUE
	
	// Foreshortened
	seType=variableSpecification()
	{ return seType ; }	
}

GroupByType group_by_clause_S() : 
{
	GroupByType gbType = null ;
	ArrayList crList = null ;
}
{
	//S:
	// GROUP BY <grouping_column_reference_list>
	<GROUPBY> crList=grouping_column_reference_list_S()
	{
		if(	crList != null ) {
			gbType = GroupByType.Factory.newInstance() ;
			ColumnReferenceType[] colRefArray = new ColumnReferenceType[ crList.size() ] ;
			gbType.setColumnArray( (ColumnReferenceType[])crList.toArray(colRefArray) ) ;	
		}
		return gbType ;
	}
}

ArrayList grouping_column_reference_list_S() : 
{
	ArrayList list = null ;
	ColumnReferenceType cr = null ;
}
{
	//S:
	// <grouping_column_reference_list> ::=
    //   <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]

	(
		cr=grouping_column_reference_A() 
		{ 
			if( list == null )
				list = new ArrayList() ;
			list.add( cr ) ; 
		}
		( <COMMA> cr=grouping_column_reference_A() { list.add( cr ) ; } )* 
	)
	{ return list ; }
}

ColumnReferenceType grouping_column_reference_A() : 
{
	ColumnReferenceType cr = null ;
}
{
	//S:
	// <grouping_column_reference> ::=
    //      <column_reference> [ <collate_clause> ]

	cr=column_reference_S()	
	{ return cr ; }
}

HavingType having_clause_S() :
{
	HavingType hType = null ;
	SearchType sType = null ;
	Token t = null ;
}
{	
	//S:
	//  HAVING <search_condition>	
	( t=<HAVING> sType=searchCondition() )
	{
		if( t != null ) {
			hType = HavingType.Factory.newInstance() ;	
			if( sType != null )
				hType.setCondition( sType ) ;
		}
		return hType ;
	}
}

String identifier_A() : 
{ String retValue ; }
{
	//S:
	// <identifier> ::=
    //   [ <introducer><character_set_specification> ] <actual_identifier>

	retValue=actual_identifier_S()
	{ return retValue ; }
} 

void in_predicate_S() : {}
{
	//S:
	// <in_predicate> ::=
    //   <row_value_constructor> [ NOT ] IN <in_predicate_value>
    //
    // <in_predicate_value> ::= <table_subquery>  | <left_paren> <in_value_list> <right_paren>

	// refactored to
	LOOKAHEAD(3)
	rowValueConstructor() [ <NOT> ] <IN> tableSubQuery() | ( <LPAREN> in_value_list_S() <RPAREN> )  
}

void interval_factor_S() : {}
{
	//S:
	// <interval_factor> ::=
    //   [ <sign> ] <interval_primary>

    [ <PLUS> | <MINUS> ] interval_primary_S()
}

void interval_fractional_seconds_precision_S() : {}
{
	//S:
	// <interval_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_leading_field_precision_S() : {}
{
	//S:
	// <interval_leading_field_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_primary_S() : {}
{
	//S:
	// <interval_primary> ::=
    //    <value_expression_primary> [ <interval_qualifier> ]

      value_expression_primary_A() [ LOOKAHEAD(2) interval_qualifier_S() ]
}

void interval_qualifier_S() : {}
{
	//S:
	// <interval_qualifier> ::=
    //    <start_field> TO <end_field> | <single_datetime_field>

	LOOKAHEAD(3)
    startField() <TO> end_field_S()
    | 
    singleDateTimeField()
}

void interval_term_S() : {}
{
	//S:
	// <interval_term> ::=
    //    <interval_factor>
    //  | <interval_term_2> <asterisk> <factor>
    //  | <interval_term_2> <solidus> <factor>
    //  | <term> <asterisk> <interval_factor>

	// refactored...
	LOOKAHEAD(3)
	interval_factor_S() 
    |
	LOOKAHEAD(3)    
    factor_S() (<STAR> | <DIVIDE>) interval_term_S()
    | 
    term() <STAR> interval_factor_S()
}

void interval_value_expression_S() : {}
{
	//S:
	// <interval_value_expression> ::=
    //    <interval_term>
    //  | <interval_value_expression_1> <plus_sign> <interval_term_1>
    //  | <interval_value_expression_1> <minus_sign> <interval_term_1>
    //  | <left_paren> <datetime_value_expression> <minus_sign>
    //      <datetime_term> <right_paren> <interval_qualifier>

	// refactored
	LOOKAHEAD(3)
	interval_term_S() ( LOOKAHEAD(2) (<PLUS> | <MINUS>) interval_term_S() )*
    | 
    <LPAREN> datetime_value_expression_S() <MINUS> datetime_term_S() <RPAREN> interval_qualifier_S()
}

void in_value_list_S() : {}
{
	//S:
	// <in_value_list> ::=
    //   <value_expression> { <comma> <value_expression> }...
    
    value_expression_A() ( <COMMA> value_expression_A() )*		
}

void join_specification_S() : {}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
	(
		// refactored to...
		<ON> searchCondition()	    |	    <USING> <LPAREN> column_name_list_S() <RPAREN>
    )
}

ComparisonPredType join_specification_A() : 
{
	ComparisonPredType cpType = null ;
}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
	(
		<ON> cpType=comparison_predicate_A()
    )
    { return cpType ; }
}

JoinTableType joined_table_S() : 
{
	JoinTableType jtType = null ;
	Token t = null ;
}
{
	//S:
	// <joined_table> ::=
    //    <cross_join>
    //  | <qualified_join>
    //  | <left_paren> <joined_table> <right_paren>
	(
		LOOKAHEAD(3)
		jtType=cross_join_S()
		|
		LOOKAHEAD(3)
		jtType=qualifiedJoin()
		|
		( t=<LPAREN> jtType=joined_table_S() <RPAREN> )
	)
	{ return jtType ; }
}

JointTableQualifierType join_type_A() :  
{
	JointTableQualifierType jType = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	//S:
	// <join_type> ::=
    //    INNER
    //  | <outer_join_type> [ OUTER ]
    //  | UNION
	(
		// refactored
		t1=<INNER>
	    | 
	    ( t1=<LEFT> | t1=<RIGHT> | t1=<FULL> ) [ t2=<OUTER> ] 
// JL. Adql does not appear to support UNION
//	    | //	    t1=<UNION>
    )
    {
    	if( t1 != null ) {
    		jType = JointTableQualifierType.Factory.newInstance() ;
    		 switch ( t1.kind ) {
    			case AdqlStoXConstants.INNER :
      				jType.set( JointTableQualifierType.INNER );
      				break;
      			case AdqlStoXConstants.LEFT :
      				jType.set( JointTableQualifierType.LEFT_OUTER );
      				break;
      			case AdqlStoXConstants.RIGHT :
      				jType.set( JointTableQualifierType.RIGHT_OUTER );
      				break;
      			case AdqlStoXConstants.FULL :
      				jType.set( JointTableQualifierType.FULL_OUTER );
      				break;
//      			case AdqlStoXConstants.UNION ://      				jType.set( JointTableQualifierType.??? );//      				break;
    		}   		
    	}
    	return jType ;
    }
}


void match_value_S() : {}
{
	//S:
	// <match_value> ::= <character_value_expression>

	character_value_expression_A()	
}

void match_predicate_S() : {}
{
	//S:
	// <match_predicate> ::=
    //   <row_value_constructor> MATCH [ UNIQUE ] [ PARTIAL | FULL ] <table_subquery>

	rowValueConstructor() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] tableSubQuery() 
}

MathFunctionType mathFunctions() : 
{
	MathFunctionType mfType = null ; 
	ScalarExpressionType arg1 = null ;
	Token t = null ;
	Token t2 = null ;
}
{
	(
		( t=<CEILING> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<DEGREES> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<EXP> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<FLOOR> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<PI> <LPAREN><RPAREN> )
		|
		( t=<POWER> <LPAREN> arg1=numericValueExpression() <COMMA> t2=<UNSIGNED_INTEGER> <RPAREN> )
		|
		( t=<RADIANS> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<SQRT> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<LOG10> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<RAND> <LPAREN> [ arg1=numericValueExpression() ] <RPAREN> )
		|
		( t=<ROUND> <LPAREN> arg1=numericValueExpression() <RPAREN> )
		|
		( t=<TRUNCATE> <LPAREN> arg1=numericValueExpression() <RPAREN> )
	)
	{
	   if( t != null ) {
	   	  mfType = MathFunctionType.Factory.newInstance() ;
	   	  mfType.setName( MathFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
	   	  if( arg1 != null ) {
	   	  	 SelectionItemType[] argArray ;
	   	  	 if( t.kind != AdqlStoXConstants.POWER ) {
	   	        argArray = new SelectionItemType[1] ;
	   	        argArray[0] = arg1 ;
	   	  	 }
	   	  	 else {
	   	  	 	argArray = new SelectionItemType[2] ;
	   	  	 	argArray[0] = arg1 ;
	   	  	 	AtomType atomType = AtomType.Factory.newInstance() ;
	   	  	 	IntegerType intType = IntegerType.Factory.newInstance() ;
	   	  	 	intType.setValue( new Long( t2.image ).longValue() ) ;
	   	  	 	atomType.setLiteral( intType ) ;
	   	  	 	argArray[1] = atomType ;
	   	  	 }
	   	     mfType.setArgArray( argArray ) ;
	   	  }
	   }
	   return mfType ;
	}
}

void nullPredicate() : {}
{
	rowValueConstructor() <IS> [ <NOT> ] <NULL>	
}

ScalarExpressionType numericPrimary() : 
{
	ScalarExpressionType seType = null ;
}
{
	( 
	  seType=numericValueFunction()	
	  |	  seType=value_expression_primary_A()
	)
	{ return seType ; } 
	
}

ScalarExpressionType numericValueExpression() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// term() ( LOOKAHEAD(2) ( <PLUS> | <MINUS> ) numericValueExpression() )*
	seType=term() exprPairs=numericValueExpression_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] numericValueExpression_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;
	Token t = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=numericValueExpression_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] numericValueExpression_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<PLUS> | t=<MINUS> ) seType=numericValueExpression()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;					beType = BinaryExprType.Factory.newInstance() ;			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}

ScalarExpressionType numericValueFunction() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		// JBL ADQL adaptation
		seType=trigFunctions()
		|
		seType=mathFunctions()	
	)
	{ return seType ; }
}

OrderExpressionType order_by_clause_A() : 
{
	OrderExpressionType oeType = null ;
	OrderType orderType = null ;
	OrderType[] orderArray = null ;
	ArrayList orderList = null ;
} 
{
	//S:
	//	ORDER BY <sort_specification_list>	//
	// !! with the following expansions
	//	// <sort_specification_list> ::=	//    <sort_specification> [ { <comma> <sort_specification> }... ]	//	// <sort_specification> ::=	//    <sort_key> [ <collate_clause> ] [ <ordering_specification> ]	//	// <sort_key> ::=	//      <column_name>	//    | <unsigned_integer>	//	// <ordering_specification> ::= ASC | DESC
	
	// As opposed to the above, the following is implemented...
	// This seems inadequate. Ie: the use of ScalarExpression in the Xml Schema, and hence value_expression()
	//<ORDERBY> valueExpression() ( <ASC> | <DESC> ) ( <COMMA> valueExpression() ( <ASC> | <DESC> ) )*
	( <ORDERBY> orderType=orderBySingleton() orderList=orderByList() )
	{
		if( orderType != null ) {
			oeType = OrderExpressionType.Factory.newInstance() ;
			if( orderList != null ) {
				orderList.add( 0, orderType ) ;	
				orderArray = new OrderType[ orderList.size() ] ;
				orderArray = (OrderType[])orderList.toArray( orderArray ) ;
			}
			else {
				orderArray = new OrderType[1] ;
				orderArray[0] = orderType ;			
			}	
			oeType.setItemArray( orderArray ) ;
		}
		return oeType ;
	}
}

OrderType orderBySingleton() : 
{
	OrderType orderType = null ;
	ScalarExpressionType se = null ;
	Token t = null ;
	OrderOptionType optionType = null ;
}
{
	( se=value_expression_A() ( t=<ASC> | t=<DESC> ) )
	{
		if( se!=null && t!= null ) {
			optionType = OrderOptionType.Factory.newInstance() ;
			optionType.setDirection( OrderDirectionType.Enum.forString( t.image.toUpperCase() ) ) ;	
			orderType = OrderType.Factory.newInstance() ;
			orderType.setExpression( se ) ;
			orderType.setOrder( optionType ) ;
		}
		return orderType ;
	}
}

ArrayList orderByList() : 
{
	ArrayList list = null ;
	OrderType orderType = null ;
}
{
	( 
		<COMMA> 
		orderType=orderBySingleton() 
		{
			if( orderType != null ) {
				if( list == null ) {
					list = new ArrayList() ;
				}
				list.add( orderType ) ;	
			}	
		}
	)*
	{ return list ; }
}

void overlapsPredicate() : {}
{
	rowValueConstructor() <OVERLAPS> rowValueConstructor()	
}

void pattern() : {}
{
	character_value_expression_A()	
}

SearchType predicate_A() : 
{
	SearchType searchType = null ;
}
{
	//S:
	//    <comparison_predicate>	//    | <between_predicate>	//    | <in_predicate>	//    | <like_predicate>	//    | <null_predicate>	//    | <quantified_comparison_predicate>	//    | <exists_predicate>	//    | <unique_predicate>	//    | <match_predicate>	//    | <overlaps_predicate>
	(
 		LOOKAHEAD(4)
		searchType=comparison_predicate_A()
	    | 
	    LOOKAHEAD(3)
	    searchType=between_predicate_A()
//	    |//	    inPredicate()//	    |//	    searchType=likePredicate()//	    | 
// adql does not support the null predicate!
//	    LOOKAHEAD(3)//	    nullPredicate()//	    | 
// adql does not support quantified comparisons
//	    LOOKAHEAD(3)//		quantifiedComparisonPredicate()//	    |
// adql does not support EXISTS //	    existsPredicate()//	    | 
// adql does not support UNIQUE//	    uniquePredicate()//	    | 
// adql does not support match
//	    LOOKAHEAD(3)//	    matchPredicate()//	    | 
// adql does not support overlap//	    overlapsPredicate()
    )
    { return searchType ; }
}

JoinTableType qualifiedJoin() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
	JointTableQualifierType jtqType = null ;
	ComparisonPredType cpType = null ;
}
{
	(
		fType1=tableReferenceBarJoinedTable() 
		[ <NATURAL> ] 
		jtqType=join_type_A() 
		<JOIN> 
		fType2=tableReference() 
		[ LOOKAHEAD(3) cpType=join_specification_A() ]
	)
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	      jtType.xsetQualifier( jtqType ) ;
	      if( cpType != null ) {
	      		jtType.setCondition( cpType ) ;
	      }
	   }
	   return jtType ;	
	}
}

String qualifiedName() : 
{
	String retValue ;
} 
{
	retValue = identifier_A()
	{ return retValue ; }	
}

String qualifier() : 
{	
	String retValue ;
}
{
	// Foreshortened
	retValue=tableName()
	{ return retValue ; }
}

SelectType query_specification_A() : 
{
	SelectType st = null ;
	ArrayList tableList = null ;
	SelectionListType listType = null ;
	SelectionLimitType limitType = null ;
	SelectionOptionType optionType = null ;
	Token t = null ;
}
{ 
	(
	//S:
	// SELECT [ <set_quantifier> ] <select_list> <table_expression>
	//
		t=<SELECT> 
		[ optionType=set_quantifier_S() ] 
		[ limitType=set_limit_A() ] 
		listType=select_list_S() 
		tableList=table_expression_A()
	)
	{ 
		if( t != null ) {
			st = SelectType.Factory.newInstance() ;
			if( optionType != null ) {
				st.setAllow( optionType ) ;	
			}
			if( limitType != null ) {
				st.setRestrict( limitType ) ;	
			}
			if( listType != null ) {
				st.setSelectionList( listType ) ;	
			}
			ListIterator iterator = tableList.listIterator() ;
			while( iterator.hasNext() ) {
				Object obj = iterator.next() ;
				if( obj instanceof FromType ) {
					st.setFrom( (FromType)obj ) ;	
				}
				else if( obj instanceof WhereType ) {
					st.setWhere( (WhereType)obj ) ;
				}
				else if( obj instanceof GroupByType ) {
					st.setGroupBy( (GroupByType)obj ) ;
				}
				else if( obj instanceof HavingType ) {
					st.setHaving( (HavingType)obj ) ;	
				}
				else if( obj instanceof OrderExpressionType ) {
					st.setOrderBy( (OrderExpressionType)obj ) ;
				}			
			}			
		}
		return st  ; 
	}
}

void rowSubquery() : {}
{
	subQuery()	
}

ScalarExpressionType rowValueConstructor() : 
{
	ScalarExpressionType seType = null ;
}
{
	// <row_value_constructor_element> 
	// | <left_paren> <row_value_constructor_list> <right_paren>
    // | <row_subquery>
	(
		LOOKAHEAD(3)
		rowValueConstructorElement()
	    | 
	    LOOKAHEAD(2)
	    <LPAREN> rowValueConstructorList() <RPAREN>
	    | 
	    rowSubquery()
	 )
	 { return seType ; }
}

ScalarExpressionType rowValueConstructorElement() : 
{
	ScalarExpressionType seType = null ;
} 
{
	// <value_expression> | <null_specification> | <default_specification>
	// foreshortened...
	seType=value_expression_A()
// adql has nothing to support the embedding of keywords...
//    | //    <NULL>//    | //    <SQL_DEFAULT>

	{ return seType ; }
}

void rowValueConstructorList() : {}
{
	rowValueConstructorElement() ( <COMMA> rowValueConstructorElement() ) *
}

void scalarSubquery() : {}
{
	subQuery()
}

SearchType searchCondition() : 
{
	SearchType st=null ;
	SearchType[] stPairs = null ;

}
{
	// refactored
	// ( boolean_term_S() ( <OR> boolean_term_S() )* )
	( st=boolean_term_S() stPairs=booleanTermList() )
	{
		if( stPairs == null ) {
		   return st ; 
		}
		else {
		   SearchType[] conditionArray = new SearchType[2] ;
		   conditionArray[0] = st ;
		   conditionArray[1] = stPairs[1] ;
		   UnionSearchType usType = (UnionSearchType)stPairs[0] ;
		   usType.setConditionArray( conditionArray ) ;
		   return usType ;
		}	
	}
}

SearchType[] booleanTermList() : 
{
	ArrayList list = null ;
	SearchType[] stPairs1 = null ;
	SearchType[] stPairs2 = null ;
	SearchType[] retPairs = null ;	
}
{
	( stPairs1=booleanTermSingleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( stPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retPairs = stPairs1 = (SearchType[])iterator.next() ;
			SearchType[] conditions = new SearchType[2] ;
			UnionSearchType usType = null ;
			while( iterator.hasNext() ) {
				stPairs2 = (SearchType[])iterator.next() ;
				conditions[0] = stPairs1[1] ;
				conditions[1] = stPairs2[1] ;
				usType = (UnionSearchType)stPairs2[0] ;
				usType.setConditionArray( conditions ) ;
				stPairs1 = stPairs2 ;
			}
		}		
		return retPairs ;
	}
}

SearchType[] booleanTermSingleton() :
{
	SearchType[] retPairs = null ;
	UnionSearchType us = null ;
	SearchType st = null ;
}
{
	( <OR> st=boolean_term_S() )
	{
		if( st != null ) {
			retPairs = new SearchType[2] ;		
			us = UnionSearchType.Factory.newInstance() ;
			retPairs[0] = us ;
			retPairs[1] = st ;
		}
		return retPairs ;
	}
}

SelectionListType select_list_S() : 
{
	ArrayList itemList = new ArrayList() ;
	SelectionListType slType = SelectionListType.Factory.newInstance() ;
}
{
	//S:
	//   <asterisk>
    // | <select_sublist> [ { <comma> <select_sublist> }... ]
	(
		allSelectionItem( itemList ) 
		| 
		( select_sublist_A( itemList ) ( <COMMA> select_sublist_A( itemList ) )* )
	)
	{
		if( itemList.size() > 0 ) {
			SelectionItemType[] itemArray = new SelectionItemType[ itemList.size() ] ;	
			slType.setItemArray( (SelectionItemType[])itemList.toArray(itemArray) ) ;
		}
		return slType ;	
	}
}

void allSelectionItem( ArrayList itemList ) : {}
{
	<STAR>
	{ itemList.add( AllSelectionItemType.Factory.newInstance() ) ; }
}

void select_sublist_A( ArrayList itemList ) : 
{ 
	SelectionItemType siType = null ;
}
{   
	//S:
	//   <derived_column>
    // | <qualifier> <period> <asterisk>
    
	siType=derived_column_S()
	{ itemList.add( siType ) ; }			
}

SelectionItemType derived_column_S() : 
{
	ScalarExpressionType seType = null ;
	String aliasName = null ;
}
{
	//S:
	// <derived_column> ::= <value_expression> [ <as_clause> ]
	// <as_clause> ::= [ AS ] <column_name>
	
	( seType=value_expression_A() [ [<AS>] aliasName=column_name_S() ] )	
	{ 
		if( aliasName != null ) {
			AliasSelectionItemType asiType = AliasSelectionItemType.Factory.newInstance() ;
			asiType.setAs( aliasName ) ;
			asiType.setExpression( seType ) ;
			return asiType ;	
		}
		return seType ; 
	}	
}

AggregateFunctionType setFunctionSpecification() : 
{
	AggregateFunctionType afType = null ;
	Token t = null ;
}
{
	(
		LOOKAHEAD(3)
		( t=<COUNT> <LPAREN> <STAR> <RPAREN> ) 
		|
		afType=general_set_function_A()
	)
	{ 
		if( t != null ) {
			afType = AggregateFunctionType.Factory.newInstance() ;
			afType.setName( AggregateFunctionNameType.COUNT ) ;
			SelectionItemType[] argArray = new SelectionItemType[1] ;
			AtomType atomType = AtomType.Factory.newInstance() ;
			StringType star = StringType.Factory.newInstance() ;
			star.setValue( "*" ) ;
			atomType.setLiteral( star ) ;
			argArray[0] = atomType ;
			afType.setArgArray( argArray ) ;
		}
		return afType ; }
}

SelectionLimitType set_limit_A() : 
{ 
	SelectionLimitType sl = null ;
	Token t1 = null ;
	Token t2 = null ;
}
{
	// There is no equivalent in the SQL/92 standard
	//
	<TOP> <LPAREN> t1=<UNSIGNED_INTEGER> t2=<RPAREN>
	{ 
		if( t2 != null ) {
			sl = SelectionLimitType.Factory.newInstance() ;
			sl.setTop( ( new Integer( t1.image )).intValue() ) ;
		}
	return sl ;	
	}
}

SelectionOptionType set_quantifier_S() : 
{
	SelectionOptionType selectionOption = null ;
	Token t ;
}
{
	//S:
	// DISTINCT | ALL
	//
	t=<DISTINCT> | t=<ALL>
	{ 	
		if( t != null ) {
			selectionOption = SelectionOptionType.Factory.newInstance() ;
			if( t.kind == AdqlStoXConstants.ALL ) {
				selectionOption.setOption( AllOrDistinctType.ALL ) ;
			}
			else {
				selectionOption.setOption( AllOrDistinctType.DISTINCT ) ;
			}
		}
		return selectionOption ;
	}
}

void singleDateTimeField() : {}
{
	<NON_SECOND_DATETIME_FIELD> [ <LPAREN> interval_leading_field_precision_S() <RPAREN> ]
    | 
    <SECOND> [ <LPAREN> interval_leading_field_precision_S() [ <COMMA> interval_fractional_seconds_precision_S() ] <RPAREN> ]
}

void startField() : {}
{
    <NON_SECOND_DATETIME_FIELD> [ <LPAREN> interval_leading_field_precision_S() <RPAREN> ]
}

ScalarExpressionType string_value_expression_A() :
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <string_value_expression> ::=
    //    <character_value_expression>
    //  | <bit_value_expression>

	seType=character_value_expression_A()
	{ return seType ; }
}

SearchType subQuery() : 
{
	SearchType st = null ;
}
{
	<LPAREN> queryExpression() <RPAREN>
	{ return st ; }		
}

SearchType subQuery_AG() : 
{
	SearchType st = null ;
}
{
	<LPAREN> queryExpression() <RPAREN>
	{ return st ; }		
}

void quantifiedComparisonPredicate() : {}
{
	rowValueConstructor() comp_op_S() quantifier() tableSubQuery()	
}

void quantifier() : {}
{
	<ALL> | ( <SOME> | <ANY> )	
}

void queryExpression() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryExpression()
	|
	joined_table_S()
}

void queryPrimary() : {}
{
    LOOKAHEAD(3)
 	nonJoinQueryPrimary()
    | 
    joined_table_S()
}


void queryTerm() : {}
{
	LOOKAHEAD(2)
	nonJoinQueryTerm()
	|
	joined_table_S()	
}

void corresponding_spec_S() : {}
{
	//S:
	// <corresponding_spec> ::=
    //    CORRESPONDING [ BY <left_paren> <corresponding_column_list> <right_paren> ]
	<CORRESPONDING> [ <BY> <LPAREN> corrsponding_column_list_S() <RPAREN> ] 
}
    
void corrsponding_column_list_S() : {}
{
	//S:
	// <corresponding_column_list> ::= <column_name_list>
	column_name_list_S()	
}
/*
 * I think at a shallow level this refactoring is the same as the standard.
 * But one level down it definitely is not.
 */
JoinTableType cross_join_S() : 
{
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	//S:
	// <cross_join> ::=
    //    <table_reference> CROSS JOIN <table_reference>
	( fType1=tableReferenceBarJoinedTable() <CROSS_JOIN> fType2=tableReference() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JointTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   return jtType ;	
	}
}


void nonJoinQueryExpression() : {}
{
// Originally ...
//	nonJoinQueryTerm()//	|//	queryExpression() <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm()//	|//	queryExpression() <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm()

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	
//	LOOKAHEAD(3)//	queryTerm() ( <UNION> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	LOOKAHEAD(3)//	queryTerm() ( <EXCEPT> [ <ALL> ] [ correspondingSpec() ] queryTerm() )*//	|//	nonJoinQueryTerm()

	LOOKAHEAD(4)
	queryTerm() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ corresponding_spec_S() ] queryTerm() )*
	|
	nonJoinQueryTerm()
}

void nonJoinQueryTerm() : {}
{
	LOOKAHEAD(3)
	nonJoinQueryPrimary()
	|
	queryPrimary() <INTERSECT> [ <ALL> ] [ corresponding_spec_S() ] queryPrimary()	
}

void nonJoinQueryPrimary() : {}
{
	simpleTable()
	|
	<LPAREN> nonJoinQueryExpression() <RPAREN>
}

void simpleTable() : {}
{
	query_specification_A()
	|
	tableValueConstructor()
	|
	explicit_table_S()	
}

ArrayList table_expression_A() : 
{
	ArrayList list = new ArrayList() ;
	Object obj = null ;
} 
{
	//S:
	// <from_clause>
    // [ <where_clause> ]
    // [ <group_by_clause> ]
    // [ <having_clause> ]
	(
		obj=from_clause_S() { if( obj!=null ) list.add(obj) ; } 
		[ obj=where_clause_S() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=group_by_clause_S() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=having_clause_S() { if( obj!=null ) list.add(obj) ; } ] 
		[ obj=order_by_clause_A() { if( obj!=null ) list.add(obj) ; } ]	
	)
	{ return list ;	}
}

String tableName() : 
{
	String retValue = null ;
}
{
	// Forshortened
	retValue=qualifiedName()
	{ return retValue ; }
}

FromTableType tableReference() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
} 
{
	(
		// refactored... 
		// 1. derivedTable() moved to first choice point
		// 2. joinedTable() moved to second choice point
//	    LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName() [ <LPAREN> derived_column_list_S() <RPAREN> ]//	    |	//		LOOKAHEAD(4)//	    joinedTable()//	    |//		tableName() [ [ <AS> ] correlationName() [ <LPAREN> derived_column_list_S() <RPAREN> ] ]    

		// Foreshortened. 
		// derivedColumnList not supported in adql
		// derivedTable not supported in adql
//		LOOKAHEAD(4)//	    derivedTable() [ <AS> ] correlationName()//	    |	
		LOOKAHEAD(4)
	    ftType=joined_table_S()
	    |
		( tName=tableName() [ [ <AS> ] cName=correlation_name_S() ] )
		{
			if( tName != null ) {	
				TableType tableType = TableType.Factory.newInstance() ;
				tableType.setName( tName ) ;
				if( cName != null )
					tableType.setAlias( cName ) ;
				ftType = tableType ;
			}
		} 
	)
	{ return ftType ; } 
}

// Adaptation of tableReference()
FromTableType tableReferenceBarJoinedTable() : 
{
	FromTableType ftType = null ;
	String tName = null ;
	String cName = null ;
}
{
	( tName=tableName() [ [ <AS> ] cName=correlation_name_S() ] )
	{
		if( tName != null ) {	
			TableType tableType = TableType.Factory.newInstance() ;
			tableType.setName( tName ) ;
			if( cName != null )
				tableType.setAlias( cName ) ;
			ftType = tableType ;
		}
	}
	{ return ftType ; }
}

SearchType tableSubQuery() : 
{
	SearchType st = null ;
}
{
	st=subQuery()	
	{ return st ; }
}

void tableValueConstructor() : {}
{
	<VALUES> tableValueConstructorList()
}

void tableValueConstructorList() : {}
{
	rowValueConstructor() ( <COMMA> rowValueConstructor() )*	
}

//ScalarExpressionType term() : //{//	ScalarExpressionType seType = null ;//}//{//	// refactored//	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*//	factor() term_List() //	{ return seType ; }//}

ScalarExpressionType term() : 
{
	ScalarExpressionType seType = null ;
	ScalarExpressionType[] exprPairs = null ;
}
{
	// refactored
	// factor() ( LOOKAHEAD(2) (<STAR> | <DIVIDE> ) term() )*
	seType=factor_S() exprPairs=term_List()
	{ 
		if( exprPairs == null ) {
		   return seType ; 
		}
		else {
		   ScalarExpressionType[] args = new ScalarExpressionType[2] ;
		   args[0] = seType ;
		   args[1] = exprPairs[1] ;
		   BinaryExprType beType = (BinaryExprType)exprPairs[0] ;
		   beType.setArgArray( args ) ;
		   return beType ;
		}	
	}
}

ScalarExpressionType[] term_List() : 
{
	ArrayList list = null ;
	ScalarExpressionType[] exprPairs1 = null ;
	ScalarExpressionType[] exprPairs2 = null ;
	ScalarExpressionType[] retExprPairs = null ;	
}
{
	( LOOKAHEAD(3) exprPairs1=term_Singleton() 
	  { if( list == null )
	  	   list = new ArrayList() ;
	  	list.add( exprPairs1 ) ;
	  } 
	)*
	{ 
		if( list != null ) {
			ListIterator iterator = list.listIterator() ;
			retExprPairs = exprPairs1 = (ScalarExpressionType[])iterator.next() ;
			ScalarExpressionType[] args = new ScalarExpressionType[2] ;
			BinaryExprType beType = null ;
			while( iterator.hasNext() ) {
				exprPairs2 = (ScalarExpressionType[])iterator.next() ;
				args[0] = exprPairs1[1] ;
				args[1] = exprPairs2[1] ;
				beType = (BinaryExprType)exprPairs2[0] ;
				beType.setArgArray( args ) ;
				exprPairs1 = exprPairs2 ;
			}
		}		
		return retExprPairs ;
	}
}

ScalarExpressionType[] term_Singleton() :
{
	ScalarExpressionType[] retPairs = null ;
	BinaryExprType beType = null ;
	ScalarExpressionType seType = null ;
	Token t = null ; 
}
{
	( t=<STAR> | t=<DIVIDE> ) seType=term()	
	{
		if( t != null ) {
			retPairs = new ScalarExpressionType[2] ;		
			beType = BinaryExprType.Factory.newInstance() ;
			beType.setOper( BinaryOperatorType.Enum.forString( t.image ) ) ;
			retPairs[0] = beType ;
			retPairs[1] = seType ;
		}
		return retPairs ;
	}
}




void timeFractionalSecondsPrecision() : {}
{
	<UNSIGNED_INTEGER> 	
}

void timePrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeStampPrecision() : {}
{
	timeFractionalSecondsPrecision()	
}

void timeZone() : {}
{
	// refactored
    <AT> ( <LOCAL> | (<TIME_ZONE> interval_value_expression_S() ) ) 
}

TrigonometricFunctionType trigFunctions() : 
{
	TrigonometricFunctionType tfType = null ; 
	ScalarExpressionType arg1 = null ;
	ScalarExpressionType arg2 = null ;
	Token t = null ;
}
{
	(
		t=<ACOS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ASIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<ATAN2> <LPAREN> arg1=numericValueExpression() <COMMA> arg2=numericValueExpression() <RPAREN>
		|
		t=<COS> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<COT> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<SIN> <LPAREN> arg1=numericValueExpression() <RPAREN>
		|
		t=<TAN> <LPAREN> arg1=numericValueExpression() <RPAREN>
	)
	{
		if( t != null ) {
			ScalarExpressionType[] argArray = null ;
			tfType = TrigonometricFunctionType.Factory.newInstance() ;
			tfType.setName( TrigonometricFunctionNameType.Enum.forString( t.image.toUpperCase() ) ) ;
			if( arg2 != null ) {
				argArray = new ScalarExpressionType[2] ;
				argArray[0] = arg1 ;
				argArray[1] = arg2 ;
			}
			else {
				argArray = new ScalarExpressionType[1] ;
				argArray[0] = arg1 ;
			}
			tfType.setArgArray( argArray ) ;
		}
		return tfType ;
	}
}

void uniquePredicate() : {}
{
	<UNIQUE> tableSubQuery()	
}

AtomType unsignedLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
		// foreshortened
	    atomType=unsignedNumericLiteral()
		| 		atomType=general_literal_A()
	)
	{ return atomType ; }
}

AtomType unsignedNumericLiteral() : 
{
	AtomType atomType = null ;
}
{
	(
// JL. Note the adql/x schema does not possess an approximateNumericLiteral
//		LOOKAHEAD(3)//		exactNumericLiteral()//	    | //	    approximate_numeric_literal_S()

		atomType=exact_numeric_literal_S()
    )
    { return atomType ; }
}


ScalarExpressionType unsignedValueSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	(
		seType=unsignedLiteral()
		|
		general_value_specification_A()
	)
	{ return seType ;  }
}

ScalarExpressionType value_expression_A() : 
{
	ScalarExpressionType retValue = null ;
} 
{
	//S:
	// <numeric_value_expression>
    // | <string_value_expression>
    // | <datetime_value_expression>
    // | <interval_value_expression>
	(
	LOOKAHEAD(3) 
	retValue=numericValueExpression() 
	|
	LOOKAHEAD(3) 	
	retValue=string_value_expression_A() 
	// JL. foreshortened. At present there seems no accommodation for
	// datetime and interval expressions in adql
//	|//	LOOKAHEAD(3) //	dateTimeValueExpression() //	|//	intervalValueExpression()
	)
	{ return retValue ; }
	
}

ScalarExpressionType variableSpecification() : 
{
	ScalarExpressionType seType = null ;
}
{
	// JBL ADQL adaptation to accommodate scripting variables.
	// Details still to be worked out.
	<DOLLAR> <LBRACE> <REGULAR_IDENTIFIER> <RBRACE>
	{ return seType ; }
}

WhereType where_clause_S()        : 
{/*@bgen(jjtree) Where */
        ASTWhere jjtn000 = new ASTWhere(this, JJTWHERE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	WhereType whereType = null ;
	SearchType s = null ;
	Token t = null ;
}
{/*@bgen(jjtree) Where */
        try {
/*@egen*/
	//S:
	// WHERE <search_condition>
	t=<WHERE> s=searchCondition()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ 
		if( t != null )
			whereType = WhereType.Factory.newInstance() ;
		if( s != null ) {
			whereType.setCondition( s ) ;
		}
		jjtn000.searchType = s ; 
	  	return whereType ;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
/* 
$Log: AdqlStoX.jj,v $
Revision 1.8  2006/09/27 20:51:55  jl99
Reorg on method naming convention: 3.

Revision 1.10  2006/09/26 13:44:11  jl99
Reorg on method naming convention: 1.

*/


