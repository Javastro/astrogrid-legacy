#! /opt/local/bin/scsh \
-e main -s
!#

;; Reads in a file in Ntriples format, and normalises it.  That means
;; imposing a consistent ordering on it (by predicate, then subject,
;; then object, with blank nodes being ordered after everything), and
;; then renumbering the blank nodes.
;;
;; 1. The set of triples is ordered in a way which is independent of the 
;;    blank nodes' ID (by subject, then predicate, then object, with
;;    blank nodes ordering after everything, and all equal to each other).
;;
;; 2. We work through this list in order, replacing all the blank
;;    nodes with new ones with prettier names.
;;
;; 3. Then, just for the sake of readability, we sort the list again,
;;    using a comparator which still orders blank nodes after
;;    everything, but which now also pays attention to the blank node
;;    IDs.
;;
;; The only way this fails to be completely independent of the input
;; is when we get a subject-predicate-blank triple, or
;; blank-predicate-object triple, where the non-blank slots are the
;; same.  In that desperate situation, we can give the
;; --suppress-blank-nodes option.

(define (main args)
  (let ((reduced-args (reduce-options (cdr args))))
    (let ((triples (sort-list (if (< (length reduced-args) 1)
                                  (read-triples (current-input-port))
                                  (call-with-input-file (car reduced-args)
                                    read-triples))
                              triple<=?-no-symbols)))
      (for-each (lambda (t)
                  (let ((subj (car t))
                        (pred (cadr t))
                        (obj  (caddr t)))
                    (format #t "~a	~a	~a	.~%"
                            subj
;;                             (if (symbol? subj)
;;                                 (get-new-blank-node subj)
;;                                 subj)
                            pred
                            obj
;;                             (if (symbol? obj)
;;                                 (get-new-blank-node obj)
;;                                 obj)
                            )))
                (sort-list (replace-symbols triples)
                           triple<=?-with-symbols)))))

;; REPLACE-SYMBOLS : list of lists -> list of lists
;; Replace each symbol in the list with a new one from GET-NEW-BLANK-NODE
(define (replace-symbols l)
  (cond ((null? l)
         '())
        ((list? (car l))
         (cons (replace-symbols (car l))
               (replace-symbols (cdr l))))
        ((symbol? (car l))
         (cons (get-new-blank-node (car l))
               (replace-symbols (cdr l))))
        (else
         (cons (car l)
               (replace-symbols (cdr l))))))

;; READ-TRIPLES port -> list
;; Read triples from a port, parsing them to three-element lists, with
;; all blank nodes represented by symbols.
(define (read-triples port)
  (define (parse-line line triples)
    (cond ((regexp-search? (rx (: bos
                                  (* whitespace)
                                  (? #\# (* any))
                                  eos))
                           line)
           triples)
          ((regexp-search (rx (: (submatch (or (: #\< (* (~ #\>)) #\>)
                                               (: #\_ #\: (* alphanumeric))))
                                 (+ whitespace)
                                 (submatch (: #\< (* (~ #\>)) #\>))
                                 (+ whitespace)
                                 (submatch (or (: #\< (* (~ #\>)) #\>)
                                               (: #\_ #\: (* alphanumeric))
                                               (: #\" (* (~ #\")) #\")))))
                          line)
           => (lambda (m)
                (let ((subj (compress-file-urls (match:substring m 1)))
                      (obj  (compress-file-urls (match:substring m 3))))
                (cons (list (if (eq? (string-ref subj 0) #\_)
                                ;(get-new-blank-node subj)
                                (string->symbol subj)
                                subj)
                            (match:substring m 2)
                            (if (eq? (string-ref obj 0) #\_)
                                ;(get-new-blank-node obj)
                                (string->symbol obj)
                                obj))
                      triples))))
          (else
           (format (current-error-port) "Unmatched line: ~a~%" line)
           triples)))
  (port-fold port read-line parse-line '()))

;; Strip any directory (specifically $PWD) from file URLs
(define (compress-file-urls f)
  (cond ((regexp-search (rx (: bos
                               "<file:"
                               (* any)
                               #\/
                               (submatch (+ (~ #\/)))
                               #\>
                               eos))
                        f)
         => (lambda (m)
              (string-append "<file:" (match:substring m 1) ">")))
        (else
         f)))

;; GET-NEW-BLANK-NODE symbol -> symbol
;; Given a symbol, return a new blank-node string (ie, "_:nnn") for
;; it; but if we've seen this symbol before, return the same string as before.
;;
;; If (option-suppress-bn) is true, however, then always return exactly
;; the same _:? symbol
(define get-new-blank-node
  (let ((known-nodes '()))
    (lambda (bnode-name)
      (if (option-suppress-bn)
          '_:?
          (cond ((assoc bnode-name known-nodes)
                 => cdr)
                (else
                 (let ((new-node-name
                        (string->symbol
                         ;; make pretty/short names which order nicely
                         (let ((l (length known-nodes)))
                           (cond ((< l 10)
                                  (format #f "_:~a" l))
                                 (else
                                  (format #f "_:~a~a"
                                          (ascii->char (+ 96 (quotient l 10)))
                                          (remainder l 10))))))))
                   (set! known-nodes (cons (cons bnode-name new-node-name)
                                           known-nodes))
                   new-node-name)))))))

;; CMP-STRING-OR-SYMBOL: return -1/0/+1 if a </=/> b.
;; Order symbols later than all strings, and equal to each other.
(define (cmp-string-or-symbol a b)
    (cond ((and (symbol? a) (symbol? b))
           0)
          ((symbol? a)
           +1)
          ((symbol? b)
           -1)
          ((string<? a b)
           -1)
          ((string=? a b)
           0)
          (else
           +1)))
(define (cmp-strings a b)
  (cond ((and (symbol? a) (symbol? b))
         (let ((sa (symbol->string a))
               (sb (symbol->string b)))
           (cond ((string<? sa sb)
                  -1)
                 ((string=? sa sb)
                  0)
                 (else
                  +1))))
        ((symbol? a)
         +1)
        ((symbol? b)
         -1)
        ((string<? a b)
         -1)
        ((string=? a b)
         0)
        (else
         +1)))

;; Use cmp
(define-syntax <=3?
  (syntax-rules ()
    ((_ cmp v1 v2 next)
     (case (cmp v1 v2)
       ((-1) #t)
       ((+1) #f)
       (else
        next)))))

(define (triple<=?-no-symbols a b)
  (<=3? cmp-string-or-symbol
        (car a) (car b)
        (<=3? cmp-string-or-symbol
              (cadr a) (cadr b)
              (<=3? cmp-string-or-symbol
                    (caddr a) (caddr b)
                    #t))))

(define (triple<=?-with-symbols a b)
  (<=3? cmp-strings
        (car a) (car b)
        (<=3? cmp-strings
              (cadr a) (cadr b)
              (<=3? cmp-strings
                    (caddr a) (caddr b)
                    #t))))

;; TRIPLE-BY-SUBJECT<=? triple triple -> boolean
;; Given two triples, return #t if the first is <= the second.  The
;; ordering is by subject, then predicate, then object, with a symbol
;; in any position ordering after all strings.
;; (define (triple-by-subject<=? a b)
;;   (<=3? cmp-strings
;;         (car a) (car b)                 ;subject
;;         (<=3? cmp-strings
;;               (cadr a) (cadr b)         ;predicate
;;               (<=3? cmp-strings
;;                     (caddr a) (caddr b) ;object
;;                     #t))))
                                        ;equal

;; TRIPLE-BY-PREDICATE<=? triple triple -> boolean
;; The same, but predicate-subject-object
;; (define (triple-by-predicate<=? a b)
;;   (<=3? cmp-strings
;;         (cadr a) (cadr b)
;;         (<=3? cmp-string-or-symbol
;;               (car a) (car b)
;;               (<=3? cmp-string-or-symbol
;;                     (caddr a) (caddr b)
;;                     #f))))

(define (sort-list l <=)
  (define (merge-lists ina inb)
    (let loop ((res '())
               (a ina)
               (b inb))
      (cond
       ((null? a)
        (append (reverse res) b))
       ((null? b)
        (append (reverse res) a))
       (else
        (if (<= (car a) (car b))
            (loop (cons (car a) res)
                  (cdr a)
                  b)
            (loop (cons (car b) res)
                  a
                  (cdr b)))))))

  (define (partition-list pe inl)
    (let loop ((pa '())
               (pb '())
               (l inl))
      (if (null? l)
          (values pa pb)
          (if (<= (car l) pe)
              (loop (cons (car l) pa) pb (cdr l))
              (loop pa (cons (car l) pb) (cdr l))))))

  (case (length l)
    ((0 1) l)
    ((2) (if (<= (car l) (cadr l))
             l
             (list (cadr l) (car l))))
    (else
     (let ((pe (car l)))
       (call-with-values
           (lambda () (partition-list pe (cdr l)))
         (lambda (left right)
           (merge-lists (sort-list left <=) (cons pe (sort-list right <=)))))))))

(define (make-option default)
  (let ((v default))
    (lambda a
      (if (null? a)
          v
          (set! v (car a))))))
(define option-suppress-bn (make-option #f))
;;(define option-order-predicate (make-option triple-by-predicate<=?))
(define (reduce-options option-list)
  (cond ((null? option-list)
         option-list)
        ((regexp-search (rx (: bos #\- #\-
                               (submatch (* any))))
                        (car option-list))
         => (lambda (m)
              (case (string->symbol (match:substring m 1))
                ((suppress-blank-nodes)
                 (option-suppress-bn #t))
;;                 ((order-by-subject)
;;                  (option-order-predicate triple-by-subject<=?))
                (else
                 (error "Unrecognised option ~s" (car option-list))))
              (reduce-options (cdr option-list))))
        (else
         option-list)))
