;; This script is a partner to the ../xschemas/xschema2rdfs.lx script,
;; which generates the RDFSchema which this script targets.  Points of
;; correspondence are marked [tag].  Refer to that script for more
;; documentation.
;;
;; Notes:
;;
;; x2s:propertyName : When propertyName is present, we should not generate
;; any property-name element, but leave that to the type handler.
;; This handler will have to be hand-written (ie, it will be in the 
;; VOResource handler); that means that there's no corresponding support
;; for this in xschema2rdfs.lx.
;; The propertyName annotation is used (for example) for validationLevel in
;; SIA, which is annotated in the XSchema with the x2s:propertyName
;; being vor:validationLevel.
;;
;;
;;
;; THE PLAN
;;
;; See the same-named section at the top of xschema2rdfs

(lx:let ((namespace (xsl "http://www.w3.org/1999/XSL/Transform")
                    (#f "http://www.w3.org/1999/XSL/Transform")
                    (xt "http://www.w3.org/1999/XSL/TransformAlias")
                    (xs "http://www.w3.org/2001/XMLSchema")
                    (x2s "http://ns.eurovotech.org/registry-metadata#")
                    ;;(dc "http://purl.org/dc/elements/1.1/")

                    (vor "http://www.ivoa.net/xml/VOResource/v1.0")
                    (voro "http://www.ivoa.net/xml/VOResource/v1.0#")

                    (rdf  "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
                    ;(rdfs "http://www.w3.org/2000/01/rdf-schema#")
                    ;(owl  "http://www.w3.org/2002/07/owl#")
                    )
         (feature "http://ns.nxg.me.uk/lx/attributes-in-no-namespace")
         (dtd (template (match #t) mode)
              (element (name #t))
              (attribute (name #t))
              (value-of (select #t))
              (when (test #t))
              (if (test #t))
              (with-param (name #t) select)))

(stylesheet version: 1.0
  (output method: xml
              version: 1.0
              indent: yes)

  (key name: classes
       match: "xs:simpleType|xs:complexType"
       use: @name)

  ;; We're generating an XSLT stylesheet, so we need to use the namespace-alias
  ;; trick to distinguish the XSL elements in this stylesheet from the
  ;; XSL elements in the result.
  (namespace-alias stylesheet-prefix: xt result-prefix: xsl)

  ;; There's quite a lot of namespace cleverness in this script.
  ;;
  ;; The output script, when run, generates elements in an
  ;; ontology/RDFS namespace, which isn't otherwise referred to in
  ;; this script or in the source XSchema.  Thus we have to copy it in
  ;; explicitly from the (generated) set of namespaces in the file
  ;; namespace-nodes.xml: it's the namespace node which has the
  ;; namespace formed from the source XSchema's @targetNamespace, with
  ;; a '#' appended. [targetns]
  ;;
  ;; We copy the namespace node in the xs:schema template below.
  ;; Here, we simply extract the prefixes of the XSchema and
  ;; RDFSchema, and construct the namespace of the target RDFSchema.
  ;; The prefixes have no significance themselves, of course, but if
  ;; we're copying namespace nodes over from namespace-nodes.xml, and
  ;; referring to them in the generated script, then they have to
  ;; match (also matching like this avoids confusion).
  (variable name: targetprefix
            select: "name(/*/namespace::*[.=/xs:schema/@targetNamespace])")
  (variable name: targetnamespaceo
            select: "concat(/xs:schema/@targetNamespace,'#')")
  (variable name: targetprefixo
            select: "name(document('namespace-nodes.xml')/namespace-nodes/namespace::*[.=$targetnamespaceo])")

  ;; we need to refer explicitly to these namespaces in the tests below
  (variable name: vor-ns "http://www.ivoa.net/xml/VOResource/v1.0")
  (variable name: vods-ns "http://www.ivoa.net/xml/VODataService/v1.0")

  (template /
     (apply-templates select: xs:schema))

  (template xs:schema
    (xt:stylesheet version: 1.0
      (for-each select: //@type
                ;; Copy over the namespace nodes for all those prefixes
                ;; which appear in a type attribute (for the benefit of the
                ;; call-template elements generated for element|attribute
                ;; declarations below.
                (if "contains(.,':')"
                    (variable name: p
                              (value-of "substring-before(.,':')"))
                    (copy-of select: "/*/namespace::*[name()=$p]")))
      ;; Copy over the namespace declaration for the target RDFS namespace
      ;; (see the discussion about namespaces above).
      (copy-of select: "document('namespace-nodes.xml')/namespace-nodes/namespace::*[.=$targetnamespaceo]")

      (comment "Generated from XSchema by xschema2xslt.lx")

      (comment "targetprefix=" (value-of $targetprefix))
      (comment "targetnamespaceo=" (value-of $targetnamespaceo))
      (comment "targetprefixo=" (value-of $targetprefixo))

      (xt:output method: xml
                 version: 1.0
                 indent: yes)

      (apply-templates select: "xs:simpleType")
      (apply-templates select: "xs:complexType")

      ;; Create $targetprefix:resolve-xsitype, where $targetprefix is
      ;; the prefix assigned to the namespace given in the
      ;; @targetNamespace attribute.
      (xt:template
       name: "{$targetprefix}:resolve-xsitype"
       (xt:param name: type)
       (xt:choose
        (apply-templates select: "xs:complexType[xs:complexContent]"
                         mode: resolve-xsitype)))))

  ;; Hmm: should I be doing more with this imports statement? [import]
  (template xs:import
    (x2s:UNKNOWN name: xs:import
                 (attribute name: namespace
                            (value-of "@namespace"))))

  ;; [complextype]
  (template xs:complexType
    (choose
     (when descendant::xs:complexType
       (x2s:ERROR "complexType " (value-of @name)
                  " contains anonymous complexType"))
     (when descendant::xs:simpleType
       (x2s:ERROR "complexType " (value-of @name)
                  " contains anonymous simpleType"))
     (when xs:simpleContent
       (xt:template name: "{$targetprefix}:{@name}"
                    (for-each select: .//xs:attribute
                              (xt:if test: @{@name}
                                     (apply-templates select: .)))
                    (xt:element name: "{$targetprefixo}:{@name}Value"
                                (xt:apply-templates))))
     (when "xs:complexContent or xs:sequence"
      (xt:template name: "{$targetprefix}:{@name}"
                   (rdf:type rdf:resource: "{$targetnamespaceo}{@name}")
                   ;; There's no need to handle xs:annotation here.
                   ;; The handling of that in xschema2rdfs.lx just passes
                   ;; documentation into the RDFSchema.
                   (choose
                    (when xs:complexContent
                      ;; handle any attributes peculiar to this type
                      (for-each select: .//xs:attribute
                                (xt:if test: @{@name}
                                       (apply-templates select: .)))

                      (apply-templates select: "xs:complexContent/xs:extension|xs:complexContent/xs:restriction"
                                       mode: complex-content)
                      ;; Don't insert a (xt:apply-templates) here.
                      ;; Ignore the content for the moment, and call the
                      ;; template for the base class: that will either call
                      ;; _its_ base class template, or (have matched the
                      ;; next case and) call apply-templates.
                      )
                    (when xs:sequence   ;sequence content
                     (xt:apply-templates))
                    (otherwise
                     (x2s:ERROR "complexType " (value-of @name)
                                " has unexpected content"))))
      (apply-templates select: .//xs:element)
      )))

  (template xs:complexType mode: resolve-xsitype
    (xt:when test: "$type='{@name}'"
             (xt:call-template name: "{$targetprefix}:{@name}")))

  ;; simpleType: The content is a string, which may be an
  ;; enumeration.  There are no attributes for a simpleType.
  (template xs:simpleType
    (variable name: avt "{$type}") ;cunning trick to get AVT into the output
    (choose
     (when .//xs:enumeration            ;[simpleenum]
       ;; Create a named template to handle this (much like a complexType).
       ;; The template takes a parameter VAL which identifies the value
       ;; of the property, which is to be turned into one of a set of
       ;; types.  This VAL defaults to (apply-templates), but will need to
       ;; be passed explicitly when (in handle-type), this enumeration
       ;; is the range type of an attribute.
       (xt:template name: "{$targetprefix}:{@name}"
         (xt:param name: val (xt:apply-templates))
         (xt:variable name: type
                      (xt:choose
                       (apply-templates select: .//xs:enumeration)
                       (xt:otherwise x2s:UNKNOWN)))
         (xt:element name: {$avt})))
     (when "xs:restriction|xs:extension" ;[simplerestriction]
       (xt:template match: "{@name}"
                    (xt:apply-templates)))
     (otherwise
      (x2s:ERROR "simpleType " (value-of @name)
                 " contains no xs:restriction or xs:extension"))))

  (template "xs:extension|xs:restriction" ;[complexrestriction]
    mode: complex-content
    (xt:call-template
     (choose
      (when .//x2s:superclass           ;indicates which template to call
        (variable name: p
                  select: "substring-before(.//x2s:superclass, ':')")
        (copy-of select: "namespace::*[name()=$p]")
        (attribute name: name
                   (value-of .//x2s:superclass)))
      (otherwise                        ;nothing special -- just call @base
       (attribute name: name
                  (value-of @base))))))

  ;; no need (yes?) for simple-content variant of extension|restriction template

  (template xs:enumeration              ;[enumeration]
    (xt:when test: "$val='{@value}'"
             (value-of select: "$targetprefixo")
             (text ":")
             (value-of ancestor::xs:simpleType/@name)
             (value-of "translate(substring(@value,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')")
             (value-of "substring(@value,2)")))

  (template xs:attribute
    ;; [propertyname] I don't think we need to worry about x2s:propertyName,
    ;; since I don't think it's actually used any more
    (xt:element name: "{$targetprefixo}:{@name}"
                (call-template name: handle-type
                               (with-param type (value-of @type))
                               (with-param use-node
                                           "@" (value-of @name)))))

  (template xs:element
    (choose

     (when "@name and @type"            ;[elementtype]
       ;; We don't do anything about x2s:multipleDomains, here (apart from the
       ;; check below).  The element template that we emit will shadow,
       ;; or be shadowed by, another same-named template elsewhere, but this
       ;; is OK, because the generated schema will have declared these
       ;; properties to be equivalent.
       (variable name: pn select: "@name")
       (choose
        (when "preceding::xs:attribute[@name=$pn]"
          ;; We can't have multiple domains where one domain is an element
          ;; and the other is an attribute (not for deep modelling reasons,
          ;; but just because I haven't handled it here).
          (x2s:ERROR "Multiple domains: element "
                     (value-of @name)
                     " declared as element AND attribute"))
        (when "preceding::xs:element[@name=$pn]"
          ;; If the current element/attribute has already been seen, then
          ;; produce a warning, unless the x2s:multipleDomains annotation
          ;; is present.
          (choose
           (when .//x2s:multipleDomains
             (comment "Spotted multiple domains for element "
                      (value-of @name)))
           (otherwise
            (x2s:ERROR "Multiple (undeclared) domains for name "
                       (value-of @name)))))
        (when ".//x2s:propertyName"
          ;; [propertyname]
          ;; In this case, let the type handler template handle this completely.
          ;; That is, we do not emit any (RDF) property element.
          (variable name: propnameprefix
                    (value-of "substring-before(.//x2s:propertyName,':')"))
          (xt:template match: "{@name}"
                       (if "$propnameprefix != ''"
                           (copy-of select: ".//x2s:propertyName/namespace::*[name()=$propnameprefix]"))
                       (xt:call-template name: {@type})))
        (otherwise
         ;; there is no x2s:propertyName annotation

         (xt:template
          match: "{@name}"
          (xt:element
           name: "{concat($targetprefixo,':',@name)}" ;"{$propname}"
           (call-template name: handle-type
                          (with-param type (value-of @type))))))))

     (when @ref                         ;[elementref]
       ;; For the moment, skip elements declared with 'ref'.  They're
       ;; generally stc:STCResourceProfile as far as I can see, and thus
       ;; not something I plan on handling anyway.
       ;; FIXME -- do something cleverer, here.
       (comment "Skipping element ref=" (value-of @ref)
                " within " (value-of "ancestor::*/@name")))

     (otherwise
      (x2s:ERROR "Element within "
                 (value-of "ancestor::*/@name") " doesn't have @name+@type or @ref"))))

  ;; named templates
  (lx:dtd ((template (name #t)))
    (template handle-type
      ;; Create (RDF) xt:element content, where the property has the given range
      (param name: type)                ;the type of the range
      (param name: use-node .)
      (variable name: type-pfx select: "substring-before($type,':')")
      (variable name: type-ln select: "substring-after($type,':')")
      (variable name: type-ns select: "namespace::*[name()=$type-pfx]")
      (choose
       ;; Work through various special cases.
       (when "$type-ns=$vor-ns and $type-ln='IdentifierURI'"
         (xt:attribute name: rdf:parseType Resource)
         ;; add a breadcrumb, mostly for debugging
         (xt:comment "IdentifierURI, type=" (value-of $type)
                     ", from " (value-of $use-node))
         (xt:call-template name: make-identifier-uri-body
                           (xt:with-param name: id
                                          (xt:apply-templates
                                           select: "{$use-node}"))))
       (when "$type-ns=$vor-ns and $type-ln='ResourceName'"
         ;; add a breadcrumb, mostly for debugging
         (xt:comment "ResourceName, type=" (value-of $type)
                     ", name=" (value-of ancestor::xs:complexType/@name))
         (xt:call-template name: voro:resource-name
                           ;; Have the ResourceName be of type Resource.
                           ;; In some cases, the actual type will be more
                           ;; specific, but we don't know when in general.
                           (xt:with-param name: type
                                          voro:Resource)
                           (xt:with-param name: ns
                                          (value-of $targetnamespaceo))))
       (when "$type-ns='http://www.w3.org/2001/XMLSchema'"
         ;; simple content
         ;; (no rdf:parseType=Resource)
         (xt:value-of select: "normalize-space({$use-node})"))
       (when "$type-ns=/xs:schema/@targetNamespace and //xs:simpleType[@name=$type-ln] and not(//xs:simpleType[@name=$type-ln]//xs:enumeration)"
         ;; this type is a non-enumeration simpleType: value is just the content
         (xt:value-of select: "normalize-space({$use-node})"))
       (when "$type-ns=/xs:schema/@targetNamespace and //xs:simpleType[@name=$type-ln]//xs:enumeration"
         ;; This is an enumeration -- simply call the template.
         ;; We don't include rdf:parseType=Resource, since the template
         ;; starts off with the enumeration type.
         (xt:call-template name: "{$type}"
                           (xt:with-param name: val
                                          (xt:value-of select: "{$use-node}"))))
       (when "self::xs:attribute"
         ;; Ooops: this type isn't one of the special cases above,
         ;; and it's not a simpleType in this XSchema, but it's on an attribute.
         ;; It therefore appears to be a simpleType in some other XSchema,
         ;; which we can't handle right now.  I don't think we have to, however.
         ;; If we do, then we'll either have to start being able to grub
         ;; around in other XSchema files, or else we could just leave it
         ;; to the otherwise clause, and go ahead an generate a named
         ;; template for simpleTypes as well.
         (x2s:ERROR "Attribute " (value-of @name)
                    " appears to have a simple type in an external XSchema: not handled!!!"))
       (otherwise
        ;; This is complexContent, within either simpleType or complexType.
        ;; If this is simpleContent, then call the template which handles
        ;; this type.  If it's complexContent, then do the same, unless
        ;; there's an xsi:type attribute on the (instance) element, in which
        ;; case call the resolve-xsitype template, which handles this.

        ;; Find the localname of the $type, and use this to look up the
        ;; type declaration in this schema.
        (variable name: localname
                  (choose
                   (when "contains($type,':')"
                     (value-of "substring-after($type,':')"))
                   (otherwise
                    (value-of $type))))
        (choose
         (when "key('classes',$localname)/self::node() = xs:simpleType or key('classes',$localname)//xs:simpleContent"
           (comment "Type " (value-of $localname) " is simpleType")
           (xt:attribute name: rdf:parseType Resource)
           (xt:call-template name: "{$type}"))
         (otherwise
          (xt:attribute name: rdf:parseType Resource)
          (xt:choose
           (xt:when test: @xsi:type
                    (xt:call-template name: resolve-xsitype))
           (xt:otherwise
            (xt:call-template name: "{$type}")))))))))

))
