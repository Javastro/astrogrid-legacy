;; This script is a partner to the ../xschemas/xschema2rdfs.lx script,
;; which generates the RDFSchema which this script targets.  Points of
;; correspondence are marked [tag].  Refer to that script for more
;; documentation.
;;
;; Notes:
;;
;; x2s:propertyName : there's partial support here, and I won't add
;; more, since I'm not sure that this annotation is actually
;; valuable.  The support here is incomplete, and partially commented
;; out, since it doesn't handle the case where there are multiple
;; elements with the same XSchema name, requiring some fancy footwork
;; with apply-templates with modes.
;;
;; No: propertyName is used for validationLevel in SIA, which is annotated
;; in the XSchema with the x2s:propertyName being vor:validationLevel.
;; When propertyName is present, we should not generate any property-name
;; element, but leave that to the type handler.
;;
;; multipleDomains : ???
;;
;;
;;
;; THE PLAN
;;
;; See the same-named section at the top of xschema2rdfs

(lx:let ((namespace (xsl "http://www.w3.org/1999/XSL/Transform")
                    (#f "http://www.w3.org/1999/XSL/Transform")
                    (xt "http://www.w3.org/1999/XSL/TransformAlias")
                    (xs "http://www.w3.org/2001/XMLSchema")
                    (x2s "http://ns.eurovotech.org/registry-metadata#")
                    ;;(dc "http://purl.org/dc/elements/1.1/")

                    (vor "http://www.ivoa.net/xml/VOResource/v1.0")
                    (voro "http://www.ivoa.net/xml/VOResource/v1.0#")

                    (rdf  "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
                    ;(rdfs "http://www.w3.org/2000/01/rdf-schema#")
                    ;(owl  "http://www.w3.org/2002/07/owl#")
                    )
         (feature "http://ns.nxg.me.uk/lx/attributes-in-no-namespace")
         (dtd (template (match #t) mode)
              (element (name #t))
              (attribute (name #t))
              (value-of (select #t))
              (when (test #t))
              (if (test #t))
              (with-param (name #t) select)))

(stylesheet version: 1.0 ;exclude-result-prefixes: "x2s"
  (output method: xml
              version: 1.0
              indent: yes)

  (key name: classes
       match: "xs:simpleType|xs:complexType"
       use: @name)

  ;; We're generating an XSLT stylesheet, so we need to use the namespace-alias
  ;; trick to distinguish the XSL elements in this stylesheet from the
  ;; XSL elements in the result.
  (namespace-alias stylesheet-prefix: xt result-prefix: xsl)

  ;; There's quite a lot of namespace cleverness in this script.
  ;;
  ;; The output script, when run, generates elements in an
  ;; ontology/RDFS namespace, which isn't otherwise referred to in
  ;; this script or in the source XSchema.  Thus we have to copy it in
  ;; explicitly from the (generated) set of namespaces in the file
  ;; namespace-nodes.xml: it's the namespace node which has the
  ;; namespace formed from the source XSchema's @targetNamespace, with
  ;; a '#' appended. [targetns]
  ;;
  ;; We copy the namespace node in the xs:schema template below.
  ;; Here, we simply extract the prefixes of the XSchema and
  ;; RDFSchema, and construct the namespace of the target RDFSchema.
  ;; The prefixes have no significance themselves, of course, but if
  ;; we're copying namespace nodes over from namespace-nodes.xml, and
  ;; referring to them in the generated script, then they have to
  ;; match (also matching like this avoids confusion).
  (variable name: targetprefix
            select: "name(/*/namespace::*[.=/xs:schema/@targetNamespace])")
  (variable name: targetnamespaceo
            select: "concat(/xs:schema/@targetNamespace,'#')")
  (variable name: targetprefixo
            select: "name(document('namespace-nodes.xml')/namespace-nodes/namespace::*[.=$targetnamespaceo])")

  ;; we need to refer explicitly to these namespaces in the tests below
  (variable name: vor-ns "http://www.ivoa.net/xml/VOResource/v1.0")
  (variable name: vods-ns "http://www.ivoa.net/xml/VODataService/v1.0")

  (template /
     (apply-templates select: xs:schema))

  (template xs:schema
    (xt:stylesheet version: 1.0
      (for-each select: //@type
                ;; Copy over the namespace nodes for all those prefixes
                ;; which appear in a type attribute (for the benefit of the
                ;; call-template elements generated for element|attribute
                ;; declarations below.
                (if "contains(.,':')"
                    (variable name: p
                              (value-of "substring-before(.,':')"))
                    (copy-of select: "/*/namespace::*[name()=$p]")))
      ;; Copy over the namespace declaration for the target RDFS namespace
      ;; (see the discussion about namespaces above).
      (copy-of select: "document('namespace-nodes.xml')/namespace-nodes/namespace::*[.=$targetnamespaceo]")
      ;; (that is, the namespace given in the @targetNamespace attribute).
      ;; This will go wrong if there isn't a prefix assigned to that,
      ;; but I think that can't happen in practice (famous last words).
      ;(copy-of select: "/*/namespace::*[.=/xs:schema/@targetNamespace]")
;;       (copy-of select: "document('namespace-nodes.xml')/namespace-nodes/namespace::*[.=concat(/xs:schema/@targetNamespace,'#')]")

      (comment "Generated from XSchema by xschema2xslt.lx")

      (comment "targetprefix=" (value-of $targetprefix))
      (comment "targetnamespaceo=" (value-of $targetnamespaceo))
      (comment "targetprefixo=" (value-of $targetprefixo))

      (xt:output method: xml
                 version: 1.0
                 indent: yes)

      ;(xt:variable name: nso select: "{$targetnamespaceo}")

      (apply-templates select: "xs:simpleType")
      (apply-templates select: "xs:complexType")

      ;; Create $targetprefix:resolve-xsitype, where $targetprefix is
      ;; the prefix assigned to the namespace given in the
      ;; @targetNamespace attribute.
      (xt:template
       name: "{$targetprefix}:resolve-xsitype"
       (xt:param name: type)
       (xt:choose
        (apply-templates select: "xs:complexType[xs:complexContent]"
                         mode: resolve-xsitype)))))

  ;; Hmm: should I be doing more with this imports statement? [import]
  (template xs:import
    (x2s:UNKNOWN name: xs:import
                 (attribute name: namespace
                            (value-of "@namespace"))))

  ;; [complextype]
  (template xs:complexType
    (choose
     (when descendant::xs:complexType
       (x2s:ERROR "complexType " (value-of @name)
                  " contains anonymous complexType"))
     (when descendant::xs:simpleType
       (x2s:ERROR "complexType " (value-of @name)
                  " contains anonymous simpleType"))
     (when xs:simpleContent
       (xt:template name: "{$targetprefix}:{@name}"
                    (for-each select: .//xs:attribute
                              (xt:if test: @{@name}
                                     (apply-templates select: .)))
                    (xt:element name: "{$targetprefixo}:{@name}Value"
                                (xt:apply-templates))))
     (when "xs:complexContent or xs:sequence"
      (xt:template name: "{$targetprefix}:{@name}"
                   (rdf:type rdf:resource: "{$targetnamespaceo}{@name}")
                   ;; There's no need to handle xs:annotation here.
                   ;; The handling of that in xschema2rdfs.lx just passes
                   ;; documentation into the RDFSchema.
                   (choose
                    (when xs:complexContent
                      ;; handle any attributes peculiar to this type
                      (for-each select: .//xs:attribute
                                (xt:if test: @{@name}
                                       (apply-templates select: .)))

                      (apply-templates select: "xs:complexContent/xs:extension|xs:complexContent/xs:restriction"
                                       mode: complex-content)
                      ;; Don't insert a (xt:apply-templates) here.
                      ;; Ignore the content for the moment, and call the
                      ;; template for the base class: that will either call
                      ;; _its_ base class template, or (have matched the
                      ;; next case and) call apply-templates.
                      )
                    (when xs:sequence   ;sequence content
                     (xt:apply-templates)
;;                      (if .//x2s:propertyName
;;                          (xt:apply-templates
;;                           mode: "within-{@name}"))
                     )
                    (otherwise
                     (x2s:ERROR "complexType " (value-of @name)
                                " has unexpected content")))
;;                    (xt:call-template
;;                     (attribute name: name
;;                                (value-of "xs:complexContent/xs:extension/@base|xs:complexContent/xs:restriction/@base")))
                   )
      (apply-templates select: .//xs:element)
      )))

  (template xs:complexType mode: resolve-xsitype
    (xt:when test: "$type='{@name}'"
             (xt:call-template name: "{$targetprefix}:{@name}")))

  ;; simpleType: The content is a string, which may be an
  ;; enumeration.  There are no attributes for a simpleType.
  (template xs:simpleType
    (variable name: avt "{$type}") ;cunning trick to get AVT into the output
    (choose
     (when .//xs:enumeration            ;[simpleenum]
       ;; Create a named template to handle this (much like a complexType).
       ;; The template takes a parameter VAL which identifies the value
       ;; of the property, which is to be turned into one of a set of
       ;; types.  This VAL defaults to (apply-templates), but will need to
       ;; be passed explicitly when (in handle-type), this enumeration
       ;; is the range type of an attribute.
       (xt:template name: "{$targetprefix}:{@name}"
         (xt:param name: val (xt:apply-templates))
         (xt:variable name: type
                      (xt:choose
                       (apply-templates select: .//xs:enumeration)
                       (xt:otherwise x2s:UNKNOWN)))
         (xt:element name: {$avt})))
     (when "xs:restriction|xs:extension" ;[simplerestriction]
       (xt:template match: "{@name}"
                    (xt:apply-templates)))
     (otherwise
      (x2s:ERROR "simpleType " (value-of @name)
                 " contains no xs:restriction or xs:extension"))))

;;   (template xs:simpleContent                   ;[simplecontent]
;;     (apply-templates select: .//xs:attribute))
                                        ;only attributes inside this: easy

  (template "xs:extension|xs:restriction" ;[complexrestriction]
    mode: complex-content
    (xt:call-template
     (choose
      (when .//x2s:superclass           ;indicates which template to call
        (variable name: p
                  select: "substring-before(.//x2s:superclass, ':')")
        (copy-of select: "namespace::*[name()=$p]")
        (attribute name: name
                   (value-of .//x2s:superclass)))
      (otherwise                        ;nothing special -- just call @base
       (attribute name: name
                  (value-of @base))))))

  ;; no need? for simple-content variant of extension|restriction template

  (template xs:enumeration              ;[enumeration]
    (xt:when test: "$val='{@value}'"
             (value-of select: "$targetprefixo")
             (text ":")
             (value-of ancestor::xs:simpleType/@name)
             (value-of "translate(substring(@value,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')")
             (value-of "substring(@value,2)")))

  (template xs:attribute
    ;; [propertyname] I don't think we need to worry about x2s:propertyName,
    ;; since I don't think it's actually used any more
    (xt:element name: "{$targetprefixo}:{@name}"
                (call-template name: handle-type
                               (with-param type (value-of @type))
                               (with-param use-node
                                           "@" (value-of @name)))))

  (template xs:element
    (choose

     (when "@name and @type"            ;[elementtype]
       ;; We don't do anything about x2s:multipleDomains, here (apart from the
       ;; check below).  The element template that we emit will shadow,
       ;; or be shadowed by, another same-named template elsewhere, but this
       ;; is OK, because the generated schema will have declared these
       ;; properties to be equivalent.
       (variable name: pn select: "@name")
       (choose
        (when "preceding::xs:attribute[@name=$pn]"
          ;; We can't have multiple domains where one domain is an element
          ;; and the other is an attribute (not for deep modelling reasons,
          ;; but just because I haven't handled it here).
          (x2s:ERROR "Multiple domains: element "
                     (value-of @name)
                     " declared as element AND attribute"))
        (when "preceding::xs:element[@name=$pn]"
          ;; If the current element/attribute has already been seen, then
          ;; produce a warning, unless the x2s:multipleDomains annotation
          ;; is present.
          (choose
           (when .//x2s:multipleDomains
             (comment "Spotted multiple domains for element "
                      (value-of @name)))
           (otherwise
            (x2s:ERROR "Multiple (undeclared) domains for name "
                       (value-of @name)))))
        (when ".//x2s:propertyName"
          ;; [propertyname]
          ;; In this case, let the type handler template handle this completely.
          ;; That is, we do not emit any (RDF) property element.
          (variable name: propnameprefix
                    (value-of "substring-before(.//x2s:propertyName,':')")
;;                     (if ".//x2s:propertyName and contains(.//x2s:propertyName,':')"
;;                         (value-of "substring-before(.//x2s:propertyName,':')"))
                    )
;;           (variable name: propname
;;                     (choose
;;                      (when "$propnameprefix != ''"
;;                        (value-of .//x2s:propertyName))
;;                      (otherwise;when .//x2s:propertyName
;;                        (value-of "concat($targetprefixo,':',.//x2s:propertyName)"))
;; ;;                      (otherwise
;; ;;                       ;; normal case -- no x2s:propertyName annotation
;; ;;                       (value-of "concat($targetprefixo,':',@name)"))
;;                      ))
          (xt:template match: "{@name}"
                       (if "$propnameprefix != ''"
                           (copy-of select: ".//x2s:propertyName/namespace::*[name()=$propnameprefix]"))
                       (xt:call-template name: {@type})))
        (otherwise
         ;; [propertyname] This may be redundant -- I'm not sure that any
         ;; of the .xsd files actually use this annotation

         (xt:template
          match: "{@name}"
          ;;         (if .//x2s:propertyName
          ;;             ;; The presence of this annotation implies that there's
          ;;             ;; more than one element with this name in the XSchema.
          ;;             ;; Thus the template we're generating should have a mode.
          ;;             ;; See the complexType handler for the way this is called.
          ;;             (attribute name: mode
          ;;                        (text "within-")
          ;;                        (value-of ancestor::xs:complexType/@name)))
          (xt:element
           name: "{concat($targetprefixo,':',@name)}" ;"{$propname}"
;;            (if "$propnameprefix != ''"
;;                (copy-of select: ".//x2s:propertyName/namespace::*[name()=$propnameprefix]"))
           (call-template name: handle-type
                          (with-param type (value-of @type))))))))

     (when @ref                         ;[elementref]
       ;; For the moment, skip elements declared with 'ref'.  They're
       ;; generally stc:STCResourceProfile as far as I can see, and thus
       ;; not something I plan on handling anyway.
       ;; FIXME -- do something cleverer, here.
       (comment "Skipping element ref=" (value-of @ref)
                " within " (value-of "ancestor::*/@name")))

     (otherwise
      (x2s:ERROR "Element within "
                 (value-of "ancestor::*/@name") " doesn't have @name+@type or @ref"))))

  ;; named templates
  (lx:dtd ((template (name #t)))
    (template handle-type
      ;; Create (RDF) xt:element content, where the property has the given range
      (param name: type)                ;the type of the range
      (param name: use-node .)
      (variable name: type-pfx select: "substring-before($type,':')")
      (variable name: type-ln select: "substring-after($type,':')")
      (variable name: type-ns select: "namespace::*[name()=$type-pfx]")
      (choose
       ;; Work through various special cases. [propertyrange]
       (when "$type-ns=$vor-ns and $type-ln='IdentifierURI'"
         (xt:attribute name: rdf:parseType Resource)
;;          (comment "handle-type: " (value-of $targetprefixo)
;;                   ":::" (value-of @name))
;;          (xt:comment "handle-type(2): " (value-of $targetprefixo)
;;                   ":::" (value-of @name))
         ;; add a breadcrumb, mostly for debugging
         (xt:comment "IdentifierURI, type=" (value-of $type)
                     ", from " (value-of $use-node))
         (xt:call-template name: make-identifier-uri-body
                           (xt:with-param
                            name: id (xt:apply-templates select: "{$use-node}"))
;;                            (xt:with-param
;;                             name: propname
;;                             ;(value-of "$targetprefixo")
;;                             ;(text ":")
;;                             (value-of "@name"))
;;                            (xt:with-param
;;                             name: ns
;;                             (value-of select: $targetnamespaceo))
                           ))
       (when "$type-ns=$vor-ns and $type-ln='ResourceName'"
         ;; add a breadcrumb, mostly for debugging
         (xt:comment "ResourceName, type=" (value-of $type)
                     ", name=" (value-of ancestor::xs:complexType/@name))
         (xt:call-template name: voro:resource-name
                           ;; Have the ResourceName be of type Resource.
                           ;; In some cases, the actual type will be more
                           ;; specific, but we don't know when in general.
                           (xt:with-param name: type
                                          voro:Resource)
                           (xt:with-param name: ns
                                          (value-of $targetnamespaceo)))
;;          (xt:call-template name: voro:resource-name
;;                            (xt:with-param
;;                             name: type
;;                             (value-of "$targetprefixo")
;;                             (text ":")
;;                             (value-of ancestor::xs:complexType/@name)))
         )
       (when "$type-ns='http://www.w3.org/2001/XMLSchema'"
         ;; simple content
         ;; (no rdf:parseType=Resource)
         (xt:value-of select: "normalize-space({$use-node})"))
       (when "$type-ns=/xs:schema/@targetNamespace and //xs:simpleType[@name=$type-ln] and not(//xs:simpleType[@name=$type-ln]//xs:enumeration)"
         ;; this type is a non-enumeration simpleType: value is just the content
;;          (x2s:logging "attribute for name=" (value-of @name) "="
;;                       (value-of "local-name()"))
         (xt:value-of select: "normalize-space({$use-node})"))
       (when "$type-ns=/xs:schema/@targetNamespace and //xs:simpleType[@name=$type-ln]//xs:enumeration"
         ;; This is an enumeration -- simply call the template.
         ;; We don't include rdf:parseType=Resource, since the template
         ;; starts off with the enumeration type.
         (xt:call-template name: "{$type}"
                           (xt:with-param name: val
                                          (xt:value-of select: "{$use-node}"))))
       (when "self::xs:attribute"
         ;; Ooops: this type isn't one of the special cases above,
         ;; and it's not a simpleType in this XSchema, but it's on an attribute.
         ;; It therefore appears to be a simpleType in some other XSchema,
         ;; which we can't handle right now.  I don't think we have to, however.
         ;; If we do, then we'll either have to start being able to grub
         ;; around in other XSchema files, or else we could just leave it
         ;; to the otherwise clause, and go ahead an generate a named
         ;; template for simpleTypes as well.
         (x2s:ERROR "Attribute " (value-of @name)
                    " appears to have a simple type in an external XSchema: not handled!!!"))
       (otherwise
        ;; This is complexContent, within either simpleType or complexType.
        ;; If this is simpleContent, then call the template which handles
        ;; this type.  If it's complexContent, then do the same, unless
        ;; there's an xsi:type attribute on the (instance) element, in which
        ;; case call the resolve-xsitype template, which handles this.

        ;; Find the localname of the $type, and use this to look up the
        ;; type declaration in this schema.
        (variable name: localname
                  (choose
                   (when "contains($type,':')"
                     (value-of "substring-after($type,':')"))
                   (otherwise
                    (value-of $type))))
        (choose
         (when "key('classes',$localname)/self::node() = xs:simpleType or key('classes',$localname)//xs:simpleContent"
           (comment "Type " (value-of $localname) " is simpleType")
           (xt:attribute name: rdf:parseType Resource)
           (xt:call-template name: "{$type}"))
         (otherwise
          (xt:attribute name: rdf:parseType Resource)
          (xt:choose
           (xt:when test: @xsi:type
                    (xt:call-template name: resolve-xsitype))
           (xt:otherwise
            (xt:call-template name: "{$type}")))))))))

;; (template "xs:element|xs:attribute"
;;     (variable name: type-pfx select: "substring-before(@type,':')")
;;     (variable name: type-ln select: "substring-after(@type,':')")
;;     (variable name: type-ns select: "namespace::*[name()=$type-pfx]")
;;     ;(variable name: avt "{$targetprefixo}:{local-name()}")
;;     (choose

;;      (when "@name and @type"            ;[elementtype]
;;        ;; If the current element/attribute has already been seen, then
;;        ;; produce a warning, unless the x2s:multipleDomains annotation
;;        ;; is present.
;;        (variable name: pn select: "@name")
;;        (choose
;;         (when "preceding::xs:element[@name=$pn] or preceding::xs:attribute[@name=$pn]"
;;           (choose
;;            (when .//x2s:multipleDomains
;;              (comment "Spotted multiple domains for element "
;;                       (value-of @name)))
;;            (otherwise
;;             (x2s:ERROR "Multiple templates for name " (value-of @name)))))
;;         (otherwise
;;          (variable name: propnameprefix
;;                    (if ".//x2s:propertyName and contains(.//x2s:propertyName,':')"
;;                        (value-of "substring-before(.//x2s:propertyName,':')")))
;;          (variable name: propname
;;                    (choose
;;                     (when "$propnameprefix != ''"
;;                       (value-of .//x2s:propertyName))
;;                     (when .//x2s:propertyName
;;                       (value-of "concat($targetprefixo,':',.//x2s:propertyName)"))
;;                     (otherwise
;;                      (value-of "concat($targetprefixo,':',@name)"))))
;;          (xt:template
;;           match: "{@name}"
;;           ;;         (if .//x2s:propertyName
;;           ;;             ;; The presence of this annotation implies that there's
;;           ;;             ;; more than one element with this name in the XSchema.
;;           ;;             ;; Thus the template we're generating should have a mode.
;;           ;;             ;; See the complexType handler for the way this is called.
;;           ;;             (attribute name: mode
;;           ;;                        (text "within-")
;;           ;;                        (value-of ancestor::xs:complexType/@name)))
;;           (xt:element
;;            name: "{$propname}"
;;            (if "$propnameprefix != ''"
;;                (copy-of select: ".//x2s:propertyName/namespace::*[name()=$propnameprefix]"))
;;            (choose
;;             ;; Work through various special cases. [propertyrange]
;;             (when "$type-ns=$vor-ns and $type-ln='IdentifierURI'"
;;               (xt:call-template name: make-identifier-uri
;;                                 (xt:with-param
;;                                  name: id (xt:apply-templates))
;;                                 (xt:with-param
;;                                  name: propname
;;                                  (value-of "$targetprefixo")
;;                                  (text ":")
;;                                  (value-of "@name"))))
;;             (when "$type-ns=$vor-ns and $type-ln='ResourceName'"
;;               (xt:call-template name: voro:resource-name
;;                                 (xt:with-param
;;                                  name: type
;;                                  (value-of select: "$targetprefixo")
;;                                  (text ":")
;;                                  (value-of ancestor::xs:complexType/@name))))
;; ;;             (when .//x2s:objectRange
;; ;;               (x2s:ERROR "The property "
;; ;;                          (value-of $propname)
;; ;;                          " is of type "
;; ;;                          (value-of @type)
;; ;;                          ": this should be handled specially within xschema2xslt, but is not"))
;;             (when "$type-ns='http://www.w3.org/2001/XMLSchema'"
;;               ;; simple content
;;               (xt:value-of select: "normalize-space()"))
;;             (otherwise
;;              (xt:call-template name: "{@type}"))))))))

;;      (when @ref                         ;[elementref]
;;        ;; For the moment, skip elements declared with 'ref'.  They're
;;        ;; generally stc:STCResourceProfile as far as I can see, and thus
;;        ;; not something I plan on handling anyway.
;;        ;; FIXME -- do something cleverer, here.
;;        (comment "Skipping element ref=" (value-of @ref)
;;                 " within " (value-of "ancestor::*/@name")))

;;      (otherwise
;;       (x2s:ERROR "Element within "
;;                  (value-of "ancestor::*/@name") " doesn't have @name+@type or @ref"))))




;;   (template "xs:element|xs:attribute[@name and @type]"
;;     (variable name: p select: "substring-before(@type,':')")
;;     (variable name: l select: "substring-after(@type,':')")
;;     (variable name: n select: "namespace::*[name()=$p]")
;;     (variable name: avt "{$targetprefixo}:{local-name()}")
;;     (choose
;;      (when "$n=$vor-ns and $l='ResourceName'"
;;        )
;;      (otherwise ;when @name
;;        (xt:template match: "{@name}"
;;          (xt:element name: {$avt}
;;             (choose
;;              (when "$n='http://www.w3.org/2001/XMLSchema'"
;;                (xt:value-of select: "normalize-space()"))
;;              (otherwise
;;               (xt:call-template name: "{@type}"))))))
;; ;;      (when @ref
;; ;;        ;; For the moment, skip elements declared with 'ref'.  They're
;; ;;        ;; generally stc:STCResourceProfile as far as I can see, and thus
;; ;;        ;; not something I plan on handling anyway.
;; ;;        (comment "Skipping element ref=" (value-of @ref)
;; ;;                 " within " (value-of "ancestor::*/@name")))
;; ;;      (otherwise
;; ;;       (x2s:ERROR "Element within "
;; ;;                  (value-of "ancestor::*/@name") " doesn't have @name or @ref"))
;;      ))

;XXX Need to add by-hand support for VOResource, which includes a
;XXX vor:ResourceName handler which doesn't take a parameter,
;XXX but which instead grubs around in the complexType to find what Resource
;XXX subtype it is.

))
