#! /usr/bin/env scsh \
-o srfi-37 -e main -s
!#

(define (main args)
  (let ((inputs (args-fold (cdr args)
                           (option-list)
                           unrecognised-option
                           operand-processor
                           '())))

    ;; all sane?
    (if (< (length inputs) 1)
        (Usage #t))

    (let ((command (string->symbol (car inputs)))
          (rest-of-args (cdr inputs)))

      (cond ((assq command command-handlers)
             => (lambda (spec) ; spec=('command nargs handler-procedure)
                  (let ((nargs (cadr spec))
                        (handler (caddr spec)))
                    (if (or (not nargs)
                            (= (length rest-of-args) nargs))
                        (apply handler rest-of-args)
                        (error (format #f "command ~a requires ~a args, got ~s"
                                       command
                                       nargs
                                       rest-of-args))))))

            (else
             (error (format #f "Unrecognised command ~a: allowed are ~a"
                            command
                            (map car command-handlers))))))))


(define (get-handler kb-name . submodel-name)
  (define (verbose-option) (if (chatter)
                               '("--verbose" ;include chatter in request
                                 "--include") ;include HTTP headers in response
                               '()))
  (let ((full-url (cond ((null? submodel-name)
                         (format #f "~a/kb/~a" (base-url) kb-name))
                        ((= (length submodel-name) 1)
                         (format #f "~a/kb/~a/~a"
                                 (base-url) kb-name (car submodel-name)))
                        (else
                         (error "Bad call to get: too many arguments")))))
    (chatter "GET ~a" full-url)
    (exec-epf (curl ,@(verbose-option)
                    --header ,(format #f "Accept:~a"
                                      (or (preferred-language) "RDF/XML"))
                    ,full-url))))

(define (new-kb-handler kb-name metadata-file)
  (define (verbose-option) (if (chatter) '("--verbose") '()))
  (let ((full-url (format #f "~a/kb/~a" (base-url) kb-name)))
    (chatter "PUT file ~a to URL ~a" metadata-file full-url)
    (exec-epf (curl ,@(verbose-option)
                    --upload-file ,metadata-file
                    ,full-url))))

(define (add-submodel-handler model-name submodel-name submodel-file)
  (define (verbose-option) (if (chatter) '("--verbose") '()))
  (let ((full-url (format #f "~a/kb/~a/~a" (base-url) model-name submodel-name)))
    (chatter "PUT file ~a to URL ~a" submodel-file full-url)
    (exec-epf
     (curl ,@(verbose-option)
           --upload-file ,submodel-file
           --header ,(format #f "Content-Type: ~a"
                             (or (get-language-from-extension submodel-file)
                                 (preferred-language)
                                 ""))
           ,full-url))))

(define (delete-handler kb-name)
  (define (verbose-option) (if (chatter) '("--verbose") '()))
  (let ((full-url (format #f "~a/kb/~a" (base-url) kb-name)))
    (format #t "Delete is not handled by this client.~%You'll have to send the request 'DELETE ~a' to a HTTP server yourself~%" full-url)))

;; Upload code to the server.  The CODE-FILE names a file, or may be '-'
;; to indicate stdin
(define (code-handler code-file)
  (define (verbose-option) (if (chatter) '("--verbose") '()))
  (let ((full-url (format #f "~a/code" (base-url))))
    (chatter "PUT code in ~a to URL ~a" code-file full-url)
    (exec-epf
     (curl ,@(verbose-option)
           --upload-file ,code-file
           ,full-url))))

(define (Usage . args)
  (format #t "Usage: quaestor-client command [args]~%Allowed commands are:~%")
  (for-each (lambda (cmd-spec)
              (format #t "  ~a -- ~a~%"
                      (car cmd-spec)
                      (cadddr cmd-spec)))
            command-handlers)
  (if (and (not (null? args))
           (car args))
      (error "Bad call")))

;; List of command handlers.  
;; Each element is a ('command number-of-args handler doc-string)
;; NUMBER-OF-ARGS may be #f to have any number of args
(define command-handlers
  `((add-submodel
     3
     ,add-submodel-handler
     "add-submodel kb model-name rdf-file: Add a new submodel")
    (code
     1
     ,code-handler
     "code scm-code-file: Upload code to running server; file may be '-'")
    (delete
     1
     ,delete-handler
     "delete kb: delete the knowledgebase from the server")
    (help
     0
     ,Usage
     "Show help")
    (get
     #f
     ,get-handler
     "get kb / get kb submodel: Get model or specific submodel")
    (new-kb
     2
     ,new-kb-handler
     "new-kb name metadata-file: Create a new knowledgebase")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Utilities

;; Given a FILENAME, return a MIME type for an RDF language.
;; If none can be deduced, return #f.
(define (get-language-from-extension filename)
  (let ((ext (file-name-extension filename))
        (ext-map '((".n3"  . "text/rdf+n3")
                   (".rdf" . "application/rdf+xml")
                   (".owl" . "application/rdf+xml"))))
    (if (assoc ext ext-map)
        (cdr (assoc ext ext-map))
        #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Options and args

(define (create-option default)
  (let ((v default))
    (lambda o
      (if (null? o)
          v
          (set! v (car o))))))

;; Define the context URL for the Quaestor service
(define base-url (create-option "http://localhost:8080/quaestor"))

;; Preferred language for receiving responses.  Fallback language for uploading.
(define preferred-language (create-option #f))

;; CHATTER controls verbosity.  Can be
;;   (chatter) : report verbosity #t/#f
;;   (chatter #t/#f) : set verbosity
;;   (chatter "format" args ...) : print message if verbosity is #t
(define chatter
  (let ((chatter? #t))                  ;default verbosity
    (lambda args
      (cond ((null? args)
             chatter?)
            ((boolean? (car args))
             (set! chatter? (car args)))
            (chatter?
             (apply format `(#t ,(string-append (car args) "~%") ,@(cdr args))))
            (else
             #f)))))

(define (operand-processor operand op-list)
  (append op-list (list operand)))

(define option-list
  (let ((l '()))
    (lambda o
      (if (null? o)
          l
          (set! l (cons (car o) l))))))

(let-syntax ((declare-option
              (syntax-rules ()
                ((_ option-name option-func)
                 (option-list (option '(option-name) #t #t
                                      (lambda (option name arg seeds)
                                        (option-func arg)
                                        seeds))))
                ((_ option-name has-arg? body ...)
                 (option-list (option '(option-name) has-arg? has-arg?
                                      (lambda (option name arg seeds)
                                        body ...
                                        seeds)))))))
  (declare-option "verbose" #f (chatter #t))
  (declare-option "quiet"   #f (chatter #f))
  (declare-option "rdf"     #f (preferred-language
                                (get-language-from-extension "x.rdf")))
  (declare-option "n3"      #f (preferred-language
                                (get-language-from-extension "x.n3")))
  (declare-option "base-url" base-url))

(define (unrecognised-option)
  (Usage)
  (error "Bad command"))
