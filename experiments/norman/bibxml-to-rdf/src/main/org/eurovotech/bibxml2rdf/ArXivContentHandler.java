package org.eurovotech.bibxml2rdf;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.reasoner.Reasoner;

public class ArXivContentHandler
        extends BibContentHandler {

    private static final String arxivns = "http://arxiv.org/OAI/arXiv/".intern();
    private static final String OAIns = "http://www.openarchives.org/OAI/2.0/".intern();

    // Base URI for resources generated by this class
    private static final String recordBaseURI = "http://arxiv.org/resources/";
    private static final String MSCBaseURI = "http://www.ams.org/msc/2000/";
    private static final String ArXivCategoriesBaseURI = "http://arxiv.org/categories/";

    // ...and output namespaces
    private static final String ARXIVns = "http://arxiv.org/OAI/arXiv/#";
    private static final String DCTERMSns = "http://purl.org/dc/terms/";
    private static final String FOAFns = "http://xmlns.com/foaf/0.1/";

    private static final Pattern mscPattern = Pattern.compile("[0-9][0-9][A-Z-]([0-9][0-9]|[Xx][Xx])");

    // accumulates the string contents
    private StringBuffer content;

    // The Model representing the current record
    private Model recordModel;

    // the reasoner which understands the RDFSchema
    private Reasoner schemaReasoner;

    private enum Field {
        // See elements in http://arXiv.org/OAI/arXiv.xsd
        // ...though the records from the OAI-PMH feed don't match this
        RECORD("record"),
                ARXIV("arXiv"),
                ID("id"),
                TITLE("title", DCTERMSns, "title"),
                AUTHORS("authors"),
                AUTHOR("author", DCTERMSns, "creator"),
                SUBJCLASS("subj-class"),
                MSCCLASS("msc-class"),
                ACMCLASS("acm-class"),
                REPORTNO("report-no"),
                JOURNALREF("journal-ref", DCTERMSns, "bibliographicCitation"),
                COMMENTS("comments"),
                ABSTRACT("abstract", DCTERMSns, "abstract"),
                CATEGORIES("categories"),
                DOI("doi"),
                PROXY("proxy"),

                // components of author
                KEYNAME("keyname"),
                FORENAMES("forenames"),
                SUFFIX("suffix"),
                AFFILIATION("affiliation"),

                // OAI-PMH info
                OAIPMH("OAI-PMH"),
                RESPONSEDATE("responseDate"),
                REQUEST("request"),
                LISTRECORDS("ListRecords"),
                HEADER("header"),
                IDENTIFIER("identifier"),
                DATESTAMP("datestamp", DCTERMSns, "created"),
                SETSPEC("setSpec"),
                METADATA("metadata"),
                RESUMPTIONTOKEN("resumptionToken");
                
        private final String v;
        private final String outputNS;
        private final String outputProperty;

        Field(String v) {
            this.v = v.intern();
            this.outputNS = ARXIVns;
            this.outputProperty = v;
        }
        Field(String v, String outputNS, String outputProperty) {
            this.v = v.intern();
            this.outputNS = outputNS;
            this.outputProperty = outputProperty;
        }
        public static Field find(String s) {
            String si = s.intern();
            for (Field f : values())
                if (f.v == si)
                    return f;
            return null;
        }
        public String toString() {
            return outputProperty;
        }
        public Property asProperty(Model model) 
        {
            if (model == null)
                throw new IllegalArgumentException("Field.asProperty given null model");
            return model.createProperty(outputNS, outputProperty);
        }
    };

    // the per-record model we're building up
    private Model currentModel;
    // ...and the Resource within it which corresponds to this preprint
    private Resource currentResource;

    // the author details current being assembled
    private Author currentAuthor;

    // date stamp from <header>
    private String datestamp;

    // constructor
    ArXivContentHandler() {
        content = new StringBuffer();
        java.io.InputStream schemaStream = ClassLoader.getSystemResourceAsStream("org/eurovotech/bibxml2rdf/arxiv-schema.ttl");
        assert schemaStream != null;
        schemaReasoner = Util.createSchemaReasoner(schemaStream);
    }

    // Implementation of ContentHandler interface

    public void characters(char[] ch, int start, int length) {
        // Receive notification of character data.
        content.append(ch, start, length);
    }
    
    public void startDocument() {
        // Receive notification of the beginning of a document.
    }

    public void startElement(String uri, String localName, String qName, org.xml.sax.Attributes atts) {
        // Receive notification of the beginning of an element.
        if (! (uri == arxivns || uri == OAIns))
            // completely ignore elements not in the arXiv namespace
            return;

        Field thisField = Field.find(localName);
        if (thisField == null)
            throw new IllegalStateException("Ooops: unrecognised field " + localName);

        //System.err.println("Start element " + localName);

        switch (thisField) {
          case RECORD:
            currentModel = ModelFactory.createDefaultModel();
            assert currentModel != null;
            break;

          case AUTHOR:
            assert currentAuthor == null;
            currentAuthor = new Author();
            break;

          default:
            // do nothing
            break;
        }
        content.setLength(0);
    }

    public void endElement(java.lang.String uri, java.lang.String localName, java.lang.String qName) {
        // Receive notification of the end of an element.
        if (! (uri == arxivns || uri == OAIns))
            // completely ignore elements not in the arXiv namespace
            return;

        Field thisField = Field.find(localName);

        //System.err.println("End element " + localName);

        switch (thisField) {
          case RECORD:
            assert currentModel != null;
            bibRecordHandler.handleRecord(ModelFactory.createInfModel(schemaReasoner, currentModel));
            currentModel = null;
            currentResource = null;
            break;

          case DATESTAMP:
            if (datestamp != null)
                throw new IllegalStateException("<datestamp> appeared twice in record!?");
            datestamp = content.toString();
            break;

          case ID:
            assert currentModel != null;
            if (currentResource != null)
                throw new IllegalStateException("<id> appeared twice in record?!");
            currentResource = currentModel.createResource(recordBaseURI + content.toString());
            addToProperties(Field.ID, content.toString());
            addToProperties(Field.DATESTAMP, datestamp);
            datestamp = null;
            break;

          case KEYNAME:
            assert currentAuthor != null;
            currentAuthor.setKeyname(content.toString());
            break;
          case FORENAMES:
            assert currentAuthor != null;
            currentAuthor.setForenames(content.toString());
            break;
          case AFFILIATION:
            assert currentAuthor != null;
            currentAuthor.setAffiliation(content.toString());
            break;
          case AUTHOR:
            addToProperties(Field.AUTHOR, currentAuthor);
            currentAuthor = null;
            break;

          case CATEGORIES:
            addToProperties(thisField, currentModel.createResource(ArXivCategoriesBaseURI + content.toString()));
            break;
          case MSCCLASS:
            String mscClass = content.toString();
            Matcher m = mscPattern.matcher(mscClass);
            //System.err.println("MSC class string=" + mscClass);
            while (m.find()) {
                String msc = mscClass.substring(m.start(), m.start()+5);
                //System.err.print("Found code " + msc);
                if (msc.charAt(3) == 'x' || msc.charAt(3) == 'X') {
                    if (msc.charAt(2) == '-')
                        msc = msc.substring(0,2);
                    else
                        msc = msc.substring(0,3);
                }
                //System.err.println(" -> " + msc);
                addToProperties(thisField, currentModel.createResource(MSCBaseURI + msc));
            }
            break;

          case TITLE:
          case ABSTRACT:
          case SUBJCLASS:       // the following could be better handled
          case ACMCLASS:
          case REPORTNO:
          case JOURNALREF:
          case DOI:
            addToProperties(thisField, content.toString());
            break;

          default:
            // do nothing
            break;
        }
    }
    
    /**
     * Add a new property to the current resource.
     */
    private void addToProperties(Field thisField, String newValue) {
        assert currentResource != null && currentModel != null;
        currentResource.addProperty(thisField.asProperty(currentModel), newValue);
    }

    /**
     * Add a new property to the current resource.
     */
    private void addToProperties(Field thisField, Util.SubResource resourceValue) {
        assert currentResource != null && currentModel != null;
        currentResource.addProperty(thisField.asProperty(currentModel), resourceValue.asResource());
    }

    private void addToProperties(Field thisField, Resource resource) {
        assert currentResource != null && currentModel != null;
        currentResource.addProperty(thisField.asProperty(currentModel), resource);
    }

    private static final Pattern nonLetter = Pattern.compile("[^\\p{javaLowerCase}\\p{javaUpperCase}]+");
    private class Author
            implements Util.SubResource {
        private String keyname;
        private String forenames;
        private String affiliation;

        Author() {
            // nothing to do
        }
        public void setKeyname(String s) {
            keyname = s;
        }
        public void setForenames(String s) {
            forenames = s;
        }
        public void setAffiliation(String s) {
            affiliation = s;
        }

        public Resource asResource() {
            Resource thisResource;
            String resourceName = keyname + (forenames == null ? "" : forenames);
            Matcher m = nonLetter.matcher(resourceName);
            assert currentModel != null;
            thisResource = currentModel.createResource(recordBaseURI + "people/" + m.replaceAll(""));

            thisResource.addProperty(currentModel.createProperty(FOAFns, "surname"),  keyname);
            if (forenames == null) {
                thisResource.addProperty(currentModel.createProperty(FOAFns, "name"),
                                         keyname);
            } else {
                thisResource.addProperty(currentModel.createProperty(FOAFns, "firstName"), forenames);
                thisResource.addProperty(currentModel.createProperty(FOAFns, "name"),
                                         keyname +  ", " + forenames);
            }
            if (affiliation != null)
                thisResource.addProperty(currentModel.createProperty(FOAFns, "isMemberOf"), // correct/best?
                                         affiliation);
            return thisResource;
        }
    }
}
