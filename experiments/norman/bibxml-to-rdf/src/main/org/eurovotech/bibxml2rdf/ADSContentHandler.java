package org.eurovotech.bibxml2rdf;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.reasoner.Reasoner;


/**
 * A class which handles the SAX events from ADS abstract files.
 * These conform to the XSchema http://ads.harvard.edu/schema/abs/1.0/abstracts.xsd
 * (though conformance is neither checked nor depended on).
 *
 * <p>We rely on the calling parser having the
 * "http://xml.org/sax/features/string-interning" feature set to true.
 */
public class ADSContentHandler
        extends BibContentHandler {

    // The namespace of the ADS XML
    private static final String adsns = "http://ads.harvard.edu/schema/abs/1.0/abstracts".intern();

    // Base URI for resources generated by this class
    private static final String recordBaseURI = "http://ads.harvard.edu/resource/";

    // ... and output namespaces
    private static final String ADSns = "http://ads.harvard.edu/schema/abs/1.0/abstracts#";
    private static final String DCTERMSns = "http://purl.org/dc/terms/";
    private static final String FOAFns = "http://xmlns.com/foaf/0.1/";

    // accumulates the string contents
    private StringBuffer content;

    // a Link being built up
    private Link currentLink;

    // Records the type of <keywords type='???'> we're in
    private String keywordsType;

    // The Model representing the current record
    private Model recordModel;

    // the reasoner which understands the RDFSchema
    private Reasoner schemaReasoner;

    private enum Field {
        // the list of elements in "http://ads.harvard.edu/schema/abs/1.0/abstracts.xsd"
        // v1.0.1
        RECORDS("records"),
                RECORD("record"),
                BIBCODE("bibcode"), // note both bibcode and doi are serialised as dc:identifier
                DOI("DOI"),
                EPRINTID("eprintid"),
                TITLE("title", DCTERMSns, "title"),
                AUTHOR("author", DCTERMSns, "creator"),
                AFFILIATION("affiliation"),
                JOURNAL("journal", DCTERMSns, "bibliographicCitation"),
                VOLUME("volume"),
                PUBDATE("pubdate", DCTERMSns, "created"),
                PAGE("page"),
                LASTPAGE("lastpage"),
                OBJECTS("objects"),
                OBJECT("object"),
                KEYWORDS("keywords"),
                KEYWORD("keyword", DCTERMSns, "subject"),
                LANGUAGE("language"),
                ORIGIN("origin"),
                COPYRIGHT("copyright"),
                LINK("link"),
                NAME("name"),
                URL("url"),
                COMMENT("comment"),
                SCORE("score"),
                CITATIONS("citations"),
                ABSTRACT("abstract", DCTERMSns, "abstract");
        
        private final String v;
        private final String outputNS;
        private final String outputProperty;

        Field(String v) {
            this.v = v.intern();
            this.outputNS = ADSns;
            this.outputProperty = v;
        }
        Field(String v, String outputNS, String outputProperty) {
            this.v = v.intern();
            this.outputNS = outputNS;
            this.outputProperty = outputProperty;
        }
        public static Field find(String s) {
            String si = s.intern();
            for (Field f : values())
                if (f.v == si)
                    return f;
            return null;
        }
        public String toString() {
            return outputProperty;
        }
        public Property asProperty(Model model) 
        {
            if (model == null)
                throw new IllegalArgumentException("Field.asProperty given null model");
            return model.createProperty(outputNS, outputProperty);
        }
    };

    // The per-record model we're building up
    private Model currentModel;
    // ... and the Resource within it which corresponds to the Bibcode
    private Resource currentResource;

    // the per-record author list which we build up
    private List<Author> authorList;

    // constructor
    ADSContentHandler() {
        content = new StringBuffer();
        java.io.InputStream schemaStream = ClassLoader.getSystemResourceAsStream("org/eurovotech/bibxml2rdf/ads-schema.ttl");
        assert schemaStream != null;
        schemaReasoner = Util.createSchemaReasoner(schemaStream);
    }

    // Implementation of ContentHandler interface

    public void characters(char[] ch, int start, int length) {
        // Receive notification of character data.
        content.append(ch, start, length);
    }
    
    public void startDocument() {
        // Receive notification of the beginning of a document.
        authorList = new java.util.ArrayList<Author>();
    }

    public void startElement(String uri, String localName, String qName, org.xml.sax.Attributes atts) {
        // Receive notification of the beginning of an element.
        if (uri != adsns)
            // completely ignore elements not in the ADS namespace
            return;

        Field thisField = Field.find(localName);

        switch (thisField) {
          case RECORD:
            currentModel = ModelFactory.createDefaultModel();
            // set the namespace prefix, for prettiness
            // don't bother -- setting it here has no effect on the output
            //currentModel.setNsPrefix("ads", ADSns);
            assert currentModel != null;
            authorList.clear();
            break;

          case LINK:
            String type = atts.getValue("type");
            currentLink = new Link(type == null ? "NULL" : type.toLowerCase());
            break;
            
          case KEYWORDS:
            keywordsType = atts.getValue("type");
            break;

          default:
            // do nothing
            break;
            
        }
        content.setLength(0);
    }

    public void endElement(java.lang.String uri, java.lang.String localName, java.lang.String qName) {
        // Receive notification of the end of an element.
        if (uri != adsns)
            // completely ignore elements not in the ADS namespace
            return;

        Field thisField = Field.find(localName);

        switch (thisField) {
          case RECORD:
            assert currentModel != null;
            for (Author a : authorList) {
                addToProperties(Field.AUTHOR, a);
            }
            bibRecordHandler.handleRecord(ModelFactory.createInfModel(schemaReasoner, currentModel));
            bibRecordHandler.setNsPrefix("ads", ADSns);
            currentModel = null;
            currentResource = null;
            break;

          case BIBCODE:
            if (currentResource != null)
                throw new IllegalStateException("<bibcode> element was not first in record");
            currentResource = currentModel.createResource(recordBaseURI + content.toString());
            addToProperties(Field.BIBCODE, content.toString());
            break;

          case URL:
            if (currentLink == null) {
                // URL element in <record>, not in <link>
                addToProperties(Field.URL, content.toString());
            } else {
                currentLink.setURI(content.toString());
            }
            break;

          case NAME:
            assert currentLink != null;
            currentLink.setTitle(content.toString());
            break;
            
          case KEYWORDS:
            // nothing to do -- all the work is done in the children
            break;

          case AUTHOR:
            authorList.add(new Author(content.toString()));
            break;

          case AFFILIATION:
            manageAffiliations(authorList, content.toString());
            break;

          case LINK:
            addToProperties(thisField, currentLink);
            break;

          case RECORDS:
            // nothing to do
            break;

          default:
            addToProperties(thisField, content.toString());
            break;
        }
    }


//     // A Turtle string is as follows.  See http://www.w3.org/TeamSubmission/turtle/#string
//     //
//     // [36]	string	::=	#x22 scharacter* #x22
//     // [37]	longString	::=	#x22 #x22 #x22 lcharacter* #x22 #x22 #x22
//     // [38]	character	::=	 '\ u' hex hex hex hex |
//     //                                   '\ U' hex hex hex hex hex hex hex hex |
//     //                                   '\\' |
//     //                                   [#x20-#x5B] | [#x5D-#x10FFFF]
//     // [39]	echaracter	::=	character | '\t' | '\n' | '\r'
//     // [40]	hex	::=	[#x30-#x39] | [#x41-#x46]
//     // [41]	ucharacter	::=	 ( character - #x3E ) | '\>'
//     // [42]	scharacter	::=	 ( echaracter - #x22 ) | '\"'
//     private static final Pattern escapes = Pattern.compile("[\\x00-\\x1F\"\\\\]");

//     /**
//      * Prepare a string for Turtle output, by escaping any characters which may not appear in a 
//      * single-quoted Turtle string.  See the pattern above.
//      */
//     private static String prepareString(String s) {
//         StringBuffer sb = null;
//         Matcher m = escapes.matcher(s);
//         int prev = 0;

//         while (m.find()) {
//             if (sb == null)
//                 sb = new StringBuffer();
//             sb.append(s.substring(prev, m.start()));
//             int codepoint = Character.codePointAt(s, m.start());
//             switch (codepoint) {
//               case 0x22: // '"'
//                 sb.append("\\\"");
//                 break;
//               case 0x5c: // '\'
//                 sb.append("\\\\");
//                 break;
//               case 0x0a: // newline
//                 sb.append("\\n");
//                 break;
//               default:
//                 assert codepoint < 0x20;
//                 sb.append("\\u");
//                 java.text.DecimalFormat df = new java.text.DecimalFormat("0000");
//                 sb.append(df.format(codepoint));
//             }
//             prev = m.start()+1;
//         }

//         if (sb == null) {
//             return s;
//         } else {
//             sb.append(s.substring(prev));
//             return sb.toString();
//         }
//     }

    static final Pattern institutePattern = Pattern.compile("([A-Z][A-Z])\\(([^\\)]+)\\)(?:,\\s*)?");
    static final Pattern emailPattern = Pattern.compile("[A-Za-z0-9.-]+@[A-Za-z0-9.-]+");
    static void manageAffiliations(List<Author> authors, String affiliationString) {
        Matcher m = institutePattern.matcher(affiliationString);
        int index = 0;

        while (m.find()) {
            String charidx = m.group(1);
            String inst = m.group(2);
            int intidx;

            intidx = (charidx.charAt(0) - 'A')*26 + (charidx.charAt(1) - 'A');

            Author a = authors.get(intidx);
            Matcher emailMatcher = emailPattern.matcher(inst);
            if (emailMatcher.find()) {
                a.setAffiliation(inst.substring(0, emailMatcher.start()));
                a.setEmail(inst.substring(emailMatcher.start(), emailMatcher.end()));
            } else {
                a.setAffiliation(inst);
            }
        }
    }

    /**
     * Add a new property to the current resource.
     */
    private void addToProperties(Field thisField, String newValue) {
        assert currentResource != null && currentModel != null;
        currentResource.addProperty(thisField.asProperty(currentModel), newValue);
    }

    /**
     * Add a new property to the current resource.
     */
    private void addToProperties(Field thisField, Util.SubResource resourceValue) {
        assert currentResource != null && currentModel != null;
        currentResource.addProperty(thisField.asProperty(currentModel), resourceValue.asResource());
//         Resource r = resourceValue.asResource();
//         currentResource.addProperty(thisField.asProperty(currentModel), r);
//         System.err.println("*** addToProperties ...");
//         com.hp.hpl.jena.rdf.model.StmtIterator si = r.listProperties();
//         while (si.hasNext()) {
//             com.hp.hpl.jena.rdf.model.Statement s = (com.hp.hpl.jena.rdf.model.Statement)si.nextStatement();
//             System.err.println("Property object: " + s.getPredicate() + " -> " + s.getObject());
//         }
    }

    private class Link
            implements Util.SubResource {
        private String type;
        private String title;
        private java.net.URI uri;
        Link(String type) {
            this.type = type;
        }
        public void setTitle(String title) {
            this.title = title;
        }
        public void setURI(String uri) {
            try {
                this.uri = new java.net.URI(uri);
            } catch (java.net.URISyntaxException e) {
                this.uri = null; // silently ignore it
            }
        }
//         public String toString() {
//             StringBuffer sb = new StringBuffer();
//             sb.append(" [ ");
//             if (type != null)
//                 sb.append(":type \"").append(type).append("\"; ");
//             if (title != null)
//                 sb.append(":title \"").append(prepareString(title)).append("\"; ");
//             if (uri != null)
//                 sb.append(":uri <").append(uri.toString()).append(">; ");
//             sb.append(" ] ");
//             return sb.toString();
//         }
        public Resource asResource() {
            Resource thisResource = currentModel.createResource(); // new anonymous resource
            thisResource.addProperty(currentModel.createProperty(ADSns, "type"),  type)
                    .addProperty(currentModel.createProperty(DCTERMSns, "title"), title)
                    .addProperty(currentModel.createProperty(ADSns, "uri"),
                                 currentModel.createResource(uri.toString()));
            return thisResource;
        }
    }

    private static final Pattern authorName = Pattern.compile("^([^,]*)(?:, *(.*))?");
    private static final Pattern nonLetter = Pattern.compile("[^\\p{javaLowerCase}\\p{javaUpperCase}]+");
    private class Author
            implements Util.SubResource {
        private String givenName;
        private String familyName;
        private String affiliation;
        private String email;
        /**
         * Construct an author, given their name as a "surname, givenname(s)" string.
         */
        Author(String fullName) {
            Matcher m = authorName.matcher(fullName);
            if (m.matches()) {
                familyName = m.group(1);
                if (m.groupCount() > 1) {
                    givenName = m.group(2);
                } else {
                    givenName = null;
                    System.err.println("Name <" + fullName + "> has no given name");
                }
            } else {
                // this pattern should match everything
                throw new AssertionError("Pattern failed to match string <" + fullName + ">");
            }
        }
        /**
         * Set an author's affiliation
         */
        public void setAffiliation(String aff) {
            affiliation = aff;
        }
        /**
         * Set an author's email address
         */
        public void setEmail(String email) {
            this.email = email;
        }
//         public String toString() {
//             StringBuffer sb = new StringBuffer();
//             sb.append(" [ ");
//             sb.append("foaf:surname \"").append(familyName).append("\"; ");
//             sb.append("foaf:firstName \"").append(givenName).append("\"; ");
//             sb.append("foaf:name \"").append(givenName).append(' ').append(familyName).append("\"; ");
//             if (affiliation != null)
//                 sb.append("foaf:isMemberOf \"") // correct/best?
//                         .append(affiliation)
//                         .append("\"; ");
//             if (email != null)
//                 sb.append("foaf:mbox <mailto:").append(email).append(">; ");
//             sb.append(" ] ");
//             return sb.toString();
//         }
        public Resource asResource() {
            Resource thisResource;
            String resourceName = familyName + (givenName == null ? "" : givenName);
            Matcher m = nonLetter.matcher(resourceName);
            thisResource = currentModel.createResource(recordBaseURI + m.replaceAll(""));

            thisResource.addProperty(currentModel.createProperty(FOAFns, "surname"),  familyName);
            if (givenName == null) {
                thisResource.addProperty(currentModel.createProperty(FOAFns, "name"),
                                         familyName);
            } else {
                thisResource.addProperty(currentModel.createProperty(FOAFns, "firstName"), givenName);
                thisResource.addProperty(currentModel.createProperty(FOAFns, "name"),
                                         givenName + ' ' + familyName);
            }
            if (affiliation != null)
                thisResource.addProperty(currentModel.createProperty(FOAFns, "isMemberOf"), // correct/best?
                                         affiliation);
            if (email != null)
                thisResource.addProperty(currentModel.createProperty(FOAFns, "mbox"),
                                         currentModel.createResource("mailto:" + email));
            return thisResource;
        }
    }
}
