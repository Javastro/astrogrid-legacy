;; Test harness.
;; The first argument to MAIN should be the full path to this script.

(import s2j)

(define nfails 0)
(define-syntax expect
  (syntax-rules ()
    ((_ id expected body ...)
     (with/fc (lambda (m e)
                (format #t "Test ~a~%    produced error~a: ~a~%    expected ~s~%"
                          (quote id)
                          (if (error-location m)
                              (format #f " in ~a" (error-location m))
                              "")
                          (or (error-message m)
                              (error-message (error-parent-error m))
                              (error-message
                               (error-parent-error
                                (error-parent-error m)))
                              m)
                          expected)
                (set! nfails (+ nfails 1)))
       (lambda ()
         (let ((test ((lambda ()
                        body ...))))
           (if (not (equal? expected test))
               (begin (format #t "Test ~a~%    produced ~s~%    expected ~s~%"
                              (quote id) test expected)
                      (set! nfails (+ nfails 1))))))))))
(define-syntax expect-failure
  (syntax-rules ()
    ((_ id body ...)
     (with/fc (lambda (m e)
                ;;failed -- OK
                #t)
        (lambda ()
          (let ((test ((lambda () body ...))))
            (format #t "Test ~a~%    produced ~s~%    expected ERROR~%"
                    (quote id) test)
            (set! nfails (+ nfails 1))))))))

;; files to test, as an explicit list
;; YUK: this should be dynamically generated by searching the tree below
;; a directory given on the command line
(define files-to-test '("utype-resolver/knowledge.scm"))

;; the following nearly works, but not quite, and I'm in a hurry
;; (define (is-java-type? jobject class)
;;   (define-generic-java-method is-instance)
;;   (if (java-object? jobject)
;;       (->boolean
;;        (is-instance (cond ((java-class? class)
;;                            class)
;;                           ((string? class)
;;                            (java-class (string->symbol class)))
;;                           ((symbol? class)
;;                            (java-class class))
;;                           (else
;;                            (error "Bad class in is-java-type?: ~s" class)))
;;                     jobject))
;;       #f))
;; (define (debug . x)
;;   (format #t "DEBUG:~s:~%" x)
;;   x)
;; (define (list-files-in-tree fn)
;;   (define-java-classes
;;     (<file> |java.io.File|)
;;     (<jstring> |java.lang.String|))
;;   (define-generic-java-methods
;;     directory? file? to-string list-files exists)
;;   (let ((f (cond ((is-java-type? fn <file>)
;;                   fn)
;;                  ((is-java-type? fn <jstring>)
;;                   (java-new <file> fn))
;;                  ((string? fn)
;;                   (java-new <file> (->jstring fn)))
;;                  (else
;;                   (error (format #f "Bad argument to LIST-FILES-IN-TREE: ~s"
;;                                  fn))))))
;;     (cond ((not (->boolean (exists f)))
;;            (error (format #f "File ~s does not exist" f)))
;;           ((->boolean (file? f))
;;            (debug (list (->string (to-string f)))))
;;           ((->boolean (directory? f))
;;            (apply append (map list-files-in-tree
;;                               (->list (list-files f)))))
;;           (else
;;            (error (format #f "Improper file type in LIST-FILES-IN-TREE: ~s (~s ~s)" f (file? f) (directory? f)))))))

(define (main . args)
  (define-generic-java-method
    exit)
  (define-java-class <java.lang.system>)
  (with-current-url (car args)
     (lambda ()
       (for-each run-test-file
                 files-to-test)))
  (if (> nfails 0)
      (format #t "Number of fails=~a~%" nfails))
  (exit (java-null <java.lang.system>) (->jint nfails)))

(define (run-test-file file-name)
  (let ((url (normalize-url (current-url) file-name)))
    (or url
        (error (format #f "Can't find resource ~a" file-name)))
    (chatter "Running tests in ~a..." file-name)
    (load url)))

(define chatter
  (let ((chatter? #t))
    (lambda (fmt . args)
      (cond ((boolean? fmt)
             (set! chatter? fmt))
            (chatter?
             (apply format `(#t ,(string-append fmt "~%") ,@args)))
            (else
             #f)))))


