;; Test harness.
;; The first argument to MAIN should be the full path to this script.

(import s2j)

;; We don't actually import this library here, but the tested modules
;; do import quaestor-support
(require-library 'org/eurovotech/quaestor/scheme-wrapper-support)

(define failures-in-block?
  (let ((failures? #f))
    (lambda arg
      (cond ((null? arg)
             (let ((t failures?))
               (set! failures? #f)
               t))
            ((boolean? (car arg))
             (set! failures? (car arg)))
            (else
             (error "Bad call to FAILURES-IN-BLOCK?"))))))
(define failures
  (let ((n 0))
    (lambda arg
      (cond ((null? arg)
             n)
            ((number? (car arg))
             (set! n (+ n (car arg)))
             (failures-in-block? #t))
            (else
             (error "Bad call to FAILURES"))))))

(define show-test
  (let ((show-em #f))
    (lambda (arg)
      (cond ((boolean? arg)
             (set! show-em arg))
            (show-em
             (display (format "Test: ~s~%" arg)))))))


(define-syntax expect
  (syntax-rules ()
    ((_ expected expr)
     (expect expr expected expr))
    ((_ id expected expr)
     (with/fc (lambda (m e)
                (format #t "Test ~a~%    produced error~a: ~a~%    expected ~s~%"
                          (quasiquote id)
                          (if (error-location m)
                              (format #f " in ~a" (error-location m))
                              "")
                          (or (error-message m)
                              (error-message (error-parent-error m))
                              (error-message
                               (error-parent-error
                                (error-parent-error m)))
                              m)
                          expected)
                (failures 1))
       (lambda ()
         (show-test (quasiquote id))
         (let ((test ((lambda () expr))))
           (if (not (equal? expected test))
               (begin (format #t "Test ~a~%    produced ~s~%    expected ~s~%"
                              (quasiquote id) test expected)
                      (failures 1)))))))))
(define-syntax expect-failure
  (syntax-rules ()
    ((_ expr)
     (expect-failure expr expr))
    ((_ id expr)
     (with/fc (lambda (m e)
                ;;failed -- OK
                #t)
        (lambda ()
          (show-test (quasiquote id))
          (let ((test ((lambda () expr))))
            (format #t "Test ~a~%    produced ~s~%    expected ERROR~%"
                    (quasiquote id) test)
            (failures 1)))))))

(define (get-system-property key)
  (define-generic-java-method get-property)
  (define-java-class <java.lang.system>)
  (let ((p (get-property (java-null <java.lang.system>)
                         (->jstring key))))
    (if (java-null? p)
        #f
        (->string p))))

(format #t "java.home=~a  single.test=~s~%"
        (get-system-property "java.home")
        (get-system-property "single.test"))

;; Files to test, as an explicit list, which can be overridden with the 
;; "single.test" property
;; YUK: this should be dynamically generated by searching the tree below
;; a directory given on the command line
(define files-to-test
  (let ((test (get-system-property "single.test")))
    (if (and test (> (string-length test) 0))
        (list (string-append "utype-resolver/" test))
        '("utype-resolver/knowledge.scm"
          "utype-resolver/web-interface.scm"))))

;; the following nearly works, but not quite, and I'm in a hurry
;; (define (is-java-type? jobject class)
;;   (define-generic-java-method is-instance)
;;   (if (java-object? jobject)
;;       (->boolean
;;        (is-instance (cond ((java-class? class)
;;                            class)
;;                           ((string? class)
;;                            (java-class (string->symbol class)))
;;                           ((symbol? class)
;;                            (java-class class))
;;                           (else
;;                            (error "Bad class in is-java-type?: ~s" class)))
;;                     jobject))
;;       #f))
;; (define (debug . x)
;;   (format #t "DEBUG:~s:~%" x)
;;   x)
;; (define (list-files-in-tree fn)
;;   (define-java-classes
;;     (<file> |java.io.File|)
;;     (<jstring> |java.lang.String|))
;;   (define-generic-java-methods
;;     directory? file? to-string list-files exists)
;;   (let ((f (cond ((is-java-type? fn <file>)
;;                   fn)
;;                  ((is-java-type? fn <jstring>)
;;                   (java-new <file> fn))
;;                  ((string? fn)
;;                   (java-new <file> (->jstring fn)))
;;                  (else
;;                   (error (format #f "Bad argument to LIST-FILES-IN-TREE: ~s"
;;                                  fn))))))
;;     (cond ((not (->boolean (exists f)))
;;            (error (format #f "File ~s does not exist" f)))
;;           ((->boolean (file? f))
;;            (debug (list (->string (to-string f)))))
;;           ((->boolean (directory? f))
;;            (apply append (map list-files-in-tree
;;                               (->list (list-files f)))))
;;           (else
;;            (error (format #f "Improper file type in LIST-FILES-IN-TREE: ~s (~s ~s)" f (file? f) (directory? f)))))))

(define (main . args)
  (define-generic-java-method
    exit)
  (define-java-class <java.lang.system>)
  (process-options args)
  (or (option-base-file)
      (error "No base file: specify --base-file option"))
  (with-current-url (option-base-file)
     (lambda ()
       (for-each run-test-file
                 files-to-test)))
  (if (> (failures) 0)
      (format #t "Number of fails=~a~%" (failures)))
  (exit (java-null <java.lang.system>) (->jint (failures))))

(define (run-test-file file-name)
  (let ((url (normalize-url (current-url) file-name)))
    (or url
        (error (format #f "Can't find resource ~a" file-name)))
    (chatter "Running tests in ~a..." file-name)
    (load url)))

(define chatter
  (let ((chatter? #t))
    (lambda (fmt . args)
      (cond ((boolean? fmt)
             (set! chatter? fmt))
            (chatter?
             (apply format `(#t ,(string-append fmt "~%") ,@args)))
            (else
             #f)))))

(define (make-option default)
  (let ((v default))
    (lambda arg
      (if (null? arg)
          v
          (set! v (car arg))))))
(define option-base-file (make-option #f))
(define option-service-url (make-option #f))

(define (string-split-at-equals s)
  (let loop ((i 0))
    (cond ((>= i (string-length s))
           (cons s #f))
          ((char=? (string-ref s i) #\=)
           (cons (substring s 0 i)
                 (substring s (+ i 1) (string-length s))))
          (else
           (loop (+ i 1))))))

(define (process-options args)
  (let loop ((o args))
    (cond ((null? o)
           o)
          ((not (char=? (string-ref (car o) 0) #\-))
           o)
          (else ; it's an option
           (let ((p (string-split-at-equals (car o))))
             (cond ((string=? (car p) "--url")
                    (option-service-url (cdr p)))
                   ((string=? (car p) "--base-file")
                    (option-base-file (cdr p)))
                   (else
                    (error (format #f "Unrecognised option ~a" (car p)))))
             (loop (cdr o)))))))

;; Simple implementation of heapsort (?).  Probably not massively efficient
;; but there isn't a SRFI for sorting yet.  Sort the given list L with
;; respect to the given sorting function, <=.
;;
;; NOTE: this isn't a stable sort.
(define (sort-list l <=)
  (define (merge-lists ina inb)
    (let loop ((res '())
               (a ina)
               (b inb))
      (cond
       ((null? a)
        (append (reverse res) b))
       ((null? b)
        (append (reverse res) a))
       (else
        (if (<= (car a) (car b))
            (loop (cons (car a) res)
                  (cdr a)
                  b)
            (loop (cons (car b) res)
                  a
                  (cdr b)))))))

  (define (partition-list pe inl)
    (let loop ((pa '())
               (pb '())
               (l inl))
      (if (null? l)
          (values pa pb)
          (if (<= (car l) pe)
              (loop (cons (car l) pa) pb (cdr l))
              (loop pa (cons (car l) pb) (cdr l))))))

  (case (length l)
    ((0 1) l)
    ((2) (if (<= (car l) (cadr l))
             l
             (list (cadr l) (car l))))
    (else
     (let ((pe (car l)))
       (call-with-values
           (lambda () (partition-list pe (cdr l)))
         (lambda (left right)
           (merge-lists (sort-list left <=)
                        (cons pe (sort-list right <=)))))))))

;; The following is a self-test harness which doesn't quite work, due to a
;; bug in SISC
;; https://sourceforge.net/tracker/index.php?func=detail&aid=1650514&group_id=23735&atid=379534
;; It relies on including
;; (define-syntax self-test     ;in this file, discard all self-test content
;;   (syntax-rules ()
;;     ((_ form . forms)
;;      (define dummy #f))))
;; in source files, and then putting self-tests inline, wrapped in
;; (self-test ...).
;;
;; Revisit this with the next SISC release, after 1.16.x

;; ;; Test harness
;; ;; The first argument to MAIN should be the path to the directory containing
;; ;; the scripts to be tested

;; (define tested-modules '("utype-resolver/knowledge.scm"))

;; (import s2j)

;; (define (main . args)
;;   (define-generic-java-method exit)
;;   (define-java-class <java.lang.system>)
;;   (let ((statuses (with-current-url (car args)
;;                      (lambda ()
;;                        (map run-test-file tested-modules)))))
;;     (format #t "Statuses = ~s~%" statuses)
;;     (exit (java-null <java.lang.system>) 0)))

;; (define (run-test-file file-name)
;;   (let ((url (normalize-url (current-url) file-name)))
;;     (or url
;;         (error (format #f "Can't find resource ~a" file-name)))
;;     (chatter "Running tests in ~a..." url)
;;     (evaluate-test-harness-of url)))

;; ;; extract-self-tests : list -> list
;; ;; Given a list of sexps, extract all of the (self-test ...) forms, plus
;; ;; a (import modulename) form for any (module ...) forms encountered.
;; (define (extract-self-tests l)
;;   (cond ((or (symbol? l) (null? l))
;;          '())
;;         ((eq? (car l) 'module)
;;          (cons `(import ,(car l))
;;                (extract-self-tests (cdr l))))
;;         ((eq? (car l) 'self-test)
;;          (list l))
;;         (else
;;          (apply append (map extract-self-tests l)))))

;; ;; make-sexp-reader-from-file : string -> procedure
;; ;; Given a file, this returns a no-arg procedure which returns one sexp at a
;; ;; time from the file
;; (define (make-sexp-reader-from-file f)
;;   (let ((port (open-input-file f)))
;;     (lambda ()
;;       (if port
;;           (let ((s (read port)))
;;             (if (eof-object? s)
;;                 (begin (close-input-port port)
;;                        (set! port #f)))
;;             s)
;;           (error "get-sexp-reader procedure called after port closed")))))
;; (define (read-sexps-from-file f)
;;   (with-input-from-file f
;;     (lambda ()
;;       (let loop ((s (read)))
;;         (if (eof-object? s)
;;             '()
;;             (cons s (loop (read))))))))

;; (define (evaluate-test-harness-of url)
;;   ;(define next-sexp (make-sexp-reader-from-file url))
;;   (format #t "Testing ~a...~%" url)
;;   (let ((env (sisc-initial-environment))
;;         (sexps (read-sexps-from-file url)))
;;     (format #t "sexps=~s~%" sexps)
;;     (eval '(define nfails 0) env)
;;     (eval '(define-syntax expect
;;              (syntax-rules ()
;;                ((_ expected body)
;;                 (let ((test ((lambda () body))))
;;                   (if (not (equal? expected test))
;;                       (begin (format #t "Test ~a: produced ~s, expected ~s~%"
;;                                      (quote body) test expected)
;;                              (set! nfails (+ nfails 1)))
;;                       (format #t "Test ~a OK!~%" (quote body)))))))
;;           env)
;;     (for-each (lambda (s)
;;                 (eval s env))
;;               sexps)
;;     (eval '(define-syntax self-test
;;              (syntax-rules ()
;;                ((_ form . forms)
;;                 (let () form . forms))))
;;           env)
;; ;;     (eval `(load ,url) env)
;; ;;     (let loop ((s (next-sexp)))
;; ;;       (format #t "evaluate-test-harness-of ~a : s=~s~%" url s)
;; ;;       (if (eof-object? s)
;; ;;           nfails
;; ;;           (begin (eval s env)
;; ;;                  (loop (next-sexp)))))
;;     (format #t "now running self-tests: ~s~%" (extract-self-tests sexps))
;;     (for-each (lambda (s)
;;                 (eval s env))
;;               (extract-self-tests sexps))
;;     ))

;; (define chatter
;;   (let ((chatter? #t))
;;     (lambda (fmt . args)
;;       (cond ((boolean? fmt)
;;              (set! chatter? fmt))
;;             (chatter?
;;              (apply format `(#t ,(string-append fmt "~%") ,@args)))
;;             (else
;;              #f)))))
