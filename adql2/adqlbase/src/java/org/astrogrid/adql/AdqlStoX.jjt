/*$Id: AdqlStoX.jjt,v 1.34 2007/07/30 09:03:47 jl99 Exp $*/

//
// High-level JavaDoc comments are present in this file.
// There is little point in placing any here. 
// At this point they are ignored by the JavaCC processors. 
//
// Jeff Lusted 
//
   
options {
  JDK_VERSION="1.4";
  STATIC=false;
  MULTI=true;
  VISITOR=false;
  NODE_USES_PARSER=true;
  NODE_DEFAULT_VOID=true;
  NODE_PREFIX="AST_";
  IGNORE_CASE=true;
  NODE_SCOPE_HOOK=true ; 
}

PARSER_BEGIN(AdqlStoX)
package org.astrogrid.adql ;

import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;
import java.util.HashSet ;
import java.util.ArrayList ;
import java.util.List ;
import org.astrogrid.adql.beans.* ;
import org.astrogrid.stc.beans.* ;

/**
 * AdqlStoX         
 * <p>
 * AdqlStoX is a generated class. It started life as a JavaCC file with a file extension of .jjt, 
 * producing a syntax tree.
 * All of the classes with a name prefix of "AST_" were emitted as part of this syntax tree.
 * Other classes emitted as an adjunct of AdqlStoX are:
 * <blockquote><pre>
 * org.astrogrid.adql.AdqlStoXConstants
 * org.astrogrid.adql.AdqlStoTokenManager 
 * org.astrogrid.adql.AdqlStoXTreeConstants 
 * org.astrogrid.adql.ParseException 
 * org.astrogrid.adql.SimpleCharacterStream
 * org.astrogrid.adql.SimpleNode
 * org.astrogrid.adql.Token
 * org.astrogrid.adql.TokenMgrError     
 * </pre></blockquote>
 * There is one emitted interface:
 * org.astrogrid.adql.SimpleNode
 * <p>
 * AdqlStoX takes text in the form of Adql/s and parsers it into xml Adql/x format.
 * Adql/s is based upon SQL/92 with astronomical extensions. However, AdqlStoX is wrapped
 * by class org.astrogrid.adql.AdqlCompiler. All public and protected methods should
 * be invoked only from AdqlCompiler!
 * <p>
 * For those who are interested, and have access to the source for AdqlStoX.jtt,
 * the following details may be of use in reconciling the method names to the BNF
 * specification of ADQL. The methods are not documented, and will probably remain
 * undocumented, although some constructors are approximately mirrored within AdqlCompiler.  
 * However, there is a naming convention for methods, which is aimed at making the match
 * with the BNF diagrams as clear as possible...
 * <p>
 * (1) All methods which are quoted bnf statements follow the bnf format, 
 *     with any embedded dashes (-) removed from the name.
 *     Thus the statment &lt;comparison_predicate> from the SQL/92 standard
 *     will have a corresponding method with a name similar to comparison_predicate().
 *     However, such methods are decorated in a particular way, for which see
 *     points (2) and (3) below. All methods which are tantamount to quoted
 *     bnf will have the standard syntax as a comment embedded within the source. However,
 *     this style of comment is private to the original .jjt file and is not emitted
 *     into the java code. 
 *     Thus:
 * <blockquote><pre>
 *     //S:
 *     // &lt;row_value_constructor> &lt;comp_op> &lt;row_value_constructor>
 * </pre></blockquote>
 * <p>
 * (2) Methods which follow exactly the SQL/92 syntax at a shallow level are suffixed _S.
 *     Thus comparison_predicate_S() represents the SQL/92 standard syntax. Shallow implies
 *     that the syntax can still vary from the standard within statements quoted
 *     within the given construct. This is usually pretty obvious from the quoted statements
 *     (eg: quoted statement some_statement_A() means an ADQL variation, see next point), 
 *     but be aware that it is possible for variations to be deeply embedded.
 *     NB: A statement that is just a synonym for another statement will take
 *         the quoted statement's decoration. This is the one exception.
 * <p>
 * (3) Methods which are varied for some reason within ADQL, or are simply
 *     specific to ADQL, are suffixed _A.
 *     Thus comparison_predicate_A() represents an ADQL deviation.
 * <p>
 * (4) Some methods are introduced as implementations of part of a syntax.
 *     This is just to make for a neater structure. These methods follow
 *     the standard Java OO naming convention and are not decorated, 
 *     eg: numericValueExpressionList().
 * <p>
 * There is built-in documentation to help in supporting BNF syntax diagrams. This built-in
 * documentation consists of special comments throughout the code. It is separate from the
 * above four conventions and must be maintained by the developer to correspond to the working
 * of the compiler. Thus the resulting BNF documentation represents what the compiler does. 
 * This seems a little back-to-front but is reasonably thorough in its results. There are two 
 * sorts of comments: singletons and multiples, depending on whether the BNF definition is on 
 * one or more lines. Two examples are given below:
 * <p>
 * <blockquote><pre>
 *     bnf-single &lt;boolean_factor> ::= [ NOT ] &lt;boolean_test>
 *     bnf-start
 *        &lt;between_predicate> ::=
 *          &lt;value_expression> [ NOT ] BETWEEN
 *          &lt;value_expression> AND &lt;value_expression>
 *     bnf-end
 * </pre></blockquote>
 * (Real ones have to be positioned at the beginning of a line with each line prefixed by
 * the string " * " exactly. )
 * <p>
 * A utility programme BnfExtractor extracts these from the source and places them in 
 * suitable files (or to standard out). BnfExtractor produces output in two formats:
 * plain text and html. 
 * <p>     
 * @author Jeff Lusted jl99@star.le.ac.uk
 * Sep 2006
 */
public class AdqlStoX {
	
	private static Log log = LogFactory.getLog( AdqlStoX.class ) ;
	
	private static final int DONT_CHANGE_SIGN = 1 ;
    
	protected Tracker tracker ;
	protected HashSet comments ; 
	protected AdqlCompiler compiler ; 
	protected Token lastCommentWritten ;
	protected LinkedListType currentLinkedElementList ; 
	void jjtreeOpenNodeScope( org.astrogrid.adql.Node n ) {		((SimpleNode)n).firstToken = getToken(1);	}		    void jjtreeCloseNodeScope( org.astrogrid.adql.Node n ) {        ((SimpleNode)n).lastToken = getToken(0);    }    	private void enterTrace( String entry ) {
		log.trace( compiler.getIndent().toString() + "enter: " + entry ) ;
		compiler.indentPlus() ;	}    private void exitTrace( String entry ) {    	compiler.indentMinus() ;
		log.trace( compiler.getIndent().toString() + "exit : " + entry ) ;	}
	
}
PARSER_END(AdqlStoX)

/*
 * SPECIAL_TOKEN: COMMENTS
 *
 * bnf-single <comment> ::= <comment_introducer> [ <comment_character>... ] <newline>
 * bnf-single <comment_character> ::= <nonquote_character> | <quote>
 * bnf-single <comment_introducer> ::= <minus_sign><minus_sign> [<minus_sign>...]
 * bnf-start
 *  <newline> ::= 
 *  !! Implementation defined end of line indicator
 * bnf-end
 * bnf-start
 *  <nonquote_character> ::= 
 *  !! One ASCII character
 * bnf-end
 *
 */
SPECIAL_TOKEN : /* COMMENTS */
{ 
// There are shortcomings in this definition to do with
// multiple line comments that do not start at the
// beginning of a line; ie: a comment where there is
// white space at the start of lines.
   < COMMENT : ( <SINGLE_LINE_COMMENT> )+ >
|  < #SINGLE_LINE_COMMENT: ("\n"|"\r"|"\r\n"|" "|"\t")* "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

SKIP :
{
 	" "
|	"\n"
|	"\r"
|	"\t"
}


/*
 * TOKEN <SQL_special_character> 
 *
 * bnf-start
 *  <SQL_special_character> ::=
 *     <space>
 *   | <double_quote>
 *   | <percent>
 *   | <ampersand>
 *   | <quote>
 *   | <left_paren>
 *   | <right_paren>
 *   | <asterisk>
 *   | <plus_sign>
 *   | <comma>
 *   | <minus_sign>
 *   | <period>
 *   | <solidus>
 *   | <colon>
 *   | <semicolon>
 *   | <less_than_operator>
 *   | <equals_operator>
 *   | <greater_than_operator>
 *   | <question_mark>
 *   | <underscore>
 *   | <vertical_bar>
 *  !! ADQL Note:
 *  !! The draft spec omits <ampersand> <semicolon> <question_mark> and <vertical_bar>
 *  !! I believe the spec is in error.
 * bnf-end
 * bnf-start
 *  <space> ::=
 *  !! Imagine there is a space character here
 * bnf-end
 * bnf-single <double_quote> ::= "
 * bnf-single <percent> ::= %
 * bnf-single <ampersand> ::= &
 * bnf-single <quote> ::= '
 * bnf-single <left_paren> ::= (
 * bnf-single <right_paren> ::= )
 * bnf-single <asterisk> ::= *
 * bnf-single <plus_sign> ::= +
 * bnf-single <comma> ::= ,
 * bnf-single <minus_sign> ::= -
 * bnf-single <period> ::= .
 * bnf-single <solidus> ::= /
 * bnf-single <colon> ::= :
 * bnf-single <semicolon> ::= ;
 * bnf-single <less_than_operator> ::= <
 * bnf-single <equals_operator> ::= =
 * bnf-single <greater_than_operator> ::= >
 * bnf-single <question_mark> ::= ?
 * bnf-single <underscore> ::= _
 * bnf-single <vertical_bar> ::= |
 */
TOKEN : // <SQL_special_character> 
{
  < DOUBLE_QUOTE: "\"\"" >
| < PERCENT: "%" >
// ampersand does not appear in the draft
| < AMPERSAND: "&" >
| < QUOTE: "'" >
| < LEFT_PAREN: "(" >
| < RIGHT_PAREN: ")" >
| < ASTERISK: "*" >
| < PLUS_SIGN: "+" >
| < COMMA: "," >
| < MINUS_SIGN: "-" >
| < PERIOD: "." >
| < SOLIDUS: "/" >
| < COLON: ":" >
// semicolon does not appear in the draft
| < SEMICOLON: ";" >
| < LESS_THAN_OPERATOR : "<" >
| < EQUALS_OPERATOR : "=" >
| < GREATER_THEN_OPERATOR : ">" >
// question mark does not appear in the draft
| < QUESTION_MARK: "?" >
| < UNDERSCORE: "_" >
// vertical bar does not appear in the draft
| < VERTICAL_BAR: "|" >
}

/*
 * TOKEN <SQL_embedded_language_character>
 *
 * bnf-start
 *  <SQL_embedded_language_character> ::=
 *      <left_bracket>
 *    | <right_bracket>
 * bnf-end
 * bnf-single <left_bracket> ::= [
 * bnf-single <right_bracket> ::= ]
 *
 */
TOKEN : // <SQL_embedded_language_character>
{
  < LEFT_BRACKET: "[" >
| < RIGHT_BRACKET: "]" >	
}

/*
 * TOKEN <SQL_reserved_word>
 *
 * bnf-start
 *  <SQL_reserved_word> ::=
 *     ABSOLUTE | ACTION | ADD | ALL
 *   | ALLOCATE | ALTER | AND
 *   | ANY | ARE
 *   | AS | ASC
 *   | ASSERTION | AT
 *   | AUTHORIZATION | AVG
 *   | BEGIN | BETWEEN | BIT | BIT_LENGTH
 *   | BOTH | BY
 *   | CASCADE | CASCADED | CASE | CAST
 *   | CATALOG
 *   | CHAR | CHARACTER | CHAR_LENGTH
 *   | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE
 *   | COLLATE | COLLATION
 *   | COLUMN | COMMIT
 *   | CONNECT
 *   | CONNECTION | CONSTRAINT
 *   | CONSTRAINTS | CONTINUE
 *   | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS
 *   | CURRENT
 *   | CURRENT_DATE | CURRENT_TIME
 *   | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
 *   | DATE | DAY | DEALLOCATE 
 *   | DECIMAL | DECLARE | DEFAULT | DEFERRABLE
 *   | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR
 *   | DIAGNOSTICS
 *   | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
 *   | ELSE | END | END-EXEC | ESCAPE
 *   | EXCEPT | EXCEPTION
 *   | EXEC | EXECUTE | EXISTS
 *   | EXTERNAL | EXTRACT
 *   | FALSE | FETCH | FIRST | FLOAT | FOR
 *   | FOREIGN | FOUND | FROM | FULL
 *   | GET | GLOBAL | GO | GOTO
 *   | GRANT | GROUP
 *   | HAVING | HOUR
 *   | IDENTITY | IMMEDIATE | IN | INDICATOR
 *   | INITIALLY | INNER | INPUT
 *   | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT
 *   | INTERVAL | INTO | IS
 *   | ISOLATION
 *   | JOIN
 *   | KEY
 *   | LANGUAGE | LAST | LEADING | LEFT
 *   | LEVEL | LIKE | LOCAL | LOWER
 *   | MATCH | MAX | MIN | MINUTE | MODULE
 *   | MONTH
 *   | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO
 *   | NOT | NULL
 *   | NULLIF | NUMERIC
 *   | OCTET_LENGTH | OF
 *   | ON | ONLY | OPEN | OPTION | OR
 *   | ORDER | OUTER
 *   | OUTPUT | OVERLAPS
 *   | PAD | PARTIAL | POSITION | PRECISION | PREPARE
 *   | PRESERVE | PRIMARY
 *   | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
 *   | READ | REAL | REFERENCES | RELATIVE | RESTRICT
 *   | REVOKE | RIGHT
 *   | ROLLBACK | ROWS
 *   | SCHEMA | SCROLL | SECOND | SECTION
 *   | SELECT
 *   | SESSION | SESSION_USER | SET
 *   | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE
 *   | SQLERROR | SQLSTATE
 *   | SUBSTRING | SUM | SYSTEM_USER
 *   | TABLE | TEMPORARY
 *   | THEN | TIME | TIMESTAMP
 *   | TIMEZONE_HOUR | TIMEZONE_MINUTE
 *   | TO | TRAILING | TRANSACTION
 *   | TRANSLATE | TRANSLATION | TRIM | TRUE
 *   | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE
 *   | USER | USING
 *   | VALUE | VALUES | VARCHAR | VARYING | VIEW
 *   | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
 *   | YEAR
 *   | ZONE
 *  !! ADQL Note:
 *  !! I've removed DEC from the reserved words.
 *  !! There was just too much hassle involved.
 *  !! But I'm against making any other exceptions.
 * bnf-end
 */
TOKEN : // <SQL_reserved_word>
{
  < ABSOLUTE : "absolute" >
| < ACTION : "action" >
| < ADD : "add" >
| < ALL : "all" >
| < ALLOCATE : "allocate" >
| < ALTER : "alter" >
| < AND : "and" >
| < ANY : "any" >
| < ARE : "are" >
| < AS : "as" >
| < ASC : "asc" >
| < ASSERTION : "assertion" >
| < AT : "at" >
| < AUTHORIZATION : "authorization" >
| < AVG : "avg" >
| < BEGIN : "begin" >
| < BETWEEN : "between" >
| < BIT : "bit" >
| < BIT_LENGTH : "bit_length" >
| < BOTH : "both" >
| < BY : "by" >
| < CASCADE : "cascade" >
| < CASCADED : "cascaded" >
| < CASE : "case" >
| < CAST : "cast" >
| < CATALOG : "catalog" >
| < CHAR : "char" >
| < CHARACTER : "character" >
| < CHAR_LENGTH : "char_length" >
| < CHARACTER_LENGTH : "character_length" >
| < CHECK : "check" >
| < CLOSE : "close" >
| < COALESCE : "coalesce" >
| < COLLATE : "collate" >
| < COLLATION : "collation" >
| < COLUMN : "column" >
| < COMMIT : "commit" >
| < CONNECT : "connect" >
| < CONNECTION : "connection" >
| < CONSTRAINT : "constraint" >
| < CONSTRAINTS : "constraints" >
| < CONTINUE : "continue" >
| < CONVERT : "convert" >
| < CORRESPONDING : "corresponding" >
| < COUNT : "count" >
| < CREATE : "create" >
| < CROSS : "cross" >
| < CURRENT : "current" >
| < CURRENT_DATE : "current_date" >
| < CURRENT_TIME : "current_time" >
| < CURRENT_TIMESTAMP : "current_timestamp" >
| < CURRENT_USER : "current_user" >
| < CURSOR : "cursor" >
| < DATE : "date" >
| < DAY : "day" >
| < DEALLOCATE : "deallocate" >
// | < DEC : "dec" >
| < DECIMAL : "decimal" >
| < DECLARE : "declare" >
| < SQL_DEFAULT : "default" >
| < DEFERRABLE : "deferrable" >
| < DEFERRED : "deferred" >
| < DELETE : "delete" >
| < DESC : "desc" >
| < DESCRIBE : "describe" >
| < DESCRIPTOR : "descriptor" >
| < DIAGNOSTICS : "diagnostics" >
| < DISCONNECT : "disconnect" >
| < DISTINCT : "distinct" >
| < DOMAIN : "domain" >
| < DOUBLE : "double" >
| < DROP : "drop" >
| < ELSE : "else" >
| < END : "end" >
| < ENDEXEC : "end-exec" >
| < ESCAPE : "escape" >
| < EXCEPT : "except" >
| < EXCEPTION : "exception" >
| < EXEC : "exec" >
| < EXECUTE : "execute" >
| < EXISTS : "exists" >
| < EXTERNAL : "external" >
| < EXTRACT : "extract" >
| < FALSE : "false" >
| < FETCH : "fetch" >
| < FIRST : "first" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FOREIGN : "foreign" >
| < FOUND : "found" >
| < FROM : "from" >
| < FULL : "full" >
| < GET : "get" >
| < GLOBAL : "global" >
| < GO : "go" >
| < GOTO : "goto" >
| < GRANT : "grant" >
| < GROUP : "group" >
| < HAVING : "having" >
| < HOUR : "hour" >
| < IDENTITY : "identity" >
| < IMMEDIATE : "immediate" >
| < IN : "in" >
| < INDICATOR : "indicator" >
| < INITIALLY : "initially" >
| < INNER : "inner" >
| < INPUT : "input" >
| < INSENSITIVE : "insensitive" >
| < INSERT : "insert" >
| < INT : "int" >
| < INTEGER : "integer" >
| < INTERSECT : "instersect" >
| < INTERVAL : "interval" >
| < INTO : "into" >
| < IS : "is" >
| < ISOLATION : "isolation" >
| < JOIN : "join" >
| < KEY : "key" >
| < LANGUAGE : "language" >
| < LAST : "last" >
| < LEADING : "leading" >
| < LEFT : "left" >
| < LEVEL : "level" >
| < LIKE : "like" >
| < LOCAL : "local" >
| < LOWER : "lower" >
| < MATCH : "match" >
| < MAX : "max" >
| < MIN : "min" >
| < MINUTE : "minute" >
| < MODULE : "module" >
| < MONTH : "month" >
| < NAMES : "names" >
| < NATIONAL : "national" >
| < NATURAL : "natural" >
| < NCHAR : "nchar" >
| < NEXT : "next" >
| < NO : "no" >
| < NOT : "not" >
| < NULL : "null" >
| < NULLIF : "nullif" >
| < NUMERIC : "numeric" >
| < OCTET_LENGTH : "octet_length" >
| < OF : "of" >
| < ON : "on" >
| < ONLY : "only" >
| < OPEN : "open" >
| < OPTION : "option" >
| < OR : "or" >
| < ORDER : "order" >
| < OUTER : "outer" >
| < OUTPUT : "output" >
| < OVERLAPS : "overlaps" >
| < PAD : "pad" >
| < PARTIAL : "partial" >
| < POSITION : "position" >
| < PRECISION : "precision" >
| < PREPARE : "prepare" >
| < PRESERVE : "preserve" >
| < PRIMARY : "primary" >
| < PRIOR : "prior" >
| < PRIVILEGES : "privileges" >
| < PROCEDURE : "procedure" >
| < PUBLIC : "public" >
| < READ : "read" >
| < REAL : "real" >
| < REFERENCES : "references" >
| < RELATIVE : "relative" >
| < RESTRICT : "restrict" >
| < REVOKE : "revoke" >
| < RIGHT : "right" >
| < ROLLBACK : "rollback" >
| < ROWS : "rows" >
| < SCHEMA : "schema" >
| < SCROLL : "scroll" >
| < SECOND : "second" >
| < SECTION : "section" >
| < SELECT : "select" >
| < SESSION : "session" >
| < SESSION_USER : "session_user" >
| < SET : "set" >
| < SIZE : "size" >
| < SMALLINT : "smallint" >
| < SOME : "some" >
| < SPACE : "space" >
| < SQL : "sql" >
| < SQLCODE : "sqlcode" >
| < SQLERROR : "sqlerror" >
| < SQLSTATE : "sqlstate" >
| < SUBSTRING : "substring" >
| < SUM : "sum" >
| < SYSTEM_USER : "system_user" >
| < TABLE : "table" >
| < TEMPORARY : "temporary" >
| < THEN : "then" >
| < TIME : "time" >
| < TIMESTAMP : "timestamp" >
| < TIMEZONE_HOUR : "timezone_hour" >
| < TIMEZONE_MINUTE : "timezone_minute" >
| < TO : "to" >
| < TRAILING : "trailing" >
| < TRANSACTION : "transaction" >
| < TRANSLATE : "translate" >
| < TRANSLATION : "translation" >
| < TRIM : "trim" >
| < TRUE : "true" >
| < UNION : "union" >
| < UNIQUE : "unique" >
| < UNKNOWN : "unknown" >
| < UPDATE : "update" >
| < UPPER : "upper" >
| < USAGE : "usage" >
| < USER : "user" >
| < USING : "using" >
| < VALUE : "value" >
| < VALUES : "values" >
| < VARCHAR : "varchar" >
| < VARYING : "varying" >
| < VIEW : "view" >
| < WHEN : "when" >
| < WHENEVER : "whenever" >
| < WHERE : "where" >
| < WITH : "with" >
| < WORK : "work" >
| < WRITE : "write" >
| < YEAR : "year" >
| < ZONE : "zone" >
}

// <non-reserved_word> 
//
// Cannot be certain what to make of these yet
//{ //  < ADA : "ada" >//| < C: "c" >//| < CATALOG_NAME: "catalog_name" >//| < CHARACTER_SET_CATALOG: "character_set_catalog" >//| < CHARACTER_SET_NAME: "character_set_name" >//| < CHARACTER_SET_SCHEMA: "character_set_schema" >//| < CLASS_ORIGIN: "class_origin" >//| < COBOL: "cobol" >//| < COLLATION_CATALOG: "collation_catalog" >//| < COLLATION_NAME: "collation_name" >//| < COLLATION_SCHEMA: "collation_schema" >//| < COLUMN_NAME: "column_name" >//| < COMMAND_FUNCTION: "command_function" >//| < COMMITTED: "committed" >//| < CONDITION_NUMBER: "condition_number" >//| < CONNECTION_NAME: "connection_name" >//| < CONSTRAINT_CATALOG: "constraint_catalog" >//| < CONSTRAINT_NAME: "constraint_name" >//| < CONSTRAINT_SCHEMA: "constraint_schema" >//| < CURSOR_NAME: "cursor_name" >//| < DATA: "data" >//| < DATETIME_INTERVAL_CODE: "datetime_interval_code" >//| < DATETIME_INTERVAL_PRECISION: "datetime_interval_precision" >//| < DYNAMIC_FUNCTION: "dynamic_function" >//| < FORTRAN: "fortran" >//| < LENGTH: "length" >//| < MESSAGE_LENGTH: "message_length" >//| < MESSAGE_OCTET_LENGTH: "message_octet_length" >//| < MESSAGE_TEXT: "message_text" >//| < SQL_MORE: "more" >//| < MUMPS: "mumps" >//| < NAME: "name" >//| < NULLABLE: "nullable" >//| < NUMBER: "number" >//| < PASCAL: "pascal" >//| < PLI: "pli" >//| < REPEATABLE: "repeatable" >//| < RETURNED_LENGTH: "returned_length" >//| < RETURNED_OCTET_LENGTH: "returned_octet_length" >//| < RETURNED_SQLSTATE: "returned_sqlstate" >//| < ROW_COUNT: "row_count" >//| < SCALE: "scale" >//| < SCHEMA_NAME: "schema_name" >//| < SERIALIZABLE: "serializable" >//| < SERVER_NAME: "server_name" >//| < SUBCLASS_ORIGIN: "subclass_origin" >//| < TABLE_NAME: "table_name" >//| < TYPE: "type" >//| < UNCOMMITTED: "uncommitted" >//| < UNNAMED: "unnamed" >//}

/*
 * TOKEN <ADQL-reserved-word>
 * 
 * bnf-start
 *  <ADQL_reserved_word> ::=
 *      ABS 
 *    | ACOS 
 *    | ASIN 
 *    | ATAN 
 *    | ATAN2 
 *    | CEILING 
 *    | COS 
 *    | DEGREES 
 *    | EXP 
 *    | FLOOR 
 *    | LOG 
 *    | LOG10 
 *    | MODE 
 *    | PI 
 *    | POWER 
 *    | RADIANS 
 *    | REGION 
 *    | RAND 
 *    | ROUND 
 *    | SIN 
 *    | SQUARE
 *    | SQRT 
 *    | TOP
 *    | TAN 
 *    | TRUNCATE
 *    | UDF  
 *    | VAR
 *  !! ADQL Note:
 *  !! VAR is part of an experiment in supporting scripting variables.
 * bnf-end
 *
 */
TOKEN : // <ADQL_reserved_word>
{

	< TOP: "top" >
	
	//region
|	< REGION: "region" >
|   < J2000: "J2000" > 
|   < LATLON: "LATLON" >
|   < CARTESIAN: "CARTESIAN" >
|   < CONVEX: "CONVEX" > 
|   < CIRCLE: "CIRCLE" >
|   < RECT: "RECT" >
|   < POLY: "POLY" >
|   < CHULL: "CHULL" >
|   < BOX: "BOX" >
	
	//math
|   < ABS: "abs" >
|	< CEILING: "ceiling" >
|	< DEGREES: "degrees" >
|	< EXP: "exp" >
|	< FLOOR: "floor" >
|	< LOG: "log" >
|	< PI: "pi" >
|	< POWER: "power" >
|	< RADIANS: "radians" >
|	< SQRT: "sqrt" >
// <SQUARE> is not in the draft standard
|	< SQUARE: "square" >
|	< LOG10: "log10" >
|	< RAND: "rand" >
|	< ROUND: "round" >
|	< TRUNCATE: "truncate" >
	
	//trig
|	< SIN: "sin" >
|	< COS: "cos" >
|	< TAN: "tan" >
|	< COT: "cot" >
|	< ASIN: "asin" >
|	< ACOS: "acos" >
|	< ATAN: "atan" >
|	< ATAN2: "atan2" >

|   < VAR: "var" >
}

/*
 * TOKEN <ADQL_special_character>
 *
 * bnf-start
 *  <ADQL_special_character> ::=
 *      <left_brace>
 *    | <right_brace>
 *    | <dollar>
 *   !! ADQL Note:
 *   !! These are not present in the ADQL draft.
 *   !! Part of an experiment to see whether it is possible to accommodate
 *   !! the presence of scripting variables in a query.
 * bnf-end
 * bnf-single <left_brace> ::= {
 * bnf-single <right_brace> ::= }
 * bnf-single <dollar> ::= $
 */
TOKEN : // <ADQL_special_character>
{ 
	< LBRACE : "{" >
|	< RBRACE : "}" >
|	< DOLLAR : "$" >		
}

/*
 * TOKEN miscellaneous SQL92 
 *
 * bnf-start 
 *  <ADQL_language_character> ::=
 *      <simple_Latin_letter>
 *    | <digit>
 *    | <SQL_special_character>
 * bnf-end
 *
 * bnf-single <keyword> ::= <SQL_reserved_word> | <ADQL_reserved_word>
 *
 * bnf-single <not_equals_operator1> ::= <>
 * bnf-single <not_equals_operator2> ::= !=
 * bnf-single <not_equals_operator> ::= <not_equals_operator1> | <not_equals_operator2>
 * bnf-single <less_than_or_equals_operator> ::= <=
 * bnf-single <greater_than_or_equals_operator> ::= >=
 * bnf-single <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 * bnf-start
 *  <simple_Latin_letter> ::=
 *      <simple_Latin_upper_case_letter>
 *    | <simple_Latin_lower_case_letter>
 * bnf-end
 * bnf-start
 *  <simple_Latin_upper_case_letter> ::=
 *      A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
 *    | P | Q | R | S | T | U | V | W | X | Y | Z
 * bnf-end
 * bnf-start
 *  <simple_Latin_lower_case_letter> ::=
 *      a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
 *    | p | q | r | s | t | u | v | w | x | y | z
 * bnf-end
 * bnf-start
 *  <regular_identifier> ::=
 *      <simple_Latin_letter>... 
 *      [ { <digit> | <simple_Latin_letter> | <dollar> | <underscore> }... ]
 *  !! ADQL Note:
 *  !! Draft spec does not have <dollar>. 
 * bnf-end
 * bnf-start
 *  <delimited_identifier> ::=
 *  !! ADQL Note:
 *  !! Begins and ends with a double quote as delimiters
 *  !! but itself contains no double quotes or white space.
 *  !! The draft spec needs correcting. It has
 *  !! <delimited_identifier> ::= <double_quote> <regular_identifier> <double_quote> 
 *  !! which cannot be correct. 
 *  !! If this were the case, we could simply make do with <regular_identifier>
 * bnf-end
 * bnf-single <unsigned_integer> ::= <digit>...
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 * bnf-single <mantissa> ::= <exact_numeric_literal>
 * bnf-single <exponent> ::= <signed_integer> 
 * bnf-single <signed_integer> ::= [ <sign> ] <unsigned_integer>
 *
 */
TOKEN : // miscellaneous SQL92 
{
	< ASCII_STRING_LITERAL : "\'" (~["\'"])* "\'" >

//| < ASCIIStringLiteral : "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >
//|	< UnicodeStringLiteral : "n" "\'" (~["\'"])* "\'" ( "\'" (~["\'"])* "\'" )* >
	
|	< NOT_EQUALS_OPERATOR : "<>" | "!=" >
|	< LESS_THAN_OR_EQUALS_OPERATOR : "<=" >
|	< GREATER_THAN_OR_EQUALS_OPERATOR : ">=" >
|	< CROSS_JOIN : "cross join">
|	< GROUPBY: "group by" >
|	< ORDERBY : "order by" >
|	< TIME_ZONE: "TIME ZONE" >
|	< TRUTH_VALUE : "true" | "false" | "unknown" >

|   < REGULAR_IDENTIFIER : ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIAL_CHARS> )* >|	< DELIMITED_IDENTIFIER : "\"" (~["\n","\r","\""])* "\"" >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: <DOLLAR> | "_">
|   < APPROXIMATE_NUMERIC_LITERAL : <MANTISSA> <E> <EXPONENT> > 
|	< UNSIGNED_INTEGER : ( <DIGIT> )+ > 
|  	< DIGIT: ["0" - "9"] >   
|   < EXACT_NUMERIC_LITERAL : 
        ( <UNSIGNED_INTEGER> ( <PERIOD> ( <UNSIGNED_INTEGER> )? )? )
        | 
        ( <PERIOD> <UNSIGNED_INTEGER> ) >
|   < #MANTISSA : <EXACT_NUMERIC_LITERAL> >
|   < #EXPONENT : <SIGNED_INTEGER> >        
|	< #SIGNED_INTEGER : ( <SIGN> )? <UNSIGNED_INTEGER> >
|   < #E : ["E", "e"] >
|   < #SIGN : <PLUS_SIGN> | <MINUS_SIGN> >

}

/*
 * TOKEN The remainder men.
 *
 *
 */
TOKEN : // The remainder
{
	< OTHER : ~[] >
}

/*
 * Dummy Tokens.
 * This section is really comment only, consisting of documentation
 * of things that are not used (so far) but are there for completeness
 * of the BNF diagrams.
 *
 * bnf-start
 *  <delimiter_token> ::=
 *        <character_string_literal>
 *    |   <delimited_identifier>
 *    |   <SQL_special_character>
 *    |   <not_equals_operator>
 *    |   <greater_than_or_equals_operator>
 *    |   <less_than_or_equals_operator>
 *    |   <concatenation_operator>
 *    |   <double_period>
 *    |   <left_bracket>
 *    |   <right_bracket>
 *   !! ADQL Note:
 *   !! The draft spec has <boolean_literal> and does not have <delimitied_identifier> 
 *   !! Should it also have <ADQL_special_character> ? 
 * bnf-end
 * bnf-single <concatenation_operator> ::= ||
 * bnf-start
 *  <nondelimiter_token> ::= 
 *      <regular_identifier>
 *    | <keyword>
 *    | <unsigned_numeric_literal>
 *   !! For information, SQL92 has some others. 
 *   !! (Jeff: Not sure I understand how this is used.)
 * bnf-end
 * bnf-start
 *  <token> ::= 
 *      <nondelimiter_token>
 *    | <delimiter_token>
 * bnf-end
 * bnf-single <double_period> ::= ..
 *
 */


/*
 * actual_identifier_S
 *
 * bnf-single <identifier> ::= <regular_identifier> | <delimited_identifier>
 *
 */
void actual_identifier_S() #ActualIdentifier : 
{
    if( log.isTraceEnabled() ) enterTrace ( "actual_identifier_S()" ) ;
} 
{
    //S:
    // <regular_identifier> | <delimited_identifier>
	( <REGULAR_IDENTIFIER> | <DELIMITED_IDENTIFIER> )
	{
		if( log.isTraceEnabled() ) exitTrace ( "actual_identifier_S()" ) ;		
	}
}

void signed_integer_S() : {}
{
	(<PLUS_SIGN> | <MINUS_SIGN>) <UNSIGNED_INTEGER> 
}

/*
 * between_predicate_A
 *
 * bnf-start
 * <between_predicate> ::=
 *     <value_expression> [ NOT ] BETWEEN
 *     <value_expression> AND <value_expression>
 * bnf-end
 *
 */
void between_predicate_A() #BetweenPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "between_predicate_A()" ) ;
	// Assume "BETWEEN"...
	tracker.setType( BetweenPredType.type ) ;
}
{
	//S:
	// <row_value_constructor> [ NOT ] BETWEEN
    // <row_value_constructor> AND <row_value_constructor>
    
    // Note the absence of row_value_constructor...	
    (
       { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A() 
	   { tracker.pop() ; }
	   [ <NOT> 
	     // We know now it is a "NOT BETWEEN"...
	     { tracker.setType( NotBetweenPredType.type ) ;
	       jjtThis.setBetween(false); } 
	   ] 
	   <BETWEEN> 
	   { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A()
	   { tracker.pop() ; }
	   <AND> 
	   { tracker.push( compiler.ARG_ELEMENT ) ; }
	   value_expression_A()
	   { tracker.pop() ; }
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "between_predicate_A()" ) ;
	}
}

/*
 * boolean_primary_S
 *
 * bnf-start
 *  <boolean_primary> ::=
 *     | <left_paren> <search_condition> <right_paren> 
 *       <predicate> 
 * bnf-end
 *
 */
void boolean_primary_S() #BooleanPrimary :  
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_primary_S()" ) ;
} 
{
	//S:
	// <boolean_primary> ::=
    //    <predicate>
    //  | <left_paren> <search_condition> <right_paren>
// 	try {
	    (
	    // lookahead was 6 and not happy about this 
	    // as the error messages produced are gargantuan
	       LOOKAHEAD( <LEFT_PAREN> search_condition_S() <RIGHT_PAREN> )
		   ( 
		     <LEFT_PAREN> 
		     { 
		     	tracker.push( compiler.CONDITION_ELEMENT, ClosedSearchType.type ) ; 
		        jjtThis.setParenthesized() ; 
		     }
		     search_condition_S() 
		     { tracker.pop() ; }
		     <RIGHT_PAREN> 
		   )
		   |
		   predicate_A()
	    )
// 	}// 	catch ( ParseException pex ) {		// 	   throw pex ;	// 	}
    {  	
    	if( log.isTraceEnabled() ) exitTrace ( "boolean_primary_S()" ) ;
    }
}

/*
 * boolean_term_S
 *
 * bnf-start
 *  <boolean_term> ::=
 *      <boolean_factor>
 *    | <boolean_term> AND <boolean_factor>
 * bnf-end
 *
 */
void boolean_term_S() #BooleanTerm : 
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_term_S()" ) ;
}
{
	//S:
	// <boolean_term> ::=
    //    <boolean_factor>
    //  | <boolean_term> AND <boolean_factor>

	// Refactored to
	// boolean_factor_S() ( <AND> boolean_factor_S() )?
	// which I believe is equivalent to the above
//	try {
		( boolean_factor_S() 
		  ( LOOKAHEAD(3) 
		    <AND> 
		    { tracker.push( compiler.CONDITION_ELEMENT, IntersectionSearchType.type ) ; }
		    boolean_term_S()
		    { tracker.pop() ; } 
		  )? 
		) 
//	}//	catch( ParseException pex ) {//	   errorSkipTo( new int[]{ token.kind }, pex ) ;				//	}	
	{
		if( log.isTraceEnabled() ) exitTrace ( "boolean_term_S()" ) ;
	}
}

/*
 * boolean_factor_S
 *
 * bnf-start
 *   <boolean_factor> ::= [ NOT ] <boolean_primary>
 *   !! ADQL Note:
 *   !! The draft spec supports <boolean_test> and its adjunct <truth value>. 
 *   !! There is some doubt as to whether we should or not.
 *   !! <boolean_test> could be an unwarranted complication.
 *   !! Change the spec.
 * bnf-end
 */
void boolean_factor_S() #BooleanFactor :
{
	if( log.isTraceEnabled() ) enterTrace ( "boolean_factor_S()" ) ;
	Token t = null ;
}
{
	//S:
	// <boolean factor> ::= [ NOT  ] <boolean test>
    // <boolean test> ::= <boolean primary> [ IS  [ NOT  ] <truth value> ]
	// <truth value> ::= TRUE | FALSE  | UNKNOWN
	
//	try {
		( [ t=<NOT> ]
		  { if( t != null ) {
		  	   tracker.push( compiler.CONDITION_ELEMENT, InverseSearchType.type ) ;
		  	   jjtThis.setInverse(true);
		  	} 
		  }
		  boolean_primary_S() 
		)
//	}//	catch( ParseException pex ) {//	    errorSkipTo( new int[]{ token.kind }, pex ) ;		//	}
	{ if( log.isTraceEnabled() ) exitTrace ( "boolean_factor_S()" ) ; }
}


/*
 * like_predicate_A
 *
 * bnf-start
 *  <like_predicate> ::=
 *      <match_value> [ NOT ] LIKE <pattern>
 *  !! For information,
 *  !! The ADQL draft spec has
 *  !! <like_predicate> ::= 
 *  !!   <character_value_expression> [ NOT ] LIKE <character_value_expression>
 *  !! But there is no underlying difference. Just different documentation.
 *  !! Using <match_value> and <pattern> is in line with SQL92.
 * bnf-end
 *
 */
void like_predicate_A() #LikePredicate: 
{
	if( log.isTraceEnabled() ) enterTrace ( "like_predicate_A()" ) ;
	tracker.setType( LikePredType.type ) ;
}
{
	//S: 
	// <like_predicate> ::=
	//   <match_value> [ NOT ] LIKE <pattern> [ ESCAPE <escape_character> ]
      
	( match_value_S() 
	  [ <NOT> { jjtThis.setLike(false);
	            tracker.setType( NotLikePredType.type ) ; } ] 
	    <LIKE> pattern_A() )
	{
		if( log.isTraceEnabled() ) exitTrace ( "like_predicate_A()" ) ;
	}
}

void caseExpression_S() : {}
{
	"5-TBD caseExpression"	
}

void castSpecification_S() : {}
{
	"6-TBD castSpecification"
}

/*
 * character_factor_A
 *
 * bnf-start
 *  <character_factor> ::= <character_primary>
 *  !! For information only, SQL92 supports <collate_clause>
 * bnf-end
 *
 */
void character_factor_A() : {}
{
	//S:
	// <character_factor> ::= <character_primary> [ <collate_clause> ]
	character_primary_A()
}

/*
 * character_primary_A
 *
 * bnf-start
 *  <character_primary> ::= 
 *      <value_expression_primary>
 *    | <user_defined_function>
 *  !! For information, SQL92 has support for <string_value_function>
 * bnf-end
 *
 */
void character_primary_A() : {}
{
	//S:
	//  <character_primary> ::=
    //    <value_expression_primary> | <string_value_function>
    LOOKAHEAD(16)	value_expression_primary_A()	|    user_defined_function_A()
}

/*
 * character_string_literal_A
 *
 * bnf-start
 *  <character_string_literal> ::=
 *     <quote> [ <character_representation>... ] <quote>
 *     [ { <separator>... <quote> [ <character_representation>... ] <quote> }... ]
 * bnf-end
 *
 * bnf-start
 *  <character_representation> ::= 
 *  !! This is one ASCII character (but not a single quote).
 *  !! The ADQL spec supports
 *  !! <character_representation> ::= <nonquote_character> | <quote_symbol>
 *  !! <quote_symbol> ::= <quote> <quote>
 *  !! which follows SQL92.
 *  !! Not sure I understand why the <quote_symbol> is here.
 * bnf-end
 *
 * bnf-single <separator> ::= { <comment> | <space> | <newline> }...
 *
 */
void character_string_literal_A() #CharacterStringLiteral : {}
{
	//S:
	// <character_string_literal> ::=
    //    [ <introducer><character_set_specification> ]
    //    <quote> [ <character_representation>... ] <quote>
    //    [ { <separator>... <quote> [ <character_representGroupingColumnReferenceListation>... ] <quote> }... ]
	ASCIIStringLiteral()
}

void ASCIIStringLiteral() #ASCIIStringLiteral : {}
{
	( ASCIIStringLiteralPart() )+ 
}

void ASCIIStringLiteralPart() #ASCIIStringLiteralPart : {}
{
	<ASCII_STRING_LITERAL>
}

/*
 * character_value_expression_S
 *
 * bnf-start
 *  <character_value_expression> ::= <concatenation> | <character_factor>
 * bnf-end
 *
 * bnf-start
 *  <concatenation> ::= <character_value_expression> <concatenation_operator> <character_factor>
 * bnf-end
 *
 */
void character_value_expression_S() #CharacterValueExpression : 
{
	if( log.isTraceEnabled() ) enterTrace ( "character_value_expression_S()" ) ;
}
{
	//S:
	// <character_value_expression> ::=
    //     <concatenation>
    //   | <character_factor>
    //
    // To avoid left recursion, refactored to the following, which I believe
    // is equivalent...
	character_factor_A() [ concatenation_operator_S() character_value_expression_S() ]
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "character_value_expression_S()" ) ;
	}	
}

/*
 * concatenation_operator_S
 *
 * bnf-single <concatenation_operator> ::= ||
 */
void concatenation_operator_S() : {}
{
	  <VERTICAL_BAR> <VERTICAL_BAR>
}

/*
 * column_name_S
 *
 * bnf-single <column_name> ::= <identifier>
 *
 */
void column_name_S() #ColumnName :  
{
	if( log.isTraceEnabled() ) enterTrace ( "column_name_S()" ) ;
}
{
	//S:
	// <column_name> ::= <identifier>
	identifier_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "column_name_S()" ) ;
	}
}

/*
 * column_name_list_S
 *
 * bnf-single <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
 *
 */
void column_name_list_S() #ColumnNameList : {}
{
	//S:
	// <column_name_list> ::= <column_name> [ { <comma> <column_name> }... ]
	 column_name_S() ( <COMMA> column_name_S() )*	
}

/*
 * column_reference_A
 *
 * bnf-start
 *  <column_reference> ::= [ <qualifier> <period> ] <column_name>
 * bnf-end
 *
 */
void column_reference_A() #ColumnReference : 
{
	if( log.isTraceEnabled() ) enterTrace ( "column_reference_A()" ) ;
	tracker.setType( ColumnReferenceType.type ) ;
}
{
	//S: 
	// <column_reference> ::= [ <qualifier> <period> ] <column_name>
	(
	   [ LOOKAHEAD(4) qualifier_A() <PERIOD> ] column_name_S() 
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "column_reference_A()" ) ;					
	}
}

///*// * aliased_expression_reference_A// *// *-bnf-start// *- <aliased_expression_reference> ::= <identifier>// *- !! ADQL specific. // *- NB. This is simply a reference to an aliased expression.// *-bnf-end// *// *///AliasSelectionItemType aliased_expression_reference_A() ://{//	if( log.isTraceEnabled() ) enterTrace ( "aliased_expression_reference_A()" ) ;//	AliasSelectionItemType asiType = null ;//	String name = null ;//}//{//	////	// Note especially that this is simply a reference to an//	// aliased expression defined elsewhere. At this point we//	// only have the name of the alias, not the content, so we//	// can only construct an empty AliasSelectionItemType.//	// Filling in these must wait until the whole query has//	// been assembled and is thought to be syntactically correct!!!//	name=identifier_A()//	{//		if( name != null ) {//		    asiType = AliasSelectionItemType.Factory.newInstance() ;//			asiType.setAs( name ) ;//		}//	    if( log.isTraceEnabled() ) exitTrace ( "aliased_expression_reference_A()" ) ;		//	    return asiType ;	//	}//}

/*
 * value_expression_primary_A
 *
 * NB: Referred in some sources as <common_primary>
 *
 * bnf-start
 *  <value_expression_primary> ::=
 *      <unsigned_value_specification>
 *    | <column_reference>
 *    | <set_function_specification>
 *    | <left_paren> <value_expression> <right_paren>
 *  !! For information, SQL92 supports <scalar_subquery>,
 *  !! <case_expression> and <cast_specification>
 * bnf-end
 *
 */
void value_expression_primary_A() #ValueExpressionPrimary : 
{
	if( log.isTraceEnabled() ) enterTrace ( "value_expression_primary_A()" ) ;
}
{
	//S:
	//	<value_expression_primary> ::=
	//      <unsigned_value_specification>
	//    | <column_reference>
	//    | <set_function_specification>
	//    | <scalar_subquery>
	//    | <case_expression>
	//    | <left_paren> <value_expression> <right_paren>
	//    | <cast_specification>

	(
		// Foreshortened 
		unsigned_value_specification_S() 
		|
		column_reference_A()
		|
		set_function_specification_S()
		|
	// JBL: no structure available for holding subqueries at this level in adql
	//		LOOKAHEAD(3)
	//		scalarSubquery()
	//	|
	// JBL: case ommitted in initial version...
	//	caseExpression()
	//	| 
		( 
		  <LEFT_PAREN>
		  value_expression_A() 
		  <RIGHT_PAREN> { jjtThis.setParenthesized(); }
		)
	// JBL: cast ommitted in initial version
	//	|
	//	castSpecification()
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "value_expression_primary_A()" ) ;
	}
}

/*
 * comp_op_S
 *
 * bnf-start
 *  <comp_op> ::=
 *      <equals_operator>
 *    | <not_equals_operator>
 *    | <less_than_operator>
 *    | <greater_than_operator>
 *    | <less_than_or_equals_operator>
 *    | <greater_than_or_equals_operator>
 * bnf-end
 *
 */
void comp_op_S() #Comparison : 
{
	if( log.isTraceEnabled() ) enterTrace ( "comp_op_S()" ) ;
}
{
	//S:
	// <comp_op> ::=
    //    <equals_operator>
    //  | <not_equals_operator>
    //  | <less_than_operator>
    //  | <greater_than_operator>
    //  | <less_than_or_equals_operator>
    //  | <greater_than_or_equals_operator>
	(
	   <EQUALS_OPERATOR> 
	   |
	   <NOT_EQUALS_OPERATOR> 
	   |
	   <LESS_THAN_OPERATOR> 
	   | 
	   <GREATER_THEN_OPERATOR> 
	   | 
	   <LESS_THAN_OR_EQUALS_OPERATOR> 
	   | 
	   <GREATER_THAN_OR_EQUALS_OPERATOR>	
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "comp_op_S()" ) ;
	}
}

/*
 * comparison_predicate_A
 *
 * bnf-start
 *  <comparison_predicate> ::=
 *      <value_expression> <comp_op> <value_expression>
 * bnf-end
 *
 */
void comparison_predicate_A() #ComparisonPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "comparison_predicate_A()" ) ;
	tracker.setType( ComparisonPredType.type ) ;
}
{
	//S:
	//  <row_value_constructor> <comp_op> <row_value_constructor>
//	try {		( 
		  { tracker.push( compiler.ARG_ELEMENT ) ; }
		  value_expression_A() 
		  { tracker.pop() ; }
		  comp_op_S() 
		  { tracker.push( compiler.ARG_ELEMENT ) ; }
		  value_expression_A() 
		  { tracker.pop() ; }
		)
//	}//	catch( ParseException pex ) {//		errorSkipTo( new int[]{ token.kind }, pex ) ;//	}
	{ 
	   if( log.isTraceEnabled() ) exitTrace( "comparison_predicate_A()" ) ;	
	}
}

/*
 * correlation_name_S
 *
 * bnf-single <correlation_name> ::= <identifier>
 *
 */
void correlation_name_S() #CorrelationName : 
{
	if( log.isTraceEnabled() ) enterTrace ( "correlation_name_S()" ) ;
}
{
	//S:
	// <correlation_name> ::= <identifier>
	try {
	   identifier_A()
	}
	catch( ParseException pex ) {
		compiler.errorSkipTo( new int[]{ token.kind }, pex ) ;	
	}
	
	{ if( log.isTraceEnabled() ) exitTrace ( "correlation_name_S()" ) ; }
}

void datetime_factor_S() : {}
{
	//S:
	//  <datetime_factor> ::=
    //     <datetime_primary> [ <time_zone> ]
    
	datetime_primary_S() [  LOOKAHEAD(2) time_zone_S() ]
}

void datetime_primary_S() : {}
{
	//S:
	// <datetime_primary> ::=
    //    <value_expression_primary>
    //  | <datetime_value_function>

	value_expression_primary_A()
    | 
    datetime_value_function_S()
}

void datetime_term_S() : {}
{
	//S:
	// <datetime_term> ::= <datetime_factor>
    datetime_factor_S()
}

void datetime_value_expression_S() : {}
{
	//S:
	// <datetime_value_expression> ::=
    //    <datetime_term>
    //  | <interval_value_expression> <plus_sign> <datetime_term>
    //  | <datetime_value_expression> <plus_sign> <interval_term>
    //  | <datetime_value_expression> <minus_sign> <interval_term>

	// refactored to
	LOOKAHEAD(3)
    ( datetime_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) datetime_value_expression_S() )* )
    |
    ( interval_value_expression_S() <PLUS_SIGN> datetime_term_S() )
}

void datetime_value_function_S() : {}
{
	//S:
	// <datetime_value_function> ::=
    //    <current_date_value_function>
    //  | <current_time_value_function>
    //  | <current_timestamp_value_function>

	<CURRENT_DATE>
	|
	<CURRENT_TIME> [ <LEFT_PAREN> time_precision_S() <RIGHT_PAREN> ]
	|
	<CURRENT_TIMESTAMP> [ <LEFT_PAREN> timestamp_precision_S() <RIGHT_PAREN> ]
}

void derived_table_S() : {}
{
	//S:
	// <derived_table> ::= <table_subquery>
   	table_subquery_A()
}

void end_field_S() : {}
{
	//S:
	// <end_field> ::=
    //    <non-second_datetime_field>
    //  | SECOND [ <left_paren> <interval_fractional_seconds_precision> <right_paren> ]
	nonsecond_datetime_field_S() | <SECOND> [ <LEFT_PAREN> interval_fractional_seconds_precision_S() <RIGHT_PAREN> ]
}

void escape_character_A() : {}
{
	//S:
	// <escape_character> ::= <character_value_expression>
	character_value_expression_S()	
}

/*
 * exact_numeric_literal_S
 *
 * bnf-start
 *  <exact_numeric_literal> ::=
 *      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]
 *    | <period> <unsigned_integer>
 * bnf-end
 *
 */
void exact_numeric_literal_S( int signIndicator ) #ExactNumericLiteral :
{
	if( log.isTraceEnabled() ) enterTrace ( "exact_numeric_literal_S()" ) ;
	jjtThis.setSign( signIndicator ) ;
	Token t ;
	//tracker.setType( AtomType.type ) ;
}
{
	//S:
	//  <exact_numeric_literal> ::=    //      <unsigned_integer> [ <period> [ <unsigned_integer> ] ]    //    | <period> <unsigned_integer>
    
    // NB: The repeat check below for <UNSIGNED_INTEGER>!
    // Not sure whether there is a better way of doing this...
    // <EXACT_NUMERIC_LITERAL> and <UNSIGNED_INTEGER> compete
    // with each other as tokens. Where only an unsigned integer
    // is used, they both represent the same thing (!), and the token
    // manager chooses unsigned integer (probably because it happens
    // to be before exact numeric literal in the token list)!
    //
    // This is probably worthy of study to see whether a more
    // stable way of doing this is possible.
//    try {
		( t=<EXACT_NUMERIC_LITERAL> | t=<UNSIGNED_INTEGER> )
		{ 
			if( t != null ) {
				if( log.isDebugEnabled() ) {
					log.debug( "Token encountered: kind [" + t.kind + "] with image [" + t.image + "]" ) ;
				}
			}
			if( log.isTraceEnabled() ) exitTrace ( "exact_numeric_literal_S()" ) ; 
		}
//    }//    catch( ParseException pex ) {//    	log.debug( "exact_numeric_literal_S complained, token.image: " + token.image ) ;//    	throw pex ;//    }
}


/*
 * exists_predicate_A
 *
 * bnf-single <exists_predicate> ::= EXISTS <table_subquery>
 *
 */
void exists_predicate_A() #ExistsPredicate : 
{
    if( log.isTraceEnabled() ) enterTrace ( "exists_predicate_A()" ) ;
    tracker.setType( ExistsPredType.type ) ;
}
{
	//S: 
	// <exists_predicate> ::= EXISTS <table_subquery>
	<EXISTS> table_subquery_A()
	{ 
	   if( log.isTraceEnabled() ) exitTrace ( "exists_predicate_A()" ) ;		
	}	
}


void explicit_table_S() : {}
{
	//S:
	// <explicit_table> ::= TABLE <table_name>
	<TABLE> table_name_A()
}

/*
 * factor_S
 *
 * bnf-single <factor> ::= [ <sign> ] <numeric_primary> 
 *
 */
void factor_S() #Factor : 
{
	if( log.isTraceEnabled() ) enterTrace ( "factor_S()" ) ;
	Token t = null ;
}
{
	//S:
	// <factor> ::= [ <sign> ] <numeric_primary>  
	( 
	  [
	    t=sign_S() 
	    {  if( t!=null ) {
	    	  jjtThis.setSign(t) ;
	       }
	    } 
	  ] 
	  numeric_primary_S() 
	)
	{ 
	   if( log.isTraceEnabled() ) exitTrace ( "factor_S()" ) ;
	}
}

/*
 * sign_S
 *
 * bnf-single <sign> ::= <plus_sign> | <minus_sign>
 *
 */
Token sign_S() #Sign : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sign_S()" ) ;
    Token t = null ;
}
{
	( t=<PLUS_SIGN> | t=<MINUS_SIGN> )
	{ 
	   log.debug( "sign: " + t.image ) ;
	   if( log.isTraceEnabled() ) exitTrace ( "sign_S()" ) ;
	   return t ;
	}
}

/*
 * from_clause_S
 *
 * bnf-start
 *  <from_clause> ::= FROM <table_reference>
 *     [ { <comma> <table_reference> }... ]
 * bnf-end
 *
 */
void from_clause_S() #From : 
{
    if( log.isTraceEnabled() ) enterTrace ( "from_clause_S()" ) ;
    tracker.push( compiler.FROM_ELEMENT, FromType.type ) ;
}
{
	//S:
	// FROM <table_reference>
    // [ { <comma> <table_reference> }... ]
	try {		
	   (  <FROM> table_reference_A() ( <COMMA> table_reference_A() )*  )
	}
	catch( ParseException pex ) {		compiler.errorSkipTo( compiler.FROM_SKIP_TO, pex ) ;
	}
	finally {
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "from_clause_S()" ) ;
	}

}


/*
 * general_literal_A
 *
 * bnf-start
 *  <general_literal> ::= <character_string_literal>
 *  !! ADQL Note:
 *  !! Not present in the draft spec.
 *  !! For information, SQL92 has <general_literal>, and also supports
 *  !! <national_character_string_literal>, <bit_string_literal>, 
 *  !! <hex_string_literal>, <datetime_literal> and <interval_literal>
 *  !! Is it good to retain it as a place-holder, bearing in mind
 *  !! that we might need <bit_string_literal> and <hex_string_literal>
 *  !! at some point in the future?
 * bnf-end
 *
 */
void general_literal_A() : {}
{
	//S:
	//  <general_literal> ::=
    //    <character_string_literal>
    //  | <national_character_string_literal>
    //  | <bit_string_literal>
    //  | <hex_string_literal>
    //  | <datetime_literal>
    //  | <interval_literal>
	character_string_literal_A()	
}

/*
 * general_set_function_A
 *
 * bnf-start
 *  <general_set_function> ::=
 *     <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>
 * bnf-end
 *
 * bnf-single <set_function_type> ::= AVG | MAX | MIN | SUM | COUNT
 *
 */
void general_set_function_A() #GeneralSetFunction : 
{  tracker.setType( AggregateFunctionType.type ) ; }
{
	//S:
	// <general_set_function> ::=
    //   <set_function_type> <left_paren> [ <set_quantifier> ] <value_expression> <right_paren>

	// JBL. setQuantifier removed for the moment. Need to talk to Kona about this.
	// ( <AVG> | <MAX> | <MIN> | <SUM> | <COUNT> ) <LEFT_PAREN> [ setQuantifier() ] value_expression_A() <RIGHT_PAREN>	
	( <AVG> | <MAX> | <MIN> | <SUM> | <COUNT> ) 
	<LEFT_PAREN>
	   [  set_quantifier_S()  ]
	   { tracker.push( compiler.ARG_ELEMENT ) ; } 
	   value_expression_A() 
	   { tracker.pop() ; }
	<RIGHT_PAREN>
}

/*
 * general_value_specification_A
 *
 * bnf-start
 *  <general_value_specification> ::= <variable_specification>
 *  !! ADQL Note:
 *  !! Missing from the ADQL draft spec.
 *  !! Part of an experiment to see if scripting variables can be accommodated.
 *  !! SQL92 also supports <parameter_specification>, <dynamic_parameter_specification>,
 *  !! USER, CURRENT_USER, SESSION_USER, SYSTEM_USER and VALUE
 * bnf-end
 *
 */
void general_value_specification_A() : {}
{
	//S:
	//<general_value_specification> ::=
    //   <parameter_specification>
    // | <dynamic_parameter_specification>
    // | <variable_specification>
    // | USER
    // | CURRENT_USER
    // | SESSION_USER
    // | SYSTEM_USER
    // | VALUE
	
	// Foreshortened
	variable_specification_A()
}

/*
 * group_by_clause_S
 *
 * bnf-start
 *  <group_by_clause> ::= GROUP BY <grouping_column_reference_list>
 * bnf-end
 *
 */
void group_by_clause_S() #GroupBy : 
{
	if( log.isTraceEnabled() ) enterTrace ( "group_by_clause_S()" ) ;
	tracker.push( compiler.GROUPBY_ELEMENT, GroupByType.type ) ; 
}
{
	//S:
	// GROUP BY <grouping_column_reference_list>
	( <GROUPBY> grouping_column_reference_list_S() )
	{
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "group_by_clause_S()" ) ;
	}
}

/*
 * grouping_column_reference_list_S
 *
 * bnf-start
 *  <grouping_column_reference_list> ::=
 *      <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
 * bnf-end
 *
 */
void grouping_column_reference_list_S() #GroupingColumnReferenceList : 
{
    if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_list_S()" ) ;
}
{
	//S:
	// <grouping_column_reference_list> ::=
    //   <grouping_column_reference> [ { <comma> <grouping_column_reference> }... ]
	( grouping_column_reference_A() ( <COMMA> grouping_column_reference_A() )* ) 
	{
		if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_list_S()" ) ;
	}
}

/*
 * grouping_column_reference_A
 *
 * bnf-start
 *  <grouping_column_reference> ::= <column_reference> 
 *  !! For information, SQL92 supports a <collate_clause>
 * bnf-end
 *
 */
void grouping_column_reference_A() : 
{
    if( log.isTraceEnabled() ) enterTrace ( "grouping_column_reference_A()" ) ;
}
{
    //S:
    // <grouping_column_reference> ::=
    //      <column_reference> [ <collate_clause> ]
	column_reference_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "grouping_column_reference_A()" ) ;
	}	
}

/*
 * having_clause_S
 *
 * bnf-single <having_clause> ::= HAVING <search_condition>	
 *
 */
void having_clause_S() #Having :
{
	if( log.isTraceEnabled() ) enterTrace ( "having_clause_S()" ) ;
	tracker.push( compiler.HAVING_ELEMENT, HavingType.type ) ;
}
{	
	//S:
	//  HAVING <search_condition>	
	( <HAVING> search_condition_S() )
	{	
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "having_clause_S()" ) ;	
	}
}

/*
 * identifier_A
 *
 * For the moment, <identifier> is a synonym for <actual_identifier>
 *
 */
void identifier_A() : {}
{
	//S:
	// <identifier> ::=
    //   [ <introducer><character_set_specification> ] <actual_identifier>
	actual_identifier_S()
} 

/*
 * in_predicate_A
 *
 * bnf-start
 *  <in_predicate> ::=
 *      <value_expression> [ NOT ] IN <in_predicate_value>
 * bnf-end
 *
 */
void in_predicate_A() #InPredicate : 
{
	if( log.isTraceEnabled() ) enterTrace ( "in_predicate_A()" ) ;
}
{
	//S:
	// <in_predicate> ::=
    //   <row_value_constructor> [ NOT ] IN <in_predicate_value>
    
	// refactored to
	( 
	  value_expression_A() [ <NOT> {jjtThis.setIn(false);} ] <IN> in_predicate_value_S()
	)
    {
       if( log.isTraceEnabled() ) exitTrace ( "in_predicate_A()" ) ;	
	}
}

/*
 * in_predicate_value_S
 *
 * bnf-start
 *  <in_predicate_value> ::=
 *     <table_subquery> | <left_paren> <in_value_list> <right_paren>
 * bnf-end
 *
 */
void in_predicate_value_S() #InPredicateValue : 
{
	if( log.isTraceEnabled() ) enterTrace ( "in_predicate_value_S()" ) ;
}
{
	//S:
    // <in_predicate_value> ::= <table_subquery>  | <left_paren> <in_value_list> <right_paren>
	
	( LOOKAHEAD(2) table_subquery_A() | ( <LEFT_PAREN> in_value_list_A() <RIGHT_PAREN> ) )
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "in_predicate_value_S()" ) ;
	} 	
}

void interval_factor_S() : {}
{
	//S:
	// <interval_factor> ::=
    //   [ <sign> ] <interval_primary>

    [ <PLUS_SIGN> | <MINUS_SIGN> ] interval_primary_S()
}

void interval_fractional_seconds_precision_S() : {}
{
	//S:
	// <interval_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_leading_field_precision_S() : {}
{
	//S:
	// <interval_leading_field_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER>	
}

void interval_primary_S() : {}
{
	//S:
	// <interval_primary> ::=
    //    <value_expression_primary> [ <interval_qualifier> ]

      value_expression_primary_A() [ LOOKAHEAD(2) interval_qualifier_S() ]
}

void interval_qualifier_S() : {}
{
	//S:
	// <interval_qualifier> ::=
    //    <start_field> TO <end_field> | <single_datetime_field>

	LOOKAHEAD(3)
    start_field_S() <TO> end_field_S()
    | 
    single_datetime_field_S()
}

void interval_term_S() : {}
{
	//S:
	// <interval_term> ::=
    //    <interval_factor>
    //  | <interval_term_2> <asterisk> <factor>
    //  | <interval_term_2> <solidus> <factor>
    //  | <term> <asterisk> <interval_factor>

	// refactored...
	LOOKAHEAD(3)
	interval_factor_S() 
    |
	LOOKAHEAD(3)    
    factor_S() (<ASTERISK> | <SOLIDUS>) interval_term_S()
    | 
    term_S() <ASTERISK> interval_factor_S()
}

void interval_value_expression_S() : {}
{
	//S:
	// <interval_value_expression> ::=
    //    <interval_term>
    //  | <interval_value_expression_1> <plus_sign> <interval_term_1>
    //  | <interval_value_expression_1> <minus_sign> <interval_term_1>
    //  | <left_paren> <datetime_value_expression> <minus_sign>
    //      <datetime_term> <right_paren> <interval_qualifier>

	// refactored
	LOOKAHEAD(3)
	interval_term_S() ( LOOKAHEAD(2) (<PLUS_SIGN> | <MINUS_SIGN>) interval_term_S() )*
    | 
    <LEFT_PAREN> datetime_value_expression_S() <MINUS_SIGN> datetime_term_S() <RIGHT_PAREN> interval_qualifier_S()
}

/*
 * in_value_list_A
 *
 * bnf-start
 *  <in_value_list> ::=
 *      <value_expression> { <comma> <value_expression> } ...
 * bnf-end
 *
 */
void in_value_list_A() #InValueList : {}
{
	//S:
	// <in_value_list> ::=
    //   <value_expression> { <comma> <value_expression> }...    
    ( value_expression_A() ( <COMMA> value_expression_A() )* )
}

///*// * in_value_list_constant_A// *// *-bnf-start// *- <in_value_list_constant> ::=// *-       [ <plus_sign> | <minus_sign> ] <exact_numeric_literal>// *-    |  <character_string_literal> // *-bnf-end// *// *///void in_value_list_constant_A() #InValueListConstant : //{//	int signChange = +1 ;//	Token t = null ;//}//{//	//A://	// <in_value_list_constant_A> ::=//	//      [ <plus> | <minus> ] <exact_numeric_literal_S>//	//      |//	//      <character_string_literal_A> //	(//	  (//	    ( [ (<PLUS_SIGN> | t=<MINUS_SIGN>) {if(t != null) signChange = -1 ;} ] ) exact_numeric_literal_S( signChange ) //	  )//	  |//	  character_string_literal_A()//	)//}

/*
 * join_specification_S
 *
 * bnf-start
 *  <join_specification> ::= <join_condition> | <named_columns_join>	
 * bnf-end
 *
 */
void join_specification_S() #JoinSpecification : {}
{
	//S:
	// <join_specification> ::=
    //    <join_condition>
    //  | <named_columns_join>	
    //
    // <join_condition> ::= ON <search_condition>
    //
    // <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren>
    //
    // <join_column_list> ::= <column_name_list>
    
    join_condition_S() | named_columns_join_S()
}

/*
 * join_condition_S
 *
 * bnf-single <join_condition> ::= ON <search_condition>
 *
 */
void join_condition_S() #JoinCondition : 
{
    if( log.isTraceEnabled() ) enterTrace ( "join_condition_S()" ) ;
}
{
	<ON> search_condition_S()
	{
		if( log.isTraceEnabled() ) exitTrace ( "join_condition_S()" ) ;
	}
} 

/*
 * named_columns_join_S
 *
 * bnf-single <named_columns_join> ::= USING <left_paren> <join_column_list> <right_paren> 
 *
 */
void named_columns_join_S() #NamedColumnsJoin :
{
	if( log.isTraceEnabled() ) enterTrace ( "named_columns_join_S()" ) ;
}
{
	<USING> <LEFT_PAREN> join_column_list_S() <RIGHT_PAREN>
	{
		if( log.isTraceEnabled() ) exitTrace ( "named_columns_join_S()" ) ;
	}
}

/*
 * join_column_list_S
 *
 * bnf-single <join_column_list> ::= <column_name_list>
 *
 */
void join_column_list_S() : {}
{	
	column_name_list_S()
}


/*
 * joined_table_S
 *
 * bnf-start
 *  <joined_table> ::=
 *      <qualified_join>
 *    | <left_paren> <joined_table> <right_paren>
 * bnf-end
 *
 */
void joined_table_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "joined_table_S()" ) ;
}
{
	//S:
	// <joined_table> ::=
    //    <cross_join>
    //  | <qualified_join>
    //  | <left_paren> <joined_table> <right_paren>
	(
// 
//		LOOKAHEAD(4)//		cross_join_S()//		|
		LOOKAHEAD(4)
		qualified_join_S()
		|
		( <LEFT_PAREN> joined_table_S() <RIGHT_PAREN> )
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "joined_table_S()" ) ;
	}
}

/*
 * join_type_A
 *
 * bnf-start
 *  <join_type> ::=
 *     INNER
 *   | <outer_join_type> [ OUTER ]
 *  !! For information, SQL92 also supports UNION
 * bnf-end
 *
 * bnf-single <outer_join_type> ::= LEFT | RIGHT | FULL
 *
 */
void join_type_A() #JoinType : {}
{
	//S:
	// <join_type> ::=
    //    INNER
    //  | <outer_join_type> [ OUTER ]
    //  | UNION

		// refactored to...
		(
		   <INNER>
	       | 
	       ( ( <LEFT> | <RIGHT> | <FULL> ) [ <OUTER> ] )
// JL. Adql does not appear to support UNION
//	       | 
//	       <UNION>
        )
}

/*
 * match_value_S
 *
 * bnf-single <match_value> ::= <character_value_expression>
 *
 */
void match_value_S() #MatchValue : 
{
    if( log.isTraceEnabled() ) enterTrace ( "match_value_S()" ) ;
}
{
	//S:
	// <match_value> ::= <character_value_expression>

	character_value_expression_S()
	{
	   if( log.isTraceEnabled() ) exitTrace ( "match_value_S()" ) ;
	}	
}

void match_predicate_S() : {}
{
	//S:
	// <match_predicate> ::=
    //   <row_value_constructor> MATCH [ UNIQUE ] [ PARTIAL | FULL ] <table_subquery>

	row_value_constructor_S() <MATCH> [ <UNIQUE> ] [ <PARTIAL> | <FULL> ] table_subquery_A() 
}

/*
 * math_function_A
 *
 * bnf-start
 *  <math_function> ::=
 *      ABS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | CEILING <left_paren> <numeric_value_expression> <right_paren> 
 *	  | DEGREES <left_paren> <numeric_value_expression> <right_paren> 
 *	  | EXP <left_paren> <numeric_value_expression> <right_paren> 
 *	  | FLOOR <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG <left_paren> <numeric_value_expression> <right_paren> 
 *	  | PI <left_paren><right_paren> 
 *	  | POWER <left_paren> <numeric_value_expression> <comma> <unsigned_integer> <right_paren> 
 *	  | RADIANS <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQUARE <left_paren> <numeric_value_expression> <right_paren> 
 *	  | SQRT <left_paren> <numeric_value_expression> <right_paren> 
 *	  | LOG10 <left_paren> <numeric_value_expression> <right_paren> 
 *	  | RAND <left_paren> [ <numeric_value_expression> ] <right_paren> 
 *	  | ROUND <left_paren> <numeric_value_expression> <right_paren> 
 *	  | TRUNCATE <left_paren> <numeric_value_expression> <right_paren> 
 * bnf-end
 *
 */
void math_function_A() #MathFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "math_function_A()" ) ;
    Token arg2 = null ;
    tracker.setType( MathFunctionType.type ) ;
}
{
	(
		( <ABS> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } 
		        numeric_value_expression_S() 
		        { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <CEILING> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <DEGREES> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <EXP> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <FLOOR> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <LOG> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <PI> 
		     <LEFT_PAREN><RIGHT_PAREN> )
		|
		( <POWER> 
		     <LEFT_PAREN> 
                { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <COMMA> 
		        arg2=<UNSIGNED_INTEGER> {jjtThis.setArg2(new Long(arg2.image));} 
		     <RIGHT_PAREN> )
		|
		( <RADIANS> 
		     <LEFT_PAREN> 
                { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		     <RIGHT_PAREN> )
		|
		( <SQUARE> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <SQRT> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <LOG10> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <RAND> 
		     <LEFT_PAREN> 
		         [ { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } ] 
		     <RIGHT_PAREN> )
		|
		( <ROUND> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
		|
		( <TRUNCATE> 
		     <LEFT_PAREN> 
		        { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		     <RIGHT_PAREN> )
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "math_function_A()" ) ;
	}
}

/*
 * null_predicate_A
 *
 * bnf-start
 *  <null_predicate> ::= <column_reference> IS [ NOT ] NULL
 *  !! ADQL Note:
 *  !! The draft spec is in error here. It has
 *  !! <null_predicate> ::= IS [ NOT ] NULL	
 * bnf-end
 *
 */
void null_predicate_A() #NullPredicate : 
{
	   if( log.isTraceEnabled() ) enterTrace ( "null_predicate_A()" ) ;	   
}
{
	//S:
	// <null_predicate> ::= 
	//   <row_value_constructor> IS [ NOT ] NULL

	column_reference_A() <IS> [ <NOT> {jjtThis.setNullPredicate(false);} ] <NULL>	
	
	{
	   if( log.isTraceEnabled() ) exitTrace ( "null_predicate_A()" ) ;
	}
}

/*
 * numeric_primary_S
 *
 * bnf-start
 *  <numeric_primary> ::=
 *      <value_expression_primary>
 *    | <numeric_value_function>
 * bnf-end
 *
 */
void numeric_primary_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_primary_S()" ) ;
}
{
	//S:
	// <numeric_primary> ::=
    //    <value_expression_primary>
    //  | <numeric_value_function>
    
    // Refactored to...
	( 
	  LOOKAHEAD(3)
	  numeric_value_function_A()	
	  |
	  value_expression_primary_A()
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "numeric_primary_S()" ) ;
	} 
	
}

/*
 * numeric_value_expression_S
 *
 * bnf-start
 *  <numeric_value_expression> ::=
 *      <term>
 *    | <numeric_value_expression> <plus_sign> <term>
 *    | <numeric_value_expression> <minus_sign> <term>
 * bnf-end
 *
 */
void numeric_value_expression_S() #NumericValueExpression : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_value_expression_S()" ) ;
	Token t = null ;
}
{
	//S:
	// <numeric_value_expression> ::=
    //    <term>
    //  | <numeric_value_expression> <plus_sign> <term>
    //  | <numeric_value_expression> <minus_sign> <term>
	
	// refactored to...
	( term_S() 
	  ( 
	     LOOKAHEAD(3) 
	     ( 
	        ( t=<PLUS_SIGN> | t=<MINUS_SIGN> ) 
	        { 
	           if( t!=null ) {
	           	  jjtThis.setOperator(t);
	           }
	        } 
	     ) numeric_value_expression_S() )? 
	)
    {
        if( log.isTraceEnabled() ) exitTrace ( "numeric_value_expression_S()" ) ;		
	}
}

/*
 * numeric_value_function_A
 *
 * bnf-start
 *  <numeric_value_function> ::= 
 *     <trig_function> 
 *   | <math_function>	
 *   | <user_defined_function>
 *  !! For information, SQ92 also supports <position_expression>,
 *  !! <extract_expression> and <length_expression>
 * bnf-end
 *
 */
void numeric_value_function_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "numeric_value_function_A()" ) ;
}
{
	//S:
	//<numeric_value_function> ::=
    //   <position_expression>
    // | <extract_expression>
    // | <length_expression>

	(
		// JBL ADQL adaptation
		trig_function_A()
		|
		math_function_A()	
	    |	    user_defined_function_A()
		
	)
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "numeric_value_function_A()" ) ;	
	}
}

/*
 * user_defined_function_A
 *
 * bnf-start
 *  <user_defined_function> ::=
 *      <user_defined_function_name> 
 *          <left_paren> 
 *              [ <numeric_value_expression> [ { <comma> <numeric_value_expression> }... ] ]
 *          <right_paren> 
 *  !! ADQL Note:
 *  !! This is an experiment. Not currently present in the draft spec.
 *  !! If metadata on a user defined function is available, this should be used.
 *  !! For example, function names and cardinality of arguments should be checked.
 * bnf-end
 *
 * bnf-start
 *   <user_defined_function_name> ::=
 *       [ <default_function_prefix> ] <regular_identifier>
 *   !! Function names should be checked against metadata where available. 
 * bnf-end 
 *
 * bnf-start
 *   <default_function_prefix> ::=
 *   !! The prefix is set by default to "udf_".
 *   !! It should be possible to change the default prefix to accommodate local preferences.
 * bnf-end
 *
 */
void user_defined_function_A() #UserDefinedFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "user_defined_function_A()" ) ;
	tracker.setType( UserDefinedFunctionType.type ) ;
	Token t = null ;
}
{
	(
		( t=<REGULAR_IDENTIFIER>
		     <LEFT_PAREN> 
		     [
                { tracker.push( compiler.ARG_ELEMENT ) ; } value_expression_A() { tracker.pop() ; }
                ( <COMMA> 
                  { tracker.push( compiler.ARG_ELEMENT ) ; } value_expression_A() { tracker.pop() ; } )* 
             ]	       
		     <RIGHT_PAREN> 
		     { if(t!=null) {
		          jjtThis.setFunctionName( t.image ) ;
		       }
		     }
		)
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "user_defined_function_A()" ) ;
	}
}


/*
 * order_by_clause
 *
 * bnf-start
 *  <order_by_clause> ::= ORDER BY <sort_specification_list>
 * bnf-end
 *
 */
void order_by_clause_S() #OrderByClause :
 //	public static final String ORDERBY_ELEMENT = "OrderBy" ;
{ 
	if( log.isTraceEnabled() ) enterTrace ( "order_by_clause_S()" ) ;
	tracker.push( compiler.ORDERBY_ELEMENT ) ; 
} 
{
	//S:
	//	ORDER BY <sort_specification_list>
	//
	( <ORDERBY> sort_specification_list() )
	{ 
	  tracker.pop() ; 
	  if( log.isTraceEnabled() ) exitTrace ( "order_by_clause_S()" ) ;
	}
}

/*
 * sort_specification_list
 *
 * bnf-start
 *  <sort_specification_list> ::=
 *      <sort_specification> [ { <comma> <sort_specification> }... ]
 * bnf-end 
 *
 */
void sort_specification_list() #SortSpecificationList : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sort_specification_list()" ) ;
} 
{
	//S:
	// <sort_specification_list> ::=
	//    <sort_specification> [ { <comma> <sort_specification> }... ]
	
	// refactored to...
	( sort_specification_A() ( <COMMA> sort_specification_A() )* )
	
	{
		if( log.isTraceEnabled() ) exitTrace ( "sort_specification_list()" ) ;	
	}
}

/*
 * sort_specification_A
 *
 * bnf-start
 *  <sort_specification> ::=
 *      <sort_key> [ <ordering_specification> ]
 *  !! For information, SQL92 also supports <collate_clause>
 * bnf-end
 * 
 */
void sort_specification_A() #SortSpecification : 
{
    if( log.isTraceEnabled() ) enterTrace ( "sort_specification_A()" ) ;
}
{
	( sort_key_S() [ ordering_specification_S() ] )
	
	{
		if( log.isTraceEnabled() ) exitTrace ( "sort_specification_A()" ) ;
	}
}

/*
 * sort_key_S
 *
 * bnf-single <sort_key> ::= <column_name> | <unsigned_integer> 
 *
 */
void sort_key_S() #SortKey : 
{
	if( log.isTraceEnabled() ) enterTrace ( "sort_key_S()" ) ;
}
{
	//S:
	// <sort_key> ::= <column_name> | <unsigned_integer> 
	column_name_S() | <UNSIGNED_INTEGER>
	{
		if( log.isTraceEnabled() ) exitTrace ( "sort_key_S()" ) ;
	}
}

/*
 * ordering_specification_S
 * 
 * bnf-single <ordering_specification> ::= ASC | DESC
 */
void ordering_specification_S() #OrderingSpecification : 
{
    if( log.isTraceEnabled() ) enterTrace ( "ordering_specification_S()" ) ;
}
{
	( <ASC> | <DESC> )
	{
		if( log.isTraceEnabled() ) exitTrace ( "ordering_specification_S()" ) ;
	}
}

void overlaps_predicate_S() : {}
{
	//S:
	// <overlaps_predicate> ::=
    //   <row_value_constructor_1> OVERLAPS <row_value_constructor_2>
    //
    // <row_value_constructor_1> ::= <row_value_constructor>
    // <row_value_constructor_2> ::= <row_value_constructor>

	row_value_constructor_S() <OVERLAPS> row_value_constructor_S()	
}

/*
 * pattern_A
 *
 * bnf-start
 *  <pattern> ::= <character_value_expression>
 * bnf-end
 *
 */
void pattern_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "pattern_A()" ) ;
}
{
	//S:
	//   <pattern> ::= <character_value_expression>
	// character_string_literal_A()
	character_value_expression_S()
	{
		if( log.isTraceEnabled() ) exitTrace ( "pattern_A()" ) ;
	}	
}

/*
 * predicate_A
 *
 * bnf-start
 *  <predicate> ::=
 *     <comparison_predicate>
 *   | <between_predicate>
 *   | <in_predicate>
 *   | <like_predicate>
 *   | <null_predicate>
 *   | <exists_predicate>
 *   | <region_predicate>
 *  !! For information, SQL92 also supports the following predicates: 
 *  !! <quantified_comparison_predicate>, <unique_predicate>, 
 *  !! <match_predicate> and <overlaps_predicate>
 * bnf-end
 *
 */
void predicate_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "predicate_A()" ) ;
	tracker.push( compiler.CONDITION_ELEMENT ) ;
}
{
	//S:
	//    <comparison_predicate>
	//    | <between_predicate>
	//    | <in_predicate>
	//    | <like_predicate>
	//    | <null_predicate>
	//    | <quantified_comparison_predicate>
	//    | <exists_predicate>
	//    | <unique_predicate>
	//    | <match_predicate>
	//    | <overlaps_predicate>
//	try {
		  (
	
	// NB: Possible site of some specialized processing to make the
	//     lookahead more efficient (and of greater range!!!)
	//     LOOKAHEAD(2147483647)
 		    LOOKAHEAD(2147483647)
			comparison_predicate_A()
		    | 
		    LOOKAHEAD(2147483647)
		    between_predicate_A()
		    |
		    LOOKAHEAD(2147483647)
		    in_predicate_A()
		    |
		    LOOKAHEAD(2147483647) 
		    like_predicate_A()
		    | 
		    LOOKAHEAD(2147483647)
		    null_predicate_A()
		    | 
	// adql does not support quantified comparisons
	//	    LOOKAHEAD(3)
	//		quantifiedComparisonPredicate()
	//	    |
	        LOOKAHEAD(2147483647) 
		    exists_predicate_A()
	//	    | 
	// adql does not support UNIQUE
	//	    uniquePredicate()
	//	    | 
	// adql does not support match
	//	    LOOKAHEAD(3)
	//	    matchPredicate()
	//	    | 
	// adql does not support overlap
	//	    overlapsPredicate()
	//    	
			|	
			region_predicate_A()    
	        
	    )
//	}//	catch( ParseException pex ) {//	    errorSkipTo( new int[] { token.kind }, pex ) ;	//	}
    { 
    	tracker.pop() ;
    	if( log.isTraceEnabled() ) exitTrace ( "predicate_A()" ) ;
    }
}


/*
 * region_predicate_A
 *
 * bnf-start
 *  <region_predicate> ::=
 *    <point> [ NOT ] IN <region_specification>
 *  !! ADQL Note:
 *  !! The draft spec has the following...
 *  !! <region_predicate> ::= 
 *  !!   <table_reference> <period> REGION 
 *  !!   <left_paren> 
 *  !!   <region_specification>
 *  !!   [ <comma> <column_reference> [ { <comma> <column_reference> }... ] ]
 *  !!   <right_paren>
 *  !! <region_specification> ::= 
 *  !! Region definition from STC schema here
 * bnf-end
 *
 */
void region_predicate_A() #RegionPredicate :      
{
	if( log.isTraceEnabled() ) enterTrace ( "region_predicate_A()" ) ;
	tracker.setType( RegionSearchType.type ) ;
}
{
	point_A() 
	[ <NOT> { jjtThis.setIn(false);
	          tracker.setType( NotInRegionSearchType.type ) ; } ] 
	<IN> region_specification_A()	
    {
    	if( log.isTraceEnabled() ) exitTrace ( "region_predicate_A()" ) ;	
    }
} 


/*
 * point_A
 *
 * bnf-start
 *  <point> ::= 
 *    <point_J2000> | <point_LATLON> | <point_CARTESIAN>
 * bnf-end
 *
 * bnf-start
 *  <point_J2000> ::= <left_paren> <ra> <comma> <dec> <right_paren>
 * bnf-end
 
 * bnf-start
 *  <point_LATLON> ::= <left_paren> <latitude> <comma> <longitude> <right_paren>
 * bnf-end
 *
 * bnf-start
 *  <point_CARTESIAN> ::= <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren>
 * bnf-end
 *
 * bnf-single <ra> ::= <numeric_value_expression>
 * bnf-single <dec> ::= <numeric_value_expression>
 * bnf-single <latitude> ::= <numeric_value_expression>
 * bnf-single <longitude> ::= <numeric_value_expression>
 * bnf-single <x_coord> ::= <numeric_value_expression>
 * bnf-single <y_coord> ::= <numeric_value_expression>
 * bnf-single <z_coord> ::= <numeric_value_expression>
 *
 */
void point_A() #Point : 
{
	if( log.isTraceEnabled() ) enterTrace ( "point_A()" ) ;
	tracker.push( compiler.POINT_ELEMENT, PointType.type  ) ;
}
{
	<LEFT_PAREN> numeric_value_expression_S() 
	     <COMMA> numeric_value_expression_S() 
	   [ <COMMA> numeric_value_expression_S() ] 
	<RIGHT_PAREN>
	{
	   tracker.pop() ;
	   if( log.isTraceEnabled() ) exitTrace ( "point_A()" ) ;	
	}	
}

/*
 * region_specification_A
 *
 * bnf-start
 *  <region_specification> ::=
 *     <box>
 *   | <circle>
 *   | <convex_hull>
 *   | <convex>
 *   | <polygon>
 * bnf-end
 *
 */
void region_specification_A() : 
{
    if( log.isTraceEnabled() ) enterTrace ( "region_specification_A()" ) ;
    tracker.push( compiler.REGION_ELEMENT ) ;
}
{
	(
		( <CONVEX> convex_A() )
		|
		( <BOX> box_A() )
		|
		( <CIRCLE> circle_A() )
		|
		( <POLY> polygon_A() )
		|
		( <CHULL> convex_hull_A() )
	)
	{
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "region_specification_A()" ) ;
	}
}

/*
 * convex_A
 *
 * bnf-start
 *   <convex> ::=
 *      LATLON <convex_LatLon>
 *    | CARTESIAN <convex_Cartesian>
 *    | [ J2000 ] <convex_J2000>
 * bnf-end
 */
void convex_A() : 
{
    if( log.isTraceEnabled() ) enterTrace ( "convex_A()" ) ;
    tracker.setType( ConvexType.type ) ;
}
{	
	(
		( <LATLON> convex_LatLon_A() )
		|
		( <CARTESIAN> convex_Cartesian_A() )
		|
		( [ <J2000> ] convex_J2000_A() )
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "convex_A()" ) ;
	}	
}


/*
 * convex_LatLon_A
 *
 * bnf-start
 *   <convex_LatLon> ::= 
 *      <left_paren> <longitude> <comma> <latitude> <comma> <direction> <right_paren>
 *    { <left_paren> <longitude> <comma> <latitude> <comma> <direction> <right_paren> }...
 * bnf-end
 */
void convex_LatLon_A() #ConvexLatLon: 
{
    if( log.isTraceEnabled() ) enterTrace ( "convex_LatLon_A()" ) ;
}
{
	  ( LOOKAHEAD(2)
	    <LEFT_PAREN> numeric_value_expression_S() <COMMA> numeric_value_expression_S() <COMMA>	direction_A() <RIGHT_PAREN> )+
      {
          if( log.isTraceEnabled() ) exitTrace ( "convex_LatLon_A()" ) ;
      }
}


/*
 * convex_Cartesian_A
 *
 * bnf-start
 *   <convex_Cartesian> ::= 
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <comma> <direction> <right_paren>
 *    { <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <comma> <direction> <right_paren> }...
 * bnf-end
 */
void convex_Cartesian_A() #ConvexCartesian : 
{
    if( log.isTraceEnabled() ) enterTrace ( "convex_Cartesian_A()" ) ;
}
{
	  ( LOOKAHEAD(2)
	    <LEFT_PAREN> numeric_value_expression_S() 
	         <COMMA> numeric_value_expression_S()
	         <COMMA> numeric_value_expression_S()  
	         <COMMA> direction_A() <RIGHT_PAREN> )+
      {
          if( log.isTraceEnabled() ) exitTrace ( "convex_Cartesian_A()" ) ;
      }
}


/*
 * convex_J2000_A
 *
 * bnf-start
 *   <convex_J2000> ::= 
 *      <left_paren> <ra> <comma> <dec> <comma> <direction> <right_paren>
 *    { <left_paren> <ra> <comma> <dec> <comma> <direction> <right_paren> }...
 * bnf-end
 */
void convex_J2000_A() #ConvexJ2000 : 
{
    if( log.isTraceEnabled() ) enterTrace ( "convex_J2000_A()" ) ;
}
{
	  ( LOOKAHEAD(2)
	    <LEFT_PAREN> numeric_value_expression_S() <COMMA> numeric_value_expression_S() <COMMA>	direction_A() <RIGHT_PAREN> )+
      {
          if( log.isTraceEnabled() ) exitTrace ( "convex_J2000_A()" ) ;
      }
}

/*
 * box_A
 *
 * bnf-start
 *   <box> ::=
 *      LATLON <box_LatLon>
 *    | CARTESIAN <box_Cartesian>
 *    | [ J2000 ] <box_J2000>
 * bnf-end
 */
void box_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "box_A()" ) ;
	tracker.setType( BoxType.type ) ;
} 
{
	(
		( <LATLON> box_LatLon_A() )
		|
		( <CARTESIAN> box_Cartesian_A() )
		|
		( [ <J2000> ] box_J2000_A() )	
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "box_A()" ) ;	
	}
}

/*
 * box_LatLon_A
 *
 * bnf-start
 *   <box_LatLon> ::= 
 *      <left_paren> <latitude> <comma> <longitude> <comma> <length> <comma> <breadth> <right_paren>
 * bnf-end
 *
 */
void box_LatLon_A() #BoxLatLon : 
{
	if( log.isTraceEnabled() ) enterTrace ( "box_LatLon_A()" ) ;
}
{
	(
	  <LEFT_PAREN> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	 <RIGHT_PAREN> 
   
    )
      {
      	   if( log.isTraceEnabled() ) exitTrace ( "box_LatLon_A()" ) ;
      }
}

/*
 * box_Cartesian_A
 *
 * bnf-start
 *   <box_Cartesian> ::= 
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <comma> 
 *                    <length> <comma> <breadth> <right_paren>
 * bnf-end
 *
 */
void box_Cartesian_A() #BoxCartesian : 
{
	if( log.isTraceEnabled() ) enterTrace ( "box_Cartesian_A()" ) ;
}
{
	(
	  <LEFT_PAREN> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	 <RIGHT_PAREN> 
   
    )
      {
      	   if( log.isTraceEnabled() ) exitTrace ( "box_Cartesian_A()" ) ;
      }
}

/*
 * box_J2000_A
 *
 * bnf-start
 *   <box_J2000> ::= 
 *      <left_paren> <ra> <comma> <dec> <comma> <length> <comma> <breadth> <right_paren>
 * bnf-end
 *
 * bnf-single <length> ::= <numeric_value_expression>
 * bnf-single <breadth> ::= <numeric_value_expression>
 */
void box_J2000_A() #BoxJ2000 : 
{
	if( log.isTraceEnabled() ) enterTrace ( "box_J2000_A()" ) ;
}
{
	(
	  <LEFT_PAREN> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	       <COMMA> numeric_value_expression_S() 
	 <RIGHT_PAREN> 
   
    )
      {
      	   if( log.isTraceEnabled() ) exitTrace ( "box_J2000_A()" ) ;
      }
}


/*
 * circle_A
 *
 * bnf-start
 *  <circle> ::= 
 *     LATLON <circle_LatLon>
 *   | CARTESIAN <circle_Cartesian>
 *   | [ J2000 ] <circle_J2000>
 * bnf-end
 */
void circle_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_A()" ) ;
	tracker.setType( CircleType.type ) ;
}
{
	(
		( <LATLON> circle_LatLon_A() )
		|
		( <CARTESIAN> circle_Cartesian_A() )
		|
		( [ <J2000> ] circle_J2000_A() ) 
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "circle_A()" ) ;	
	}
}

/*
 * circle_LatLon_A
 *
 * bnf-start
 *   <circle_LatLon> ::= 
 *      <left_paren> <latitude> <comma> <longitude> <comma> <radius> <right_paren>
 * bnf-end
 */
void circle_LatLon_A() #CircleLatLon : 
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_LatLon_A()" ) ;
}
{
	 ( <LEFT_PAREN> numeric_value_expression_S() <COMMA> numeric_value_expression_S() <COMMA> radius_A() <RIGHT_PAREN> )
	 {
	 	if( log.isTraceEnabled() ) exitTrace ( "circle_LatLon_A()" ) ;	
	 }
}


/*
 * circle_Cartesian_A
 *
 * bnf-start
 *   <circle_Cartesian> ::= 
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <comma> <radius> <right_paren>
 * bnf-end
 */
void circle_Cartesian_A() #CircleCartesian : 
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_Cartesian_A()" ) ;
}
{
	 ( <LEFT_PAREN> numeric_value_expression_S() 
	        <COMMA> numeric_value_expression_S() 
	        <COMMA> numeric_value_expression_S()
	        <COMMA> radius_A() 
	   <RIGHT_PAREN> )
	 {
	 	if( log.isTraceEnabled() ) exitTrace ( "circle_Cartesian_A()" ) ;	
	 }
}


/*
 * circle_J2000_A
 *
 * bnf-start
 *   <circle_J2000> ::= 
 *      <left_paren> <ra> <comma> <dec> <comma> <radius> <right_paren>
 * bnf-end
 */
void circle_J2000_A() #CircleJ2000 : 
{
	if( log.isTraceEnabled() ) enterTrace ( "circle_J2000_A()" ) ;
}
{
	 ( <LEFT_PAREN> numeric_value_expression_S() <COMMA> numeric_value_expression_S() <COMMA> radius_A() <RIGHT_PAREN> )
	 {
	 	if( log.isTraceEnabled() ) exitTrace ( "circle_J2000_A()" ) ;	
	 }
}

/*
 * polygon_A
 *
 * bnf-start
 *  <polygon> ::= 
 *     LATLON <polygon_LatLon>
 *   | CARTESIAN <polygon_Cartesian>
 *   | [ J2000 ] <polygon_J2000>
 * bnf-end
 */
void polygon_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "polygon_A()" ) ;
	tracker.setType( PolygonType.type ) ;
}
{
	(
		( <LATLON> polygon_LatLon_A() )
		|
		( <CARTESIAN> polygon_Cartesian_A() )
		|
		( [ <J2000> ] polygon_J2000_A() ) 
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "polygon_A()" ) ;	
	}
}

/*
 * polygon_LatLon_A
 *
 * bnf-start
 *   <polygon_LatLon> ::=
 *      <left_paren> <latitude> <comma> <longitude> <right_paren>
 *      <left_paren> <latitude> <comma> <longitude> <right_paren>
 *    { <left_paren> <latitude> <comma> <longitude> <right_paren> }...
 * bnf-end
 */
void polygon_LatLon_A() #PolygonLatLon : 
{
	if( log.isTraceEnabled() ) enterTrace ( "polygon_LatLon_A()" ) ;
}
{
	  (
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
		( LOOKAHEAD(2)
	  	  <LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	  <RIGHT_PAREN> )+ 
	  )
	  {
	  		if( log.isTraceEnabled() ) exitTrace ( "polygon_LatLon_A()" ) ;
	  }
}

/*
 * polygon_Cartesian_A
 *
 * bnf-start
 *   <polygon_Cartesian> ::=
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren>
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren>
 *    { <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren> }...
 * bnf-end
 */
void polygon_Cartesian_A() #PolygonCartesian : 
{
	if( log.isTraceEnabled() ) enterTrace ( "polygon_Cartesian_A()" ) ;
}
{
	  (
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
		( LOOKAHEAD(2)
	  	  <LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	  <RIGHT_PAREN> )+ 
	  )
	  {
	  		if( log.isTraceEnabled() ) exitTrace ( "polygon_Cartesian_A()" ) ;
	  }
}


/*
 * polygon_J2000_A
 *
 * bnf-start
 *   <polygon_J2000> ::=
 *      <left_paren> <ra> <comma> <dec> <right_paren>
 *      <left_paren> <ra> <comma> <dec> <right_paren>
 *    { <left_paren> <ra> <comma> <dec> <right_paren> }...
 * bnf-end
 */
void polygon_J2000_A() #PolygonJ2000 : 
{
	if( log.isTraceEnabled() ) enterTrace ( "polygon_J2000_A()" ) ;
}
{
	  (
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
	  	<LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	<RIGHT_PAREN> 
		( LOOKAHEAD(2)
	  	  <LEFT_PAREN>
		 	numeric_value_expression_S() <COMMA>
		 	numeric_value_expression_S() 
	  	  <RIGHT_PAREN> )+ 
	  )
	  {
	  		if( log.isTraceEnabled() ) exitTrace ( "polygon_J2000_A()" ) ;
	  }
}


/*
 * convex_hull_A
 *
 * bnf-start
 *  <convex_hull> ::= 
 *     LATLON <convex_hull_LatLon>
 *   | CARTESIAN <convex_hull_Cartesian>
 *   | [ J2000 ] <convex_hull_J2000>
 * bnf-end
 */
void convex_hull_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "convex_hull_A()" ) ;
    tracker.setType( ConvexHullType.type ) ;
}
{
	( <LATLON> convex_hull_LatLon_A() )
	|
	( <CARTESIAN> convex_hull_Cartesian_A() )
	|
	( [ <J2000> ] convex_hull_J2000_A() ) 
	{
		if( log.isTraceEnabled() ) exitTrace ( "convex_hull_A()" ) ;
	}
}


/*
 * convex_hull_LatLon_A
 *
 * bnf-start
 *   <convex_hull_LatLon> ::= 
 *      <left_paren> <latitude> <comma> <longitude> <right_paren>
 *      <left_paren> <latitude> <comma> <longitude> <right_paren>
 *    { <left_paren> <latitude> <comma> <longitude> <right_paren> }...
 * bnf-end
 */
void convex_hull_LatLon_A() #ConvexHullLatLon : 
{
	if( log.isTraceEnabled() ) enterTrace ( "convex_hull_LatLon_A()" ) ;
}
{
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	( LOOKAHEAD(2)
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> )+ 
	  
	  {
	  	  if( log.isTraceEnabled() ) exitTrace ( "convex_hull_LatLon_A()" ) ;
	  }
}


/*
 * convex_hull_Cartesian_A
 *
 * bnf-start
 *   <convex_hull_Cartesian> ::= 
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren>
 *      <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren>
 *    { <left_paren> <x_coord> <comma> <y_coord> <comma> <z_coord> <right_paren> }...
 * bnf-end
 */
void convex_hull_Cartesian_A() #ConvexHullCartesian : 
{
	if( log.isTraceEnabled() ) enterTrace ( "convex_hull_Cartesian_A()" ) ;
}
{
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	( LOOKAHEAD(2)
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> )+ 
	  
	  {
	  	  if( log.isTraceEnabled() ) exitTrace ( "convex_hull_Cartesian_A()" ) ;
	  }
}


/*
 * convex_hull_J2000_A
 *
 * bnf-start
 *   <convex_hull_J2000> ::= 
 *      <left_paren> <ra> <comma> <dec> <right_paren>
 *      <left_paren> <ra> <comma> <dec> <right_paren>
 *    { <left_paren> <ra> <comma> <dec> <right_paren> }...
 * bnf-end
 */
void convex_hull_J2000_A() #ConvexHullJ2000 : 
{
	if( log.isTraceEnabled() ) enterTrace ( "convex_hull_J2000_A()" ) ;
}
{
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> 
	( LOOKAHEAD(2)
	  <LEFT_PAREN>
		 numeric_value_expression_S() <COMMA>
		 numeric_value_expression_S() 
	  <RIGHT_PAREN> )+ 
	  
	  {
	  	  if( log.isTraceEnabled() ) exitTrace ( "convex_hull_J2000_A()" ) ;
	  }
}

/*
 * direction_A
 *
 * bnf-start
 *  <direction> ::= [ <sign> ] <unsigned_numeric_literal>
 *  !! The distance along the normal vector where the constraint plane intersects that vector. 
 *  !! If positive, the spherical sector on the far side (seen from the center) is selected.
 *  !! If negative, the point of intersection is in the opposite direction of the vector, resulting in more than a hemisphere.
 *  !! The valid range is -1.0 to +1.0
 *  !! ADQL Note: As far as I can see, there is not room within STC for allowing a symbolic representation / link
 *  !! to something like a column reference or complex expression. Therefore, this has to be a literal.
 * bnf-end
 *
 */
void direction_A() #Direction : 
{
	tracker.push( AdqlCompiler.OFFSET_ELEMENT, HsOffsetType.type ) ;
}
{
	signed_numeric_literal_A()
	{ tracker.pop() ; }
}






/*
 * radius_A
 *
 * bnf-single <radius> ::= <numeric_value_expression>
 * -bnf-start
 * - <radius> ::= <stc_numeric_value_expression>
 * - !! At some point in the future,
 * - !! this could be <numeric_value_expression>
 * -bnf-end
 *
 */
void radius_A() : {}
{
	numeric_value_expression_S()	
	//stc_numeric_value_expression_S()
}

/*
 * stc_numeric_value_expression_S
 *
 *- bnf-start
 *-   <stc_numeric_value_expression> ::=
 *-      [ <sign> ] <unsigned_numeric_literal>
 *- bnf-end
 */
//void stc_numeric_value_expression_S() #STCNumericValueExpression : {}//{//	[//	    t=sign_S() //	    {  if( t!=null ) {//	    	  jjtThis.setSign(t) ;//	       }//	    } //	] //	unsigned_numeric_literal_S()//}


/*
 * qualified_join_S
 *
 * bnf-start
 *  <qualified_join> ::=
 *      <table_reference> [ NATURAL ] [ <join_type> ] JOIN
 *      <table_reference> [ <join_specification> ]
 * bnf-end
 *
 */
void qualified_join_S() #QualifiedJoin : 
{
	if( log.isTraceEnabled() ) enterTrace ( "qualified_join_S()" ) ;
}
{
	//S:
	// <qualified_join> ::=
    //    <table_reference> [ NATURAL ] [ <join_type> ] JOIN
    //    <table_reference> [ <join_specification> ]
	
	(
		tableReferenceBarJoinedTable() 
		[ <NATURAL> ] 
		join_type_A() 
		<JOIN> 
		table_reference_A() 
		[ LOOKAHEAD(3) join_specification_S() ]
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "qualified_join_S()" ) ;
	}
} 


void table_array_fragment() #TableArrayFragment : 
{
    if( log.isTraceEnabled() ) enterTrace ( "table_array_fragment()" ) ;
}
{
	(
	   tableReferenceBarJoinedTable()
	   <COMMA> 
	   table_reference_A() 
	   <SEMICOLON>
	)
	{
	   if( log.isTraceEnabled() ) exitTrace ( "table_array_fragment()" ) ;	
	}
}


/*
 * qualified_name_A
 *  
 *  JL Note: Removed for the moment. Problems with semantic lookahead
 *           made this approach too difficult in the time available.
 * 
 * -bnf-start
 *  -<qualified_name> ::= [ <schema_name> <period> ] <identifier>
 *  -!! SQL92 has [ <schema_name> <period> ] <qualified_identifier>
 * -bnf-end
 *
 */
void qualified_name_A() #QualifiedName : 
{
    if( log.isTraceEnabled() ) enterTrace ( "qualified_name_A()" ) ;
} 
{
	//S:
	// <qualified_name> ::=
    //   [ <schema_name> <period> ] <qualified_identifier>
    
    // JL: LOOKAHEAD requires explanation
    ( [ LOOKAHEAD( schema_name_A() <PERIOD>                 , { ( getToken(3).kind == AdqlStoXConstants.REGULAR_IDENTIFIER                  	   ||                 	   getToken(3).kind == AdqlStoXConstants.DELIMITED_IDENTIFIER                 	 )                 	 &&                  	 ( getToken(4).kind == AdqlStoXConstants.PERIOD )                 	 &&                 	 ( getToken(5).kind == AdqlStoXConstants.REGULAR_IDENTIFIER                  	   ||                 	   getToken(5).kind == AdqlStoXConstants.DELIMITED_IDENTIFIER                 	 )                   }                  )        schema_name_A() <PERIOD> ]    ) 
       identifier_A() 
    {
        if( log.isTraceEnabled() ) exitTrace ( "qualified_name_A()" ) ;	
    }
}

/*
 * schema_name_A
 *
 * bnf-start
 *    <schema_name> ::= [ <catalog_name> <period> ] <unqualified_schema name>
 *    !! ADQL Note:
 *    !! The draft spec has
 *    !! <schema_name> ::= [ <identifier> <period> ] <identifier>
 *    !! which is less informative, but the two are equivalent.
 * bnf-end
 * bnf-single <catalog_name> ::= <identifier>
 * bnf-single <unqualified_schema name> ::= <identifier>
 *
 */
void schema_name_A() #SchemaName : 
{
   if( log.isTraceEnabled() ) enterTrace ( "schema_name_A()" ) ;
}
{
	//S:
	//  <schema name> ::=
	//    [ <catalog name> <period> ] <unqualified schema name>
	[ LOOKAHEAD(3) catalog_name_A() <PERIOD> ] identifier_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "schema_name_A()" ) ;
	}
}

void catalog_name_A() : {}
{
	identifier_A()
}

/*
 * 
 * bnf-start
 *  <qualifier> ::= <table_name> | <correlation_name> 
 * bnf-end
 *
 */
void qualifier_A() : 
{
   if( log.isTraceEnabled() ) enterTrace ( "qualifier_A()" ) ;
}
{
	//S:
	// <qualifier> ::=
    //    <table_name> 
    //  | <correlation_name>

	// Foreshortened, but this is indeed equivalent...
	table_name_A()
	{
		if( log.isTraceEnabled() ) exitTrace ( "qualifier_A()" ) ;
	}
}

/*
 * 
 *
 * bnf-start
 *  <query_specification> ::=
 *      SELECT [ <set_quantifier> ] [ <set_limit> ] <select_list> <table_expression>
 * bnf-end
 *
 * bnf-start
 *  <table_expression> ::=
 *      <from_clause>
 *      [ <where_clause> ]
 *      [ <group_by_clause> ]
 *      [ <having_clause> ]
 *      [ <order_by_clause> ]
 * bnf-end 
 *
 */
void query_specification_A() #Select : 
{
    if( log.isTraceEnabled() ) enterTrace ( "query_specification_A()" ) ;
    tracker.push( compiler.SELECT_ELEMENT, SelectType.type ) ;
}
{ 
	(
	//S:
	// SELECT [ <set_quantifier> ] <select_list> <table_expression>
	//
	// <table_expression> ::=
	//    <from_clause>
    //    [ <where_clause> ]
    //    [ <group_by_clause> ]
    //    [ <having_clause> ]
	 
	//A:
	// Refactored to include <set-limit> and to bring up <table_expression> 
	// into this method. <table_expression> also now includes <order_by_clause>

		<SELECT>
		[ set_quantifier_S() ]
		[ set_limit_A() ] 
		select_list_S() 
		from_clause_S() 
		[ LOOKAHEAD(3) where_clause_S() ] 		
		[ LOOKAHEAD(3) group_by_clause_S() ] 		
		[ LOOKAHEAD(3) having_clause_S() ] 		
		[ LOOKAHEAD(3) order_by_clause_S() ]	
		[ <SEMICOLON> ]
    )
	{ 
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "query_specification_A()" ) ;
	}
}

void row_subquery_S() : {} 
{
	//S:
	// <row_subquery> ::= <subquery>
	subquery_S()	
}

Double double_numeric_literal_A() :
{
	if( log.isTraceEnabled() ) enterTrace ( "double_numeric_literal_A()" ) ;
	Token s = null ;
	Token t = null ;
	Double dnl = null ;
}
{
	( [ <PLUS_SIGN> | s=<MINUS_SIGN> ]  t=<EXACT_NUMERIC_LITERAL> | t=<UNSIGNED_INTEGER> )
	{
		if( t != null ) {
           dnl = new Double( (s!=null ? '-' : '+' ) + t.image ) ;		
		}
		if( log.isTraceEnabled() ) exitTrace ( "double_numeric_literal_A()" ) ;
		return dnl ;
	}
}


ScalarExpressionType row_value_constructor_S() : 
{
	ScalarExpressionType seType = null ;
}
{
	//S:
	// <row_value_constructor> ::=
    //     <row_value_constructor_element>
    //  | <left_paren> <row_value_constructor_list> <right_paren>
    //  | <row_subquery>

	(
		LOOKAHEAD(3)
		row_value_constructor_element_S()
	    | 
	    LOOKAHEAD(2)
	    <LEFT_PAREN> row_value_constructor_list_S() <RIGHT_PAREN>
	    | 
	    row_subquery_S()
	 )
	 { return seType ; }
}

ScalarExpressionType row_value_constructor_element_S() : 
{
	ScalarExpressionType seType = null ;
} 
{
	//S:
	//  <row_value_constructor_element> ::=
    //     <value_expression>
    //   | <null_specification>
    //   | <default_specification>

	value_expression_A()
// adql has nothing to support the embedding of keywords...
//    | 
//    <NULL>
//    | 
//    <SQL_DEFAULT>

	{ return seType ; }
}

void row_value_constructor_list_S() : {}
{
	//S:
	//  <row_value_constructor_list> ::=
    //    <row_value_constructor_element> [ { <comma> <row_value_constructor_element> }... ]

	row_value_constructor_element_S() ( <COMMA> row_value_constructor_element_S() ) *
}

void scalar_subquery_S() : {}
{
	//S:
	// <scalar_subquery> ::= <subquery>
	subquery_S()
}

/*
 * 
 *
 * bnf-start
 *  <search_condition> ::=
 *      <boolean_term>
 *    | <search_condition> OR <boolean_term>
 * bnf-end
 *
 */
void search_condition_S() #SearchCondition : 
{
	if( log.isTraceEnabled() ) enterTrace ( "search_condition_S" ) ;
}
{
	//S:
	// <search_condition> ::=
    //    <boolean_term>
    //  | <search_condition> OR <boolean_term>

    // Refactored to
	// boolean_term() ( <OR> search_condition() )?
	// which I believe is equivalent to the above
//    try {
		( boolean_term_S() 
		  ( <OR>
		    { tracker.push( compiler.CONDITION_ELEMENT, UnionSearchType.type ) ; }	      
		    search_condition_S() 
		    { tracker.pop() ; }
		  )? 
		)
//    }//    catch( ParseException pex ) {//        errorSkipTo( new int[]{ token.kind }, pex ) ;	//    } 
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "search_condition_S" ) ;	
	}
}

//SearchType booleanTermList() : //{//	if( log.isTraceEnabled() ) enterTrace ( "booleanTermList" ) ;//	Stack stack = null ;//	SearchType st = null ;//}//{//	( //	  LOOKAHEAD(3)//	  st=booleanTermSingleton() //	  { if( stack == null )//	  	   stack = new Stack() ;//	  	stack.push( st ) ;//	  } //	)*//	{ //		if( stack != null ) {//			UnionSearchType heldOr = null ;//			SearchType[] conditions = new SearchType[2] ;//			while( stack.empty() == false ) {//				st = (SearchType)stack.pop() ;//				if( heldOr != null ) {//					conditions[0] = st ;//					conditions[1] = heldOr ;//					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;//					orType.setConditionArray( conditions ) ;//					heldOr = orType ;//				}//				else if( stack.empty() == false  ) {//					conditions[0] = (SearchType)stack.pop() ;//					conditions[1] = st ;//					UnionSearchType orType = UnionSearchType.Factory.newInstance() ;//					orType.setConditionArray( conditions ) ;//					heldOr = orType ;//				}//			}//			if( heldOr != null )//				st = heldOr ; //		}	//		if( log.isTraceEnabled() ) exitTrace ( "booleanTermList" ) ;	//		return st ;//	}//}////SearchType booleanTermSingleton() ://{//	if( log.isTraceEnabled() ) enterTrace ( "booleanTermSingleton" ) ;//	SearchType st = null ;//	Token t = null ;//}//{////	t=<OR>{if(t!=null){_lt(UnionSearchType.type);_lp(CONDITION_ELEMENT);}}  //	st=boolean_term_S() //	{ //		_lp() ;//		if( log.isTraceEnabled() ) exitTrace ( "booleanTermSingleton" ) ;//		return st ; //	}//}

/*
 * select_list_S
 *
 * bnf-start
 *  <select_list> ::=
 *      <asterisk>
 *    | <select_sublist> [ { <comma> <select_sublist> }... ]
 * bnf-end
 *
 */
void select_list_S() #SelectionList : 
{
	if( log.isTraceEnabled() ) enterTrace ( "select_list_S()" ) ;
	tracker.push( compiler.SELECTION_LIST_ELEMENT, SelectionListType.type ) ;
}
{
	//S:
	// <select_list> ::=
	//   <asterisk>
    // | <select_sublist> [ { <comma> <select_sublist> }... ]
    try {
		(
			allSelectionItem()
			| 
			( select_sublist_A( true ) ( <COMMA> select_sublist_A( false ) )* )		
		)
    }    catch( ParseException pex ) {
    	compiler.errorSkipTo( new int[] { AdqlStoXConstants.FROM }, pex ) ;    }
    finally {
    	tracker.pop() ;
    	if( log.isTraceEnabled() ) exitTrace ( "select_list_S()" ) ;	
    }
	
}

void allSelectionItem() #AllSelectionItem : 
{ tracker.push( compiler.ITEM_ELEMENT, AllSelectionItemType.type ) ; }
{
	<ASTERISK>
    { tracker.pop() ; }
}

/*
 * select_sublist_A
 *
 * bnf-start
 *  <select_sublist> ::= <derived_column> | <qualifier> <period> <asterisk>
 * bnf-end
 *
 */
void select_sublist_A( boolean first ) #SelectSublist : 
{ 
	if( log.isTraceEnabled() ) enterTrace ( "select_sublist_A()" ) ;
	tracker.push( compiler.ITEM_ELEMENT ) ; 
	if( first ) {
		compiler.selectSublistEnsureNotComma() ;
	}
}
{   
	//S:
	// <select_sublist> ::= <derived_column> | <qualifier> <period> <asterisk>
    try {
       LOOKAHEAD(3) 
	   ( derived_column_S() { compiler.selectSublistEnsureCommaOrFrom() ; } )
	   |
	   ( qualifierPeriodAsterisk() { compiler.selectSublistEnsureCommaOrFrom() ; } )
	   |
	   { compiler.selectSublistError( first, new ParseException( "select_sublist error" ) ) ; }
    }    catch( ParseException pex ) {       compiler.selectSublistError( first, pex ) ;	    }
    finally {
       tracker.pop() ;
       if( log.isTraceEnabled() ) exitTrace ( "select_sublist_A()" ) ;
    }
	
}

void qualifierPeriodAsterisk() #QualifierPeriodAsterisk : 
{
	if( log.isTraceEnabled() ) enterTrace ( "qualifierPeriodAsterisk()" ) ;
}
{
	qualifier_A() <PERIOD> <ASTERISK>
	{
		if( log.isTraceEnabled() ) exitTrace ( "qualifierPeriodAsterisk()" ) ;
	}
}


/*
 * derived_column_S
 *
 * bnf-start
 *  <derived_column> ::= <value_expression> [ <as_clause> ]
 * bnf-end
 * bnf-start
 *  <as_clause> ::= [ AS ] <column_name>
 * bnf-end
 */
void derived_column_S() #DerivedColumn : 
{
	if( log.isTraceEnabled() ) enterTrace ( "derived_column_S()" ) ;
}
{
	//S:
	// <derived_column> ::= <value_expression> [ <as_clause> ]
	// <as_clause> ::= [ AS ] <column_name>
	( value_expression_A() [ [ <AS> ] column_name_S() ] ) 
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "derived_column_S()" ) ;
	}	
}

/*
 * set_function_specification_S
 *
 * bnf-start
 *  <set_function_specification> ::=
 *      COUNT <left_paren> <asterisk> <right_paren>
 *    | <general_set_function>
 * bnf-end
 *
 */
void set_function_specification_S() #SetFunctionSpecification : {}
{
	//S:
	//  <set_function_specification> ::=
    //     COUNT <left_paren> <asterisk> <right_paren>
    //   | <general_set_function>


	( 
	  LOOKAHEAD(3)
	  ( <COUNT> <LEFT_PAREN> <ASTERISK> <RIGHT_PAREN> ) 
	  |
	  general_set_function_A()
	)
}

void set_function_specification_part_fragment() #SetFunctionSpecificationPartFragment : 
{
	if( log.isTraceEnabled() ) enterTrace ( "set_function_specification_part_fragment()" ) ;
}
{
		( ( <ASTERISK> | value_expression_A() ) )
		{
		  if( log.isTraceEnabled() ) exitTrace ( "set_function_specification_part_fragment()" ) ;
		}
}

/*
 * 
 *
 * bnf-start
 *  <set_limit> ::= TOP <unsigned_integer>
 * bnf-end
 *
 */
void set_limit_A() #Restrict : 
{ if( log.isTraceEnabled() ) enterTrace ( "set_limit_A" ) ;
  tracker.push( compiler.RESTRICT_ELEMENT, SelectionLimitType.type ) ; 
  Token t = null ;
}
{
	// There is no equivalent in the SQL/92 standard
	//
	try { 
		( <TOP> 
		  t=<UNSIGNED_INTEGER> 
		  {
		  	if( t!=null ) {
				try { 
				   jjtThis.setLimit( ( new Integer( t.image )).intValue() ) ;
				}
				catch( NumberFormatException ex ) {
				   throw new ParseException( ex.getLocalizedMessage() ) ;	
				}
			}
		  }
		)
	}	catch( ParseException pex ) {
	    tracker.setError( pex.getLocalizedMessage() ) ;	}
	{ 		
		tracker.pop() ;
        if( log.isTraceEnabled() ) exitTrace ( "set_limit_A" ) ;
	}
}

/*
 * set_quantifier_S
 *
 * bnf-single <set_quantifier> ::= DISTINCT | ALL
 *
 */
void set_quantifier_S() #Allow : 
{ tracker.push( compiler.ALLOW_ELEMENT, SelectionOptionType.type ) ; }
{
	//S:
	// <set_quantifier> ::= DISTINCT | ALL
	//
	( <DISTINCT> | <ALL> )
	{ tracker.pop() ; }
}


void single_datetime_field_S() : {}
{
	//S:
	//  <single_datetime_field> ::=
    //     <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]
    //   | SECOND [ <left_paren> <interval_leading_field_precision> [ <comma> <interval_fractional_seconds_precision> ] <right_paren> ]

	nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
    | 
    <SECOND> [ <LEFT_PAREN> interval_leading_field_precision_S() [ <COMMA> interval_fractional_seconds_precision_S() ] <RIGHT_PAREN> ]
}

void start_field_S() : {}
{
	//S:
	//  <start_field> ::=
    //    <non-second_datetime_field> [ <left_paren> <interval_leading_field_precision> <right_paren> ]

    nonsecond_datetime_field_S() [ <LEFT_PAREN> interval_leading_field_precision_S() <RIGHT_PAREN> ]
}

/*
 * string_value_expression_A()
 *
 * bnf-start
 *  <string_value_expression> ::=
 *      <character_value_expression>
 *  !! For information, SQL92 also supports <bit_value_expression>
 * bnf-end
 *
 */
void string_value_expression_A() : {}
{
	//S:
	// <string_value_expression> ::=
    //    <character_value_expression>
    //  | <bit_value_expression>
	character_value_expression_S()
}

/*
 * subquery_S
 *
 */
SearchType subquery_S() : 
{
	SearchType st = null ;
}
{
	//S:
	//  <subquery> ::= <left_paren> <query_expression> <right_paren>
	( <LEFT_PAREN> query_expression_S() <RIGHT_PAREN> )
	{ return st ; }		
}


void quantified_comparison_predicate_S() : {}
{
	//S:
	// <quantified_comparison_predicate> ::=
    //    <row_value_constructor> <comp_op> <quantifier> <table_subquery>

	row_value_constructor_S() comp_op_S() quantifier_S() table_subquery_A()	
}

void quantifier_S() : {}
{
	//S:
	// <quantifier> ::= <all> | <some>
	//
	// <all> ::= ALL
	// <some> ::= SOME | ANY
	//
	<ALL> | ( <SOME> | <ANY> )	
}

void query_expression_S() : {}
{
	//S:
	// <query_expression> ::=
    //    <non-join_query_expression>
    //  | <joined_table>
	
	LOOKAHEAD(3)
	nonjoin_query_expression_S()
	|
	joined_table_S()
}

void query_primary_S() : {}
{
	//S:
	// <query_primary> ::=
    //    <non-join_query_primary>
    //  | <joined_table>

    LOOKAHEAD(3)
 	nonjoin_query_primary_S()
    | 
    joined_table_S()
}


void query_term_S() : {}
{
	//S:
	// <query_term> ::=
    //    <non-join_query_term>
    //  | <joined_table>

	LOOKAHEAD(2)
	nonjoin_query_term_S()
	|
	joined_table_S()	
}

void corresponding_spec_S() : {}
{
	//S:
	// <corresponding_spec> ::=
    //    CORRESPONDING [ BY <left_paren> <corresponding_column_list> <right_paren> ]
	<CORRESPONDING> [ <BY> <LEFT_PAREN> corresponding_column_list_S() <RIGHT_PAREN> ] 
}
    
void corresponding_column_list_S() : {}
{
	//S:
	// <corresponding_column_list> ::= <column_name_list>
	column_name_list_S()	
}

/*
 * cross_join_S
 *
 *-bnf-start
 *- <cross_join> ::=
 *-     <table_reference> CROSS JOIN <table_reference>
 *-bnf-end
 *
 */
JoinTableType cross_join_S() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "cross_join_S()" ) ;
	JoinTableType jtType = null ;
	FromTableType fType1 = null ;
	FromTableType fType2 = null ;
}
{
	//S:
	// <cross_join> ::=
    //    <table_reference> CROSS JOIN <table_reference>
	( tableReferenceBarJoinedTable() <CROSS_JOIN> table_reference_A() )
	{
	   if( fType2 != null ) {
	      jtType = JoinTableType.Factory.newInstance() ;
	      jtType.setQualifier( JoinTableQualifierType.CROSS ) ;
	      FromTableType[] fttArray = new FromTableType[2] ;
	      fttArray[0] = fType1 ;
	      fttArray[1] = fType2 ;
	      ArrayOfFromTableType tableArray = ArrayOfFromTableType.Factory.newInstance() ;
	      tableArray.setFromTableTypeArray( fttArray ) ;
	      jtType.setTables( tableArray ) ;
	   }
	   if( log.isTraceEnabled() ) exitTrace ( "cross_join_S()" ) ;
	   return jtType ;	
	}
}


void nonjoin_query_expression_S() : {}
{
	//S:
	// <non-join_query_expression> ::=
    //    <non-join_query_term>
    //  | <query_expression> UNION  [ ALL ] [ <corresponding_spec> ] <query_term>
    //  | <query_expression> EXCEPT [ ALL ] [ <corresponding_spec> ] <query_term>

//	Refactored to...
//	But I'm uncertain the refactoring is the same as the original!
	LOOKAHEAD(4)
	( query_term_S() ( (<UNION> | <EXCEPT> ) [ <ALL> ] [ corresponding_spec_S() ] query_term_S() )* )
	|
	nonjoin_query_term_S()
}

void nonjoin_query_term_S() : {}
{
	//S:
	// <non-join_query_term> ::=
    //    <non-join_query_primary>
    //  | <query_term> INTERSECT [ ALL ] [ <corresponding_spec> ] <query_primary>

	// Refactored to...
	LOOKAHEAD(3)
	nonjoin_query_primary_S()
	|
	( query_primary_S() <INTERSECT> [ <ALL> ] [ corresponding_spec_S() ] query_primary_S() )	
}

void nonjoin_query_primary_S() : {}
{
	//S:
	//  <non-join_query_primary> ::=
    //    <simple_table>
    //  | <left_paren> <non-join_query_expression> <right_paren>
    
	simple_table_S()
	|
	( <LEFT_PAREN> nonjoin_query_expression_S() <RIGHT_PAREN> )
}

void nonsecond_datetime_field_S() : {}
{
	//S:
	// <non-second_datetime_field> ::= YEAR | MONTH | DAY | HOUR | MINUTE
	<YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE>
}

void simple_table_S() : {}
{
	//S:
	// <simple_table> ::=
    //    <query_specification>
    //  | <table_value_constructor>
    //  | <explicit_table>

	query_specification_A()
	|
	table_value_constructor_S()
	|
	explicit_table_S()	
}

/*
 * table_name_A
 *
 * bnf-start
 *  <table_name> ::= [ <schema_name> <period> ] <identifier>
 * bnf-end
 *
 */
void table_name_A() #TableName : 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_name_A()" ) ;
}
{
	//S:
	// <table_name> ::=
    //  <qualified_name> | <qualified_local_table_name>
	[ LOOKAHEAD(4) schema_name_A() <PERIOD> ] identifier_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "table_name_A()" ) ;
	}
}

/* 
 * table_reference_A
 *
 * bnf-start
 *  <table_reference> ::=
 *     <table_name> [ <correlation_specification> ]
 *   | <table_subquery> <correlation_specification>
 *   | <joined_table>
 * bnf-end
 *
 */
void table_reference_A() #Table : 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_reference_A()" ) ;
} 
{
	//S:
	// <table reference> ::=
    //     <table name> [ <correlation specification> ]
    //   | <derived table> <correlation specification>
    //   | <joined table>
	try {
	  (
	  // Sequence slightly refactored...
	  // JL: These lookaheads probably need adjusting.
	    LOOKAHEAD(20)
	    joined_table_S()
	    |
		LOOKAHEAD(20)
	    table_name_A() [ correlation_specification_A() ]
		| 
		LOOKAHEAD(10)
		table_subquery_A() correlation_specification_A()
		
	  )
	}
	catch( ParseException pex ) {
		compiler.errorSkipTo( compiler.TABLE_REF_SKIP_TO, pex ) ;
	}
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "table_reference_A()" ) ;
	} 
}

/*
 * correlation_specification_A
 *
 * bnf-single <correlation_specification> ::= [ AS ] <correlation_name>
 *
 */
void correlation_specification_A() : {}
{
	//S:
	//  <correlation specification>    ::=
    //     [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
	[ <AS> ] correlation_name_S()
}

// Adaptation of <table_reference>
void tableReferenceBarJoinedTable() #TableReferenceBarJoinedTable : 
{
	if( log.isTraceEnabled() ) enterTrace ( "tableReferenceBarJoinedTable()" ) ;
}
{
//	( ( LOOKAHEAD(5) schema_name_A() <PERIOD> )? table_name_A() [ [ <AS> ] correlation_name_S() ] )
		LOOKAHEAD(20)
	    table_name_A() [ correlation_specification_A() ]
		| 
		table_subquery_A() correlation_specification_A()
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "tableReferenceBarJoinedTable()" ) ;
	}
}


/*
 * table_subquery_A
 *
 * bnf-start
 *  <table_subquery> ::= 
 *      <left_paren> <query_specification> <right_paren>
 *  !! SQL92 uses <subquery>. Not sure whether this is relevant.
 * bnf-end
 *
 */
void table_subquery_A() #TableSubQuery: 
{
	if( log.isTraceEnabled() ) enterTrace ( "table_subquery_A" ) ;
}
{
	//S:
	// <table_subquery> ::= <subquery>
	( <LEFT_PAREN> query_specification_A() <RIGHT_PAREN> )	
	{
		if( log.isTraceEnabled() ) exitTrace ( "table_subquery_A" ) ;
	}
}

void table_value_constructor_S() : {}
{
	//S:
	//  <table_value_constructor> ::=
    //     VALUES <table_value_constructor_list>

	<VALUES> table_value_constructor_list_S()
}

void table_value_constructor_list_S() : {}
{
	//S:
	// <table_value_constructor_list> ::=
    //    <row_value_constructor> [ { <comma> <row_value_constructor> }... ]

	row_value_constructor_S() ( <COMMA> row_value_constructor_S() )*	
}

/*
 * term_S
 *
 * bnf-start
 *  <term> ::=
 *      <factor>
 *    | <term> <asterisk> <factor>
 *    | <term> <solidus> <factor>
 * bnf-end
 *
 */
void term_S() #Term :  
{
	if( log.isTraceEnabled() ) enterTrace ( "term_S()" ) ;
	Token t = null ;
}
{
	//S:
	//  <term> ::=
    //     <factor>
    //   | <term> <asterisk> <factor>
    //   | <term> <solidus> <factor>

	// refactored
	// factor() ( LOOKAHEAD(2) (<ASTERISK> | <SOLIDUS> ) term() )?
	( 
	   factor_S() 
	   ( LOOKAHEAD(2) 
	     ( 
	       ( t=<ASTERISK> | t=<SOLIDUS> ) 
	       {   if( t!=null ) {
	           	  jjtThis.setOperator(t);
	           }
	       } 
	     ) 
	     term_S() 
	   )? 	
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "term_S()" ) ;
	}
}

void time_fractional_seconds_precision_S() : {}
{
	//S:
	// <time_fractional_seconds_precision> ::= <unsigned_integer>
	<UNSIGNED_INTEGER> 	
}

void time_precision_S() : {}
{
	//S:
	// <time_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void timestamp_precision_S() : {}
{
	//S:
	// <timestamp_precision> ::= <time_fractional_seconds_precision>
	time_fractional_seconds_precision_S()	
}

void time_zone_S() : {}
{
	//S:
	//  <time_zone> ::= AT <time_zone_specifier>
    //  <time_zone_specifier> ::= LOCAL | TIME ZONE <interval_value_expression>

	// refactored
    <AT> ( <LOCAL> | ( <TIME_ZONE> interval_value_expression_S() ) ) 
}

/*
 * 
 *
 * bnf-start
 *  <trig_function> ::=
 *      ACOS <left_paren> <numeric_value_expression> <right_paren>
 *    | ASIN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN <left_paren> <numeric_value_expression> <right_paren>
 *    | ATAN2 <left_paren> <numeric_value_expression> <comma> <numeric_value_expression> <right_paren>
 *    | COS <left_paren> <numeric_value_expression> <right_paren>
 *    | COT <left_paren> <numeric_value_expression> <right_paren>
 *    | SIN <left_paren> <numeric_value_expression> <right_paren>
 *    | TAN <left_paren> <numeric_value_expression> <right_paren>
 * bnf-end
 *
 */
void trig_function_A() #TrigFunction : 
{
	if( log.isTraceEnabled() ) enterTrace ( "trig_function_A()" ) ;
	tracker.setType( TrigonometricFunctionType.type ) ;
}
{
	(
		<ACOS> <LEFT_PAREN>
		          { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		       <RIGHT_PAREN>
		|
		<ASIN> <LEFT_PAREN> 
		          { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		       <RIGHT_PAREN>
		|
        <ATAN> <LEFT_PAREN> 
                  { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
               <RIGHT_PAREN>
		|
		( <ATAN2> <LEFT_PAREN> 
		             { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		          <COMMA> 
		             { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		          <RIGHT_PAREN> )
		|
		<COS> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
		|
		<COT> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; }
		      <RIGHT_PAREN>
		|
		<SIN> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
		|
		<TAN> <LEFT_PAREN> 
		         { tracker.push( compiler.ARG_ELEMENT ) ; } numeric_value_expression_S() { tracker.pop() ; } 
		      <RIGHT_PAREN>
	)
	{
		if( log.isTraceEnabled() ) exitTrace ( "trig_function_A()" ) ;
	}
}

void unique_predicate_S() : {}
{
	//S:
	// <unique_predicate> ::= UNIQUE <table_subquery>
	<UNIQUE> table_subquery_A()	
}

/*
 * unsigned_literal_S
 *
 * bnf-single <unsigned_literal> ::= <unsigned_numeric_literal> | <general_literal>
 *
 */
void unsigned_literal_S() : {}
{
	//S: 
	// <unsigned_literal> ::=
    //    <unsigned_numeric_literal>
    //  | <general_literal>
	unsigned_numeric_literal_S()
    | 
    general_literal_A()
}

/*
 * unsigned_numeric_literal_S
 *
 * bnf-start
 *  <unsigned_numeric_literal> ::=
 *     <exact_numeric_literal>
 *     |
 *     <approximate_numeric_literal>
 * bnf-end
 *
 */
void unsigned_numeric_literal_S() : 
{
    if( log.isTraceEnabled() ) enterTrace ( "unsigned_numeric_literal_S()" ) ;
} 
{
	//S:
	//  <unsigned_numeric_literal> ::=
    //      <exact_numeric_literal>
    //    | <approximate_numeric_literal>
    exact_numeric_literal_S( +1 )
    |
	approximate_numeric_literal_S( +1 ) 
	{
		if( log.isTraceEnabled() ) exitTrace ( "unsigned_numeric_literal_S()" ) ;
	}
}


void signed_numeric_literal_A() : 
{
	if( log.isTraceEnabled() ) enterTrace ( "signed_numeric_literal_A()" ) ;
	Token t = null ;
	int signIndicator = +1 ;
}
{
	[ t=sign_S() ]
	{
		if( t != null ) {
			if( t.image == "-" ) {
			   signIndicator = -1 ;
			}
		}
		
	}
	exact_numeric_literal_S( signIndicator )
    |
	approximate_numeric_literal_S( signIndicator ) 
	{
		if( log.isTraceEnabled() ) exitTrace ( "signed_numeric_literal_A()" ) ;
	}
}
	


/*
 * approximate_numeric_literal_S
 *
 * bnf-start
 *  <approximate_numeric_literal> ::= <mantissa>E<exponent>
 * bnf-end
 *
 */
void approximate_numeric_literal_S( int sign ) #ApproximateNumericLiteral : 
{
	if( log.isTraceEnabled() ) enterTrace ( "approximate_numeric_literal_S()" ) ;
	jjtThis.setSign( sign ) ;
} 
{
	<APPROXIMATE_NUMERIC_LITERAL>
	{
		if( log.isTraceEnabled() ) exitTrace ( "approximate_numeric_literal_S()" ) ;
	}	
}

/*
 * unsigned_value_specification_S
 *
 * bnf-start
 *  <unsigned_value_specification> ::=
 *      <unsigned_literal>
 *    | <general_value_specification>
 *  !! ADQL Note:
 *  !! The draft spec does not have <general_value_specification>
 * bnf-end
 *
 */
void unsigned_value_specification_S() : {}
{
	//S:
	// <unsigned_value_specification> ::=
    //     <unsigned_literal>
    //   | <general_value_specification>
	unsigned_literal_S()
	|
	general_value_specification_A()
}

/*
 * value_expression_A
 *
 * bnf-start
 *  <value_expression> ::=
 *      <numeric_value_expression>
 *    | <string_value_expression>
 *  !! For information only, SQL92 supports <datetime_value_expression> and <interval_value_expression>
 * bnf-end
 *
 */
void value_expression_A() #ValueExpression : 
{
    if( log.isTraceEnabled() ) enterTrace ( "value_expression_A()" ) ;
} 
{
	//S:
	// <value_expression> ::=
	//    <numeric_value_expression>
    //  | <string_value_expression>
    //  | <datetime_value_expression>
    //  | <interval_value_expression>
    try {
		(
		LOOKAHEAD(16) 
		numeric_value_expression_S() 
		|
		LOOKAHEAD(16) 	
		string_value_expression_A() 
		// JL. foreshortened. At present there seems no accommodation for
		// datetime and interval expressions in adql
	//	|
	//	LOOKAHEAD(3) 
	//	dateTimeValueExpression() 
	//	|
	//	intervalValueExpression()
	
		)
    }    catch( ParseException pex ) {
    	if( log.isDebugEnabled() ) log.debug( "value_expression_A() throwing pex" ) ;		throw pex ;    }
	{ 
		if( log.isTraceEnabled() ) exitTrace ( "value_expression_A()" ) ;
	}
	
}

/*
 * variable_specification_A
 *
 * bnf-start
 * <variable_specification> ::=
 *     <dollar> <left_brace> <regular_identifier> <right_brace>
 *   | VAR <regular_identifier>
 *  !! ADQL Note:
 *  !! Not in the draft spec.
 *  !! Part of an ADQL experiment to specify symbolic scripting variables.
 * bnf-end
 *
 */
void variable_specification_A() #VariableSpec : 
{
	if( log.isTraceEnabled() ) enterTrace ( "variable_specification_A" ) ;
	Token t ;
}
{
	//S:
	// <variable_specification> ::=
    //    <embedded_variable_name> [ <indicator_variable> ]
    
	( <DOLLAR> <LBRACE> t=<REGULAR_IDENTIFIER> <RBRACE> 
	  |
	  <VAR> t=<REGULAR_IDENTIFIER> )
	{
		if( t != null ) {
			jjtThis.setVariable( t.image ) ;
		}
        if( log.isTraceEnabled() ) exitTrace ( "variable_specification_A" ) ;
	}
}

/*
 * where_clause_S
 *
 * bnf-single <where_clause> ::= WHERE <search_condition>
 *
 */
void where_clause_S() #Where : 
{
	if( log.isTraceEnabled() ) enterTrace ( "where_clause_S" ) ;
	tracker.push( compiler.WHERE_ELEMENT, WhereType.type ) ;
}
{
	//S:
	// WHERE <search_condition>
    try {   	
	  ( <WHERE> search_condition_S() )
    }
    catch( ParseException pex ) {
       compiler.errorSkipTo( compiler.WHERE_SKIP_TO, pex ) ;	
    }
	{ 			
		tracker.pop() ;
		if( log.isTraceEnabled() ) exitTrace ( "where_clause_S" ) ;
	}
}
    
/* 
$Log: AdqlStoX.jjt,v $
Revision 1.34  2007/07/30 09:03:47  jl99
BNF tidy

Revision 1.33  2007/07/29 11:27:27  jl99
User defined function calls accommodated with metadata

Revision 1.32  2007/07/28 14:14:58  jl99
User defined function calls accommodated

Revision 1.31  2007/07/28 08:29:41  jl99
BNF tidy

Revision 1.30  2007/07/28 08:00:17  jl99
Sort key and symbolic variables done.

Revision 1.29  2007/07/28 07:38:11  jl99
Symbolic variable specification accommodated

Revision 1.28  2007/07/27 21:46:03  jl99
Accommodation for selecting all columns from one table.

Revision 1.27  2007/07/27 18:32:30  jl99
tidy

Revision 1.26  2007/07/27 15:32:32  jl99
In predicate now supports value_expression in lists

Revision 1.25  2007/07/27 15:09:37  jl99
set_quantifier now correctly supported

Revision 1.24  2007/07/27 11:11:00  jl99
Updated bnd documentation

Revision 1.23  2007/07/27 10:36:24  jl99
Schema name and relaxing of correlation in place

Revision 1.22  2007/07/26 17:51:02  jl99
Partial rejig (not yet finished) to accommodate schema name

Revision 1.21  2007/07/25 20:24:29  jl99
Partial rejig (not yet finished) to accommodate schema name

Revision 1.20  2007/07/25 16:05:22  jl99
Added: character value expression and (implicitly) the ability to concatenate such expressions.

Revision 1.19  2007/07/25 13:47:37  jl99
Shell of region types set up

Revision 1.18  2007/07/25 12:28:16  jl99
Introduced the tracker object into the AST_classes as a basis for tracking semantic errors.

Revision 1.17  2007/07/24 11:37:11  jl99
Region

Revision 1.16  2007/07/23 09:50:09  jl99
Region

Revision 1.15  2007/07/19 17:53:57  jl99
Region

Revision 1.14  2007/07/18 10:02:05  jl99
Region

Revision 1.13  2007/07/17 16:54:01  jl99
Region

Revision 1.12  2007/07/17 11:17:43  jl99
Region

Revision 1.11  2007/07/16 21:06:10  jl99
Attempt to accommodate element linking with STC.

Revision 1.10  2007/07/13 15:56:02  jl99
Region

Revision 1.9  2007/07/13 15:17:02  jl99
Region

Revision 1.8  2007/07/13 14:36:57  jl99
Region

Revision 1.7  2007/07/13 11:27:57  jl99
BNF updated

Revision 1.6  2007/07/13 11:03:47  jl99
NamedColumnsJoin added

Revision 1.5  2007/07/13 08:21:32  jl99
Extending <join specification>

Revision 1.4  2007/07/12 13:40:58  jl99
Added extensive BNF comments which highlight differences from ADQL draft spec

Revision 1.3  2007/07/10 21:04:39  jl99
some javadoc added

Revision 1.2  2007/07/02 18:12:58  jl99
Exists and Null predicates added

Revision 1.1  2007/06/28 09:07:45  jl99
Creation of temporary project adql2 to explore complexities of moving
ADQL to conform to the draft spec of April 2007.

Revision 1.36  2007/06/17 15:17:20  jl99
AdqlStoX.jtt alone...
Minor correction to definitions that hide aliases H and M (upper or lower case).
Passed all 134 unit tests, and thought it worth the risk to commit straight to head,
for the sake of speed. The following documents the changes...
// <H: "h"> causes severe problems with "h" appearing on its own, as this
//          consumes the token. Eg: table alias h is not then workable. Changed to
|   < H : "_h_" >
// < M : "m" > causes severe problems with "m" appearing on its own, as this
//          consumes the token. Eg: table alias m is not then workable. Changed to
|   < M : "_m_" >

Revision 1.35  2007/06/06 18:19:28  jl99
Merge of branch adql-jl-2135

Revision 1.34.2.36  2007/06/06 16:51:28  jl99
Tidy just prior to merge of branch adql-jl-2135

Revision 1.34.2.35  2007/06/06 10:53:22  jl99
Code tidy just prior to merge of branch adql-jl-2135

Revision 1.34.2.34  2007/05/29 18:59:12  jl99
Correction to set_function_specification_part_fragment

Revision 1.34.2.33  2007/05/22 10:35:35  jl99
Refinement to user defined functions.

Revision 1.34.2.32  2007/05/21 17:39:38  jl99
First experiment with user defined functions.

Revision 1.34.2.31  2007/05/18 12:45:29  jl99
Bug fix on the predicate clause.

Revision 1.34.2.30  2007/05/17 11:25:11  jl99
Code tidy

Revision 1.34.2.29  2007/05/10 18:57:55  jl99
Reorg to improve AST_ classes and memory usage: fragment processing

Revision 1.34.2.28  2007/05/09 13:58:08  jl99
Reorg to improve AST_ classes and memory usage: fragment processing

Revision 1.34.2.27  2007/05/09 08:51:11  jl99
Reorg to improve AST_ classes and memory usage.

Revision 1.34.2.26  2007/05/08 15:52:35  jl99
Reorg to improve AST_ classes and memory usage.

Revision 1.34.2.25  2007/05/01 08:35:18  jl99
Updating unit test in line with improvement in comment processing.

Revision 1.34.2.24  2007/04/30 17:23:24  jl99
Better comment processing.

Revision 1.34.2.23  2007/04/30 10:22:23  jl99
Better comment processing.

Revision 1.34.2.22  2007/04/27 20:40:55  jl99
Improvements to comment processing.

Revision 1.34.2.21  2007/04/26 14:50:34  jl99
Strengthening unit tests

Revision 1.34.2.20  2007/04/26 09:02:35  jl99
Tidying tracing.

Revision 1.34.2.19  2007/04/25 07:49:48  jl99
Minor improvements to tracing

Revision 1.34.2.18  2007/04/24 17:30:56  jl99
First working version that includes multiple archives.

Revision 1.34.2.17  2007/04/24 14:43:26  jl99
First attempt at including multiple archives.

Revision 1.34.2.16  2007/04/23 12:31:35  jl99
Introduction of module AdqlCompiler to contain majority of java code previously in AdqlStoX.
AdqlStoX is a non-java source module which must be pre-processed to produce java.
AdqlCompiler makes for ease of maintenance and clarity.

Revision 1.34.2.15  2007/04/20 21:52:34  jl99
Tighter fragment processing

Revision 1.34.2.14  2007/04/19 11:49:50  jl99
Changes to public methods to accommodate multiple error recording.

Revision 1.34.2.13  2007/04/17 15:45:29  jl99
Rationalizing multiple error reporting

Revision 1.34.2.12  2007/04/04 17:34:52  jl99
Improvements to compiling beyond the first error.

Revision 1.34.2.11  2007/04/02 16:26:35  jl99
Improvements to compiling beyond the first error.

Revision 1.34.2.10  2007/03/23 21:22:32  jl99
First attempts to continue compiling beyond the first error.

Revision 1.34.2.9  2007/03/14 12:55:54  jl99
Restrict (eg: top 1000) misbehaving

Revision 1.34.2.8  2007/03/10 14:00:42  jl99
Fixed bug in set_limit_A()

Revision 1.34.2.7  2007/03/09 09:21:16  jl99
Started to use position tracking for errors. At present only in debugging messages.

Revision 1.34.2.6  2007/03/08 17:44:47  jl99
Position Tracking

Revision 1.34.2.5  2007/03/08 16:28:03  jl99
Position Tracking

Revision 1.34.2.4  2007/03/06 11:59:44  jl99
Tracking comments: principles revised and processing of trailing comment added.
The tracking principles are in process of revision.
The writing of comments no longer needs the tracker object.
Tracking will be used for multiple error recording.

Revision 1.34.2.3  2007/03/04 22:54:09  jl99
More coverage of comments.

Revision 1.34.2.2  2007/03/03 00:22:20  jl99
Tracking comments: principles established.

Revision 1.34.2.1  2007/03/02 21:14:13  jl99
Tracking comments introduced. First attempt to track position.

Revision 1.34  2007/01/26 09:45:53  jl99
Merge of adql-jl-2031-a into HEAD

Revision 1.33.4.8  2007/01/25 14:13:21  jl99
Logging adjustments

Revision 1.33.4.7  2007/01/19 08:30:43  jl99
Improvements to nested processing, plus the inclusion of approximate numeric literals into the grammar

Revision 1.33.4.6  2007/01/12 12:16:22  jl99
Renamed userDefinedObject and associated methods to generatedObject

Revision 1.33.4.5  2007/01/11 13:55:00  jl99
The technique for undertaking fragment processing is now probably complete.

Revision 1.33.4.4  2007/01/11 12:46:45  jl99
Made ending <SEMICOLON> optional on full query

Revision 1.33.4.3  2007/01/11 12:09:12  jl99
Improved fragment processing.

Revision 1.33.4.2  2007/01/10 22:39:24  jl99
(1) ParseException generated for unprocessed "dangling" source.
(2) Improved fragment processing.

Revision 1.33.4.1  2007/01/10 13:58:59  jl99
First commit after cvs recovery.

Revision 1.33.2.4  2006-12-19 14:22:36  jl99
More revision and refinement of fragment processing: more elements and types

Revision 1.33.2.3  2006/12/12 11:34:53  jl99
Revision of fragment processing.

Revision 1.33.2.2  2006/12/09 19:26:23  jl99
More fragments defined.

Revision 1.33.2.1  2006/11/30 16:42:51  jl99
More fragments defined.

Revision 1.33  2006/11/27 18:05:47  jl99
Merge of branch adql-jl-2020

Revision 1.32.2.3  2006/11/27 16:35:28  jl99
Adopted a more short term approach to Delimited Identifiers. In our terms these are quoted identifiers, eg: "2xmmp" as a table name. We now allow quoted identifiers (partially) in order to differentiate possible name clashes but do not format them into the xml (that's the partial bit). This is acceptable since the dsa still works on xml and does not need quotes to differentiate name clashes.

Revision 1.32.2.2  2006/11/17 13:45:45  jl99
More on compiling fragments of ADQL

Revision 1.32.2.1  2006/11/16 22:11:34  jl99
First experiment with compiling fragments

Revision 1.32  2006/11/13 21:02:18  jl99
Slight code rationalization

Revision 1.31  2006/11/12 20:06:00  jl99
Removed support for Cross Joins.
Difficult to support this with the current Adlq/x schema which has a join condition as mandatory.

Revision 1.30  2006/10/28 22:08:05  jl99
Rejig to enable more speedy adaptation to aliased expressions
when these become feasible. At present ADQL/x is broken in this area.

Revision 1.29  2006/10/27 14:29:56  jl99
Made alliases for tables compulsary. Not sure this is such a good idea,
but it obeys the adql/x 1.01 standard.

Revision 1.28  2006/10/25 13:22:15  jl99
Extra convenience methods to trigger compilations with differing output
(XmlBeans, XmlText, Xml Dom Node etc)

Revision 1.27  2006/10/23 22:39:10  jl99
Corrections to embedded BNF documentation

Revision 1.26  2006/10/22 20:47:10  jl99
More BNF Documentation

Revision 1.25  2006/10/20 13:02:10  jl99
More BNF Documentation

Revision 1.24  2006/10/20 08:53:25  jl99
BNF Documentation

Revision 1.23  2006/10/18 22:35:53  jl99
Some systematization of token definitions.

Revision 1.22  2006/10/16 15:35:49  jl99
Region: Circle and Ellipse at STCregion v1.10.
This is not the latest spec for region. But is appropriate as a prototype.

Revision 1.21  2006/10/16 11:37:46  jl99
First Attempt at Region.

Revision 1.20  2006/10/14 16:14:52  jl99
like_predicate complete (according to adql/x v1.01a).

Revision 1.19  2006/10/14 13:09:19  jl99
in_predicate complete (according to adql/x v1.01a).

Revision 1.18  2006/10/13 21:01:59  jl99
in_predicate begun.

Revision 1.17  2006/10/13 13:29:24  jl99
(1) Some logging added.
(2) Improved processing for unary values.

Revision 1.16  2006/10/11 20:36:25  jl99
(1) Change of signature to exec method. Now throws a ParserException.

Revision 1.15  2006/10/02 09:03:35  jl99
First attempt at mavenizing project

Revision 1.14  2006/09/28 15:08:55  jl99
Errors corrected.

Revision 1.13  2006/09/28 08:50:02  jl99
Reorg on method naming convention: complete.

Revision 1.12  2006/09/28 08:43:29  jl99
Reorg on method naming convention: 4.

Revision 1.11  2006/09/27 20:51:55  jl99
Reorg on method naming convention: 3.

Revision 1.10  2006/09/26 13:44:11  jl99
Reorg on method naming convention: 1.

*/


