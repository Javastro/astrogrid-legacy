/* Generated By: AdqlStoX.jjt,v 1.15 2007/07/19 17&JJTree: Do not edit this line. AST_ConvexJ2000.java */

package org.astrogrid.adql;

import org.apache.xmlbeans.XmlObject;
import org.astrogrid.adql.beans.LinkedListType;
import org.astrogrid.adql.beans.ScalarExpressionType;
import org.astrogrid.adql.beans.AtomType;

import org.astrogrid.stc.beans.*;
import org.apache.commons.logging.Log ;
import org.apache.commons.logging.LogFactory ;

public class AST_ConvexJ2000 extends SimpleNode {

    private static Log log = LogFactory.getLog( AST_ConvexJ2000.class ) ;

    public AST_ConvexJ2000(AdqlStoX p, int id) {
        super(p, id);
    }

    public void buildXmlTree( XmlObject xo ) {
        if( log.isTraceEnabled() ) enterTrace( log, "AST_ConvexJ2000.buildXmlTree()" ) ; 

        ( (AST_RegionPredicate)this.parent ).setAstroCoordSystem_J2000() ;
        //
        // Establish where we can create linked elements for this region...
        LinkedListType llt = this.getCurrentLinkedElementList() ;
        int currentLinkedArrayPosition = llt.sizeOfLinkedElementArray() ;
        //
        // Calculate the number of half spaces requested...
        ConvexType convex = (ConvexType)xo.changeType( ConvexType.type ) ;
        int childCount = jjtGetNumChildren() ;
        int halfSpaceCount = childCount / 3 ;      
        //
        // Create a HalfSpaceType for each half space requested...
        for( int i=0; i<halfSpaceCount; i++ ) {

            HalfspaceType halfSpace = convex.addNewHalfspace() ;         
            //
            // This needs to be a spherical coordinate vector.
            // It is the unit vector that is normal to the plane that forms a constraint for a convex...
            Double3Type d3t = halfSpace.addNewVector() ;
            //
            // Need to transform ra and dec into a spherical coordinate vector, but how???
            // Here comes ra...
            ScalarExpressionType setRa = llt.addNewLinkedElement() ;
            children[0].buildXmlTree( setRa ) ;
            setRa = (ScalarExpressionType)children[0].getGeneratedObject() ;         
            Double d = this.unpackNumericLiteral( setRa ) ;
            if( d != null ) {
                // ????.setDoubleValue( d.doubleValue() ) ;
                llt.removeLinkedElement( currentLinkedArrayPosition ) ;
            }
            else {
                String uid = this.formUniqueID() ;
                setRa.setId( uid ) ;
                // ????.setIdref( uid ) ;
                currentLinkedArrayPosition++ ;
            }
            //
            // Here comes dec...
            ScalarExpressionType setDec = llt.addNewLinkedElement() ;
            children[1].buildXmlTree( setDec ) ;
            setDec = (ScalarExpressionType)children[1].getGeneratedObject() ;
            d = this.unpackNumericLiteral( setDec ) ;
            if( d != null ) {
                // ????.setDoubleValue( d.doubleValue() ) ;
                llt.removeLinkedElement( currentLinkedArrayPosition ) ;
            }
            else {
                String uid = this.formUniqueID() ;
                setDec.setId( uid ) ;
                // ????.setIdref( uid ) ;
                currentLinkedArrayPosition++ ;
            }        
            //
            // The distance along the normal vector where the constraint plane intersects that vector.
            // If positive, the spherical sector on the far side (seen from the center) is selected.
            // If negative, the point of intersection is in the opposite direction of the vector, 
            // resulting in more than a hemisphere.
            // The valid range is -1.0 to +1.0
            //
            // Jeff Note. Looks to me as if the offset has to be a numeric literal (literal!).
            AtomType setHsOffset = AtomType.Factory.newInstance() ;
            children[2].buildXmlTree( setHsOffset ) ;
            setHsOffset = (AtomType)children[2].getGeneratedObject() ;     
            d = this.unpackNumericLiteral( setHsOffset ) ;
            halfSpace.setOffset( d.doubleValue() ) ;
        }

        this.generatedObject = convex ;
        super.buildXmlTree( convex ) ;
        if( log.isTraceEnabled() ) exitTrace( log, "AST_ConvexJ2000.buildXmlTree()" ) ; 
    }

}
