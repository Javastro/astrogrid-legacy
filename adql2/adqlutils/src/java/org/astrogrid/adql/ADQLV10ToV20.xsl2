<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
		xmlns:ad1="http://www.ivoa.net/xml/ADQL/v1.0"
		xmlns:adql="http://www.ivoa.net/xml/v2.0/adql"
		xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:fragment="http://www.w3.org/2001/02/xml-fragment"
		exclude-result-prefixes="ad1 xsd fragment"  >
	
	<!-- 
		Stylesheet to convert ADQL/x v1.0 to ADQL/x v2.0
		Version 1.0 - first release - July 3, 2007
		Jeff Lusted - University of Leicester
		jl99@star.le.ac.uk
	 -->
	
    <xsl:output method="xml" encoding="UTF-8" indent="yes"/>   	
    
  	<xsl:param name="ad1Prefix" select="'v1'"/>
    <xsl:param name="ad2Prefix" select="'adql'"/>
    <xsl:param name="xsiPrefix" select="'xsi'"/>
    
    <xsl:param name="ad1NS" select="'http://www.ivoa.net/xml/ADQL/v1.0'" />
    <xsl:param name="fragmentNS" select="'http://www.w3.org/2001/02/xml-fragment'"/>
    <xsl:param name="ad2NS" select="'http://www.ivoa.net/xml/v2.0/adql'" />
    <xsl:param name="xsiNS" select="'http://www.w3.org/2001/XMLSchema-instance'"/>
    
    <!--+
        | Identity template that ensures everything gets copied.
        | We override this to change specific differences between versions.
        +--> 
    <xsl:template match="@*|node()">
        <xsl:copy>
	       <xsl:apply-templates select="@*|node()"/>
	    </xsl:copy>
	</xsl:template>
	
	<!--+
        | Sponge category for any elements that do not require change
        | apart from the namespace and prefix change.
        +-->
	<xsl:template match="*[ namespace-uri() = $ad1NS ]">
        <xsl:element name="{$ad2Prefix}:{local-name()}" namespace="{$ad2NS}">	     	
			<xsl:apply-templates select="@*|node()"/>	
		</xsl:element> 
	</xsl:template>
	
	<!--+
        | Sponge category for any fragment elements.
        | It could probable be fitted into above template, but simplicity first.
        | xmlns:v1="http://www.ivoa.net/xml/ADQL/v1.0" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        +-->
	<xsl:template match="xml-fragment">
        <xsl:element name="{local-name()}" namespace="{namespace-uri()}">  	
			<xsl:apply-templates select="@*|node()"/>	
		</xsl:element> 
	</xsl:template>
	
	<!--+
        | Expression within OrderBy needs have column name only,
        | so we drop Table and Archive...
        +--> 
	<xsl:template match="ad1:OrderBy/ad1:Item/ad1:Expression">
        <xsl:element name="{$ad2Prefix}:{local-name()}" namespace="{$ad2NS}">
            <xsl:for-each select="@*">
            	<xsl:choose>
			    	<xsl:when test="local-name() = 'Table'"/>
			    	<xsl:when test="local-name() = 'Archive'"/>
					<xsl:otherwise>
						<xsl:apply-templates select="."/> 
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>	
		</xsl:element> 
	</xsl:template>
	
	<!--+
        | Joins are now more complex. A simple condition is no longer sufficient structure...
        +-->        
	<xsl:template match="ad1:Table[substring-after(@xsi:type, ':') = 'joinTableType']/ad1:Condition | ad1:Table[@xsi:type = 'joinTableType']/ad1:Condition">
       <xsl:element name="{$ad2Prefix}:JoinSpecification" namespace="{$ad2NS}">
            <xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                <xsl:value-of select="$ad2Prefix" />
			 	<xsl:text>:joinConditionType</xsl:text>
			</xsl:attribute>
            <xsl:element name="{$ad2Prefix}:Condition" namespace="{$ad2NS}">
                <xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    <xsl:value-of select="$ad2Prefix" />
			 	    <xsl:text>:comparisonPredType</xsl:text>
			    </xsl:attribute>
			    <xsl:apply-templates select="@*"/> 
            	<xsl:apply-templates select="node()"/>            	
            </xsl:element>	
        </xsl:element> 
	</xsl:template>
	
	<!--+
        | ConstantListSet of In predicate and Not In predicate no longer sufficient.
        +-->  
	<xsl:template match="*[substring-after(@xsi:type, ':') = 'ConstantListSet'] | *[@xsi:type = 'ConstantListSet']">
       <xsl:element name="{$ad2Prefix}:Set" namespace="{$ad2NS}">
            <xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                <xsl:value-of select="$ad2Prefix" />
			 	<xsl:text>:InListSet</xsl:text>
			</xsl:attribute>
			<xsl:for-each select="ad1:Item">
				<xsl:element name="{$ad2Prefix}:Item" namespace="{$ad2NS}">
                	<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    	<xsl:value-of select="$ad2Prefix" />
			 	    	<xsl:text>:atomType</xsl:text>
			    	</xsl:attribute>
			    	<xsl:element name="{$ad2Prefix}:Literal" namespace="{$ad2NS}">
                		<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    		<xsl:value-of select="$ad2Prefix" />
			 	    		<xsl:text>:</xsl:text>
			 	    		<xsl:value-of select="substring-after(@xsi:type, ':')" />
			    		</xsl:attribute>	
			    		<xsl:apply-templates select="@*"/>            	
            		</xsl:element>			    	          	
            	</xsl:element>	
			</xsl:for-each>           
        </xsl:element> 
	</xsl:template>
	
	<!--+
        | subQuerySet changed to be a simple holder of QueryExpression...
        +-->  
	<xsl:template match="*[substring-after(@xsi:type, ':') = 'subQuerySet'] | *[@xsi:type = 'subQuerySet']">
       <xsl:element name="{$ad2Prefix}:Set" namespace="{$ad2NS}">
            <xsl:apply-templates select="@*"/>
            <xsl:element name="{$ad2Prefix}:QueryExpression" namespace="{$ad2NS}">           
				<xsl:for-each select="*">		
					<xsl:choose>	
			    		<xsl:when test="self::node()[local-name() = 'selection']" >
							<xsl:element name="{$ad2Prefix}:Select" namespace="{$ad2NS}">
                				<xsl:apply-templates select="@*|node()"/>      	
            				</xsl:element>
						</xsl:when>
			    		<xsl:otherwise>
							<xsl:apply-templates select="@*|node()"/>     	
						</xsl:otherwise>
					</xsl:choose>			
				</xsl:for-each>  			
			</xsl:element>         
        </xsl:element> 
	</xsl:template>
	
	<!--+
        | Children of Like and Not Like predicates no longer sufficient.
        +-->  
	<xsl:template match="*[substring-after(@xsi:type, ':') = 'likePredType'] | *[@xsi:type = 'likePredType']
	                   | *[substring-after(@xsi:type, ':') = 'notLikePredType'] | *[@xsi:type = 'notLikePredType']">                  
	    <xsl:element name="{$ad2Prefix}:{local-name()}" namespace="{$ad2NS}">
	    	<xsl:apply-templates select="@*"/>
	   	 	<xsl:for-each select="*">
	   			<xsl:choose>
					<xsl:when test="self::node()[local-name() = 'Arg']" >
						<xsl:element name="{$ad2Prefix}:Arg" namespace="{$ad2NS}">
                			<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    			<xsl:value-of select="$ad2Prefix" />
			 	    			<xsl:text>:characterValueExpressionType</xsl:text>			 	    		
			    			</xsl:attribute>  
			    			<xsl:element name="{$ad2Prefix}:CharacterFactor" namespace="{$ad2NS}">		    			
			    				<xsl:apply-templates select="@*|node()"/>            	
            				</xsl:element>           	
            			</xsl:element>
					</xsl:when>
					<xsl:when test="self::node()[local-name() = 'Pattern']" >
						<xsl:element name="{$ad2Prefix}:Pattern" namespace="{$ad2NS}">
                			<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    			<xsl:value-of select="$ad2Prefix" />
			 	    			<xsl:text>:characterValueExpressionType</xsl:text>			 	    		
			    			</xsl:attribute>
			    			<xsl:element name="{$ad2Prefix}:CharacterFactor" namespace="{$ad2NS}">					    			
                				<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
                    				<xsl:value-of select="$ad2Prefix" />
			 	    				<xsl:text>:atomType</xsl:text>
			    				</xsl:attribute>
			    				<xsl:apply-templates select="@*|node()"/>	          	
            				</xsl:element>			    	          	        	
            			</xsl:element>
					</xsl:when>
					<xsl:otherwise>
						<xsl:element name="context-debug">
	   	 					<xsl:attribute name="current-context">
                    			<xsl:value-of select="name()" />		 	    		
			    			</xsl:attribute>
			    			<xsl:attribute name="context-self">
                    			<xsl:value-of select="self::node" />		 	    		
			    			</xsl:attribute>
	   	 				</xsl:element>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
		</xsl:element>                   
	</xsl:template>
	   
	<!--+
        | Template for type attributes belonging to Schema-instance.
        +--> 
    <xsl:template match="@xsi:type">
		<xsl:attribute name="xsi:type" namespace="{$xsiNS}">
			<xsl:choose>
				<!-- correction of a typo -->
			    <xsl:when test="substring-after( . , ':' ) = 'jointTableQualifierType'">
			 	    <xsl:value-of select="$ad2Prefix" />
			 	    <xsl:text>:joinTableQualifierType</xsl:text>
			 	</xsl:when>
			 	<!-- change the prefix for ADQL version 1 to version 2 -->
			 	<xsl:when test="substring-before( . , ':' ) = $ad1Prefix">
			 	    <xsl:value-of select="$ad2Prefix" />
			 	    <xsl:text>:</xsl:text>
			 		<xsl:value-of select="substring-after( . , ':' )" />
			 	</xsl:when>
			 	<!-- copy anything else as is -->
				<xsl:otherwise>
					<xsl:value-of select="." />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:attribute>
	</xsl:template>
	
	<!--+
        | Template for v1 namespace.
        +--> 
    <xsl:template match="@xmlns:v1">
		<xsl:attribute name="@xmlns:{$ad2Prefix}" namespace="{namespace-uri()}">			
			<xsl:value-of select="$ad2NS" />
		</xsl:attribute>
	</xsl:template>
	
	<!--+
        | Tables can now be qualified by catalog and schema.
        | Previously they could be qualified (if at all) by archive.
        | Archive has been replaced by Schema...
        | Keep an eye on this. I'm not sure I understand all the ramifications 
        | and may have misjudged the complexity of the situation.
        + --> 
    <xsl:template match="@Archive">
		<xsl:attribute name="Schema">			
			 <xsl:value-of select="." />
		</xsl:attribute>
	</xsl:template>
		
</xsl:stylesheet>

